#include"ebench.h"
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
//#define _USE_MATH_DEFINES
#include<math.h>
#include<process.h>
#include<immintrin.h>
static const char file[]=__FILE__;


	#define OLS4_OPTIMAL_CLAMP
	#define NORMALIZED_VALUES
//	#define OLS4_DEBUG
//	#define OLS4_SHOWKERNEL


#define ALLOCASSERT(C)\
	do\
		if(C)\
		{\
			LOG_ERROR("Alloc error");\
			return;\
		}\
	while(0)

//#define OLS4_RMAX 4
//#define OLS4_CTXSIZE (2*(OLS4_RMAX+1)*OLS4_RMAX)
#define PADX 8
#define PADY 8
#define PREC 8
int ols4_period=8;
double ols4_lr[4]={0.001, 0.001, 0.001, 0.001};
unsigned char ols4_mask[4][OLS4_CTXSIZE+1]=//MSB {E3 E2 E1 E0  P3 P2 P1 P0} LSB,  last element can't exceed 1<<(kc<<1) for causality
{
#if 1
	{
		0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00,
		0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00,
		0x00, 0x01, 0x01, 0x07, 0x07, 0x07, 0x01, 0x01, 0x01,
		0x01, 0x01, 0x01, 0x07, 0x00,
	},
	{
		0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x00,
		0x00, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x00,
		0x00, 0x02, 0x02, 0x07, 0x07, 0x07, 0x02, 0x02, 0x02,
		0x02, 0x02, 0x02, 0x07, 0x01,
	},
	{
		0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x00,
		0x00, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x00,
		0x00, 0x04, 0x04, 0x07, 0x07, 0x07, 0x04, 0x04, 0x04,
		0x04, 0x04, 0x04, 0x07, 0x03,
	},
#endif
#if 0
	{
		0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
		0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
		0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
		0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
		0x07, 0x07, 0x07, 0x07, 0x00,
	},
	{
		0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
		0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
		0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
		0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
		0x07, 0x07, 0x07, 0x07, 0x01,
	},
	{
		0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
		0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
		0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
		0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
		0x07, 0x07, 0x07, 0x07, 0x03,
	},
#endif
#if 0
	{
		0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
		0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
		0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
		0x01, 0x01, 0x01, 0x01, 0x07, 0x07, 0x01, 0x01, 0x01,
		0x01, 0x01, 0x01, 0x07, 0x00,
	},
	{
		0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
		0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
		0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
		0x02, 0x02, 0x02, 0x02, 0x07, 0x07, 0x02, 0x02, 0x02,
		0x02, 0x02, 0x02, 0x07, 0x01,
	},
	{
		0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
		0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
		0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
		0x04, 0x04, 0x04, 0x04, 0x07, 0x07, 0x04, 0x04, 0x04,
		0x04, 0x04, 0x04, 0x07, 0x03,
	},
#endif
#if 0
	{
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00,
		0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00,
		0x00, 0x00, 0x07, 0x07, 0x00,
	},
	{
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00,
		0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00,
		0x00, 0x00, 0x07, 0x07, 0x01,
	},
	{
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00,
		0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00,
		0x00, 0x00, 0x07, 0x07, 0x03,
	},
#endif
#if 0
	{
		0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x01, 0x07, 0x07, 0x07, 0x01, 0x00, 0x00,
		0x00, 0x00, 0x01, 0x07, 0x00,
	},
	{
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x02, 0x02, 0x02, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x02, 0x07, 0x07, 0x07, 0x02, 0x00, 0x00,
		0x02, 0x02, 0x02, 0x07, 0x01,
	},
	{
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x04, 0x07, 0x07, 0x07, 0x04, 0x04, 0x04,
		0x00, 0x00, 0x04, 0x07, 0x03,
	},
#endif
};
void pred_ols4(Image *src, int period, double *lrs, unsigned char *mask0, unsigned char *mask1, unsigned char *mask2, unsigned char *mask3, int fwd)
{
	double t_start=time_sec();
	if(loud_transforms)
		DisableProcessWindowsGhosting();
	unsigned char *masks[]=
	{
		mask0,
		mask1,
		mask2,
		mask3,
	};
	int ctxsize[4]={0};
	for(int kc=0;kc<4;++kc)
	{
		for(int km=0;km<OLS4_CTXSIZE+1;++km)
		{
			int val=masks[kc][km];
			if(km==OLS4_CTXSIZE)//causality mask
				val&=(1<<(kc<<1))-1;
			val-=val>>1&0x55;
			val=(val>>2&0x33)+(val&0x33);
			val=(val>>4)+(val&15);
			ctxsize[kc]+=val;
			//ctxsize[kc]+=hammingweight16(masks[kc][km]);
		}
	}
	double *ctx[4]={0}, *vec[4]={0};
	int matsize[4]={0};
	double *cov[4]={0}, *cholesky[4]={0};
	double *params[4]={0};
	for(int kc=0;kc<4;++kc)
	{
		if(ctxsize[kc])
		{
			ptrdiff_t vecsize=sizeof(double)*ctxsize[kc];
			matsize[kc]=ctxsize[kc]*ctxsize[kc];
			ctx[kc]=(double*)malloc(vecsize);
			vec[kc]=(double*)malloc(vecsize);
			cov[kc]=(double*)malloc(sizeof(double)*matsize[kc]);
			cholesky[kc]=(double*)malloc(sizeof(double)*matsize[kc]);
			params[kc]=(double*)malloc(vecsize);
			ALLOCASSERT(!ctx[kc]||!vec[kc]||!cov[kc]||!params[kc]);
			memset(ctx[kc], 0, vecsize);
			memset(vec[kc], 0, vecsize);
			memset(cov[kc], 0, sizeof(double)*matsize[kc]);
			memset(cholesky[kc], 0, sizeof(double)*matsize[kc]);
			memset(params[kc], 0, vecsize);
		}
	}

	size_t bufsize=(src->iw+PADX*2LL)*sizeof(int[4*PADY*2]);//PADY padded rows * 4 channels * {pixels, errors}
	int *pixels=(int*)malloc(bufsize);
	ALLOCASSERT(!pixels);
	memset(pixels, 0, bufsize);

	int nlevels[]=
	{
		1<<src->depth[0],
		1<<src->depth[1],
		1<<src->depth[2],
		1<<src->depth[3],
	};
	int half[]=
	{
		nlevels[0]>>1,
		nlevels[1]>>1,
		nlevels[2]>>1,
		nlevels[3]>>1,
	};
#ifdef NORMALIZED_VALUES
	double gains[]=
	{
		1./nlevels[0],
		1./nlevels[1],
		1./nlevels[2],
		1./nlevels[3],
	};
#endif
	int fwdmask=-fwd;
	int successcount=0;
	for(int ky=0, idx=0, olsidx=1;ky<src->ih;++ky)
	{
		int *rows[PADY];
		for(int k=0;k<PADY;++k)
			rows[k]=pixels+(((src->iw+PADX*2LL)*(((size_t)ky-k)&(PADY-1))+PADX)<<3);
		for(int kx=0;kx<src->iw;++kx, ++olsidx)
		{
			for(int kc=0;kc<4;++kc, ++idx)
			{
				int nparams=ctxsize[kc];
				if(!nparams)
					continue;
				unsigned char *ctxmask=masks[kc];
#ifdef NORMALIZED_VALUES
				double gain=gains[kc];
#endif
				double *curr_ctx=ctx[kc];
				double *curr_vec=vec[kc];
				double *curr_cov=cov[kc];
				double *curr_cholesky=cholesky[kc];
				double *curr_params=params[kc];
				double fpred;
#ifdef OLS4_OPTIMAL_CLAMP
				int temp=rows[0][kc-8];//W
				int cmin=temp, cmax=temp;
				temp=rows[1][kc];//N
				UPDATE_MIN(cmin, temp);
				UPDATE_MAX(cmax, temp);
				temp=rows[1][kc+8];//NE
				UPDATE_MIN(cmin, temp);
				UPDATE_MAX(cmax, temp);
#endif
				const unsigned char *ctxcell=ctxmask;
				for(int ky2=-OLS4_RMAX, loadidx=0;ky2<=0;++ky2)
				{
					for(int kx2=-OLS4_RMAX;kx2<=OLS4_RMAX;++kx2, ++ctxcell)
					{
						int *comp=rows[-ky2]+((size_t)kx2<<3);
						for(int kc2=0;kc2<8;++kc2)
						{
							if(!ky2&&!kx2&&kc2==kc)
								goto finish_loading;
#ifdef OLS4_DEBUG
							if(ctxcell-ctxmask>=OLS4_CTXSIZE+1)
								LOG_ERROR("");
#endif
							//int included=ctxmask[(OLS4_RMAX<<1|1)*(ky2+OLS4_RMAX)+kx2+OLS4_RMAX]>>kc2&1;
							if(*ctxcell>>kc2&1)
							{
#ifdef OLS4_DEBUG
								if(loadidx>=nparams)//
									LOG_ERROR("");
#endif
#ifdef NORMALIZED_VALUES
								curr_ctx[loadidx]=comp[kc2]*gain;
#else
								curr_ctx[loadidx]=comp[kc2];
#endif
#ifdef OLS4_SHOWKERNEL
								if(kx==src->iw/2&&ky==src->ih/2)
									src->data[(src->iw*(ky+ky2)+kx+kx2)<<2|kc]=32*(kc+1);
#endif
								++loadidx;
							}
						}
					}
				}
			finish_loading:
				fpred=0;
				for(int k=0;k<nparams;++k)
					fpred+=curr_params[k]*curr_ctx[k];
#ifdef OLS4_DEBUG
				double fpred0=fpred;//
#endif
#ifdef OLS4_OPTIMAL_CLAMP
#ifdef NORMALIZED_VALUES
				fpred*=nlevels[kc];
#endif
				fpred=CLAMP(cmin, fpred, cmax);
#else
#ifdef NORMALIZED_VALUES
				fpred=CLAMP(-(1<<PREC), fpred, (1<<PREC)-1);
				fpred*=nlevels[kc];
#endif
#endif
				int pred=(int)round(fpred);

				int val=src->data[idx];
#ifdef OLS4_DEBUG
				if(!kc&&kx==4&&ky==4)//
					printf("");
#endif

				if(fwd)
				{
					rows[0][kc+0]=val<<PREC;//pixel
					val-=(pred+(1<<PREC>>1)-1)>>PREC;
					val+=half[kc];
					val&=nlevels[kc]-1;
					val-=half[kc];
				}
				else
				{
					val+=(pred+(1<<PREC>>1)-1)>>PREC;
					val+=half[kc];
					val&=nlevels[kc]-1;
					val-=half[kc];
					rows[0][kc+0]=val<<PREC;//pixel
				}
				src->data[idx]=val;
#ifdef OLS4_SHOWKERNEL
				src->data[idx]=-64;
#endif
				rows[0][kc+4]=rows[0][kc+0]-pred;//high-res error

				double lr=lrs[kc];
				for(int ky2=0, midx=0;ky2<nparams;++ky2)
				{
					for(int kx2=0;kx2<nparams;++kx2, ++midx)
						curr_cov[midx]+=(curr_ctx[kx2]*curr_ctx[ky2]-curr_cov[midx])*lr;
				}
#ifdef NORMALIZED_VALUES
				double lval=rows[0][kc+0]*gain;
#else
				double lval=rows[0][kc+0];
#endif
				for(int k=0, midx=0;k<nparams;++k)
					curr_vec[k]+=(lval*curr_ctx[k]-curr_vec[k])*lr;
				if(olsidx==period)//OLS solver by Cholesky decomposition from paq8px
				{
					int success=1;
					double sum;
					int n=nparams;
					memcpy(curr_cholesky, curr_cov, sizeof(double)*matsize[kc]);
					for(int k=0;k<matsize[kc];k+=n+1)
						curr_cholesky[k]+=0.1;
					for(int i=0;i<n;++i)
					{
						for(int j=0;j<i;++j)
						{
							sum=curr_cholesky[i*n+j];
							for(int k=0;k<j;++k)
								sum-=curr_cholesky[i*n+k]*curr_cholesky[j*n+k];
							curr_cholesky[i*n+j]=sum/curr_cholesky[j*n+j];
						}
						sum=curr_cholesky[i*n+i];
						for(int k=0;k<i;++k)
							sum-=curr_cholesky[i*n+k]*curr_cholesky[i*n+k];
						if(sum<=1e-8)
						{
							success=0;
							break;
						}
						curr_cholesky[i*n+i]=sqrt(sum);
					}
					if(success)
					{
						for(int i=0;i<n;++i)
						{
							sum=curr_vec[i];
							for(int j=0;j<i;++j)
								sum-=curr_cholesky[i*n+j]*curr_params[j];
							curr_params[i]=sum/curr_cholesky[i*n+i];
						}
						for(int i=n-1;i>=0;--i)
						{
							sum=curr_params[i];
							for(int j=i+1;j<n;++j)
								sum-=curr_cholesky[j*n+i]*curr_params[j];
							curr_params[i]=sum/curr_cholesky[i*n+i];
						}
						++successcount;
					}
				}
			}
			olsidx&=-(olsidx<period);
			//if(olsidx==period)
			//	olsidx=0;
			for(int k=0;k<PADY;++k)
				rows[k]+=8;
		}
		if(loud_transforms)
			set_window_title("%d/%d = %7.3lf%%  OLS4 rate %lf%%  %lf sec", ky+1, src->ih, 100.*(ky+1)/src->ih, 100.*successcount*period/(src->nch*src->iw*(ky+1)), time_sec()-t_start);
	}
	if(loud_transforms)
		set_window_title("OLS4 %lf%%  %lf sec {%d %d %d %d} params",
			100.*successcount*period/(src->nch*src->iw*src->ih),
			time_sec()-t_start,
			ctxsize[0],
			ctxsize[1],
			ctxsize[2],
			ctxsize[3]
		);
	for(int kc=0;kc<4;++kc)
	{
		if(ctxsize[kc])
		{
			free(ctx[kc]);
			free(vec[kc]);
			free(cov[kc]);
			free(cholesky[kc]);
			free(params[kc]);
		}
	}
	free(pixels);
}