#ifdef _MSC_VER
#	ifndef _CRT_SECURE_NO_WARNINGS
#		define _CRT_SECURE_NO_WARNINGS
#	endif
#elif defined __linux__ && !defined _GNU_SOURCE
#	define _GNU_SOURCE
#	include<stddef.h>//ptrdiff_t
#endif
#include<stdint.h>
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<stdarg.h>
#define _USE_MATH_DEFINES
#include<math.h>
#include<sys/stat.h>
#if defined _MSC_VER || defined _WIN32
#define WIN32_LEAN_AND_MEAN
#include<Windows.h>
#else
#include<time.h>
#endif
#include<immintrin.h>


#ifdef _MSC_VER
	#define LOUD
	#define PROFILE_SIZE
	#define ENABLE_GUIDE
	#define FIFOVAL
#endif


	#define USE_L1


#define PREDLIST\
	PRED(N)\
	PRED(W)\
	PRED(2*N-NN)\
	PRED(2*W-WW)\
	PRED(3*(N-NN)+NNN)\
	PRED(3*(W-WW)+WWW)\
	PRED(N+W-NW)\

//c32
#if 0
#define PREDLIST\
	PRED(N)\
	PRED(W)\
	PRED(3*(N-NN)+NNN)\
	PRED(3*(W-WW)+WWW)\
	PRED(W+NE-N)\
	PRED((WWWW+WWW+NNN+NEE+NEEE+NEEEE-2*NW)/4)\
	PRED(N+W-NW)\
	PRED(N+NE-NNE)\

#endif

enum
{
	DCTsize32,
	DCTsize16,
	DCTsize8,
	DCTsize4,

	BLOCK0X=32,
	BLOCK0Y=32,
	BLOCK1X=16,
	BLOCK1Y=16,
	BLOCK2X=8,
	BLOCK2Y=8,
	BLOCK3X=4,
	BLOCK3Y=4,

	SHIFT=18,
#define PRED(...) +1
	NPREDS=PREDLIST,
#undef  PRED

	//XPAD=8,
	//NCH=3,
	//NROWS=4,
	//NVAL=2,

	GRBITS=3,

	NCTX_DC=18,
	NCTX_AC=32,
	NCTX=NCTX_DC+4*NCTX_AC,
	
	NLEVELS=256,
};

//runtime
#if 1
#define CLAMP2(X, LO, HI)\
	do\
	{\
		if((X)<(LO))X=LO;\
		if((X)>(HI))X=HI;\
	}while(0)
#ifdef _MSC_VER
#	define	ALIGN(N) __declspec(align(N))
#	define AWM_INLINE __forceinline static
#else
#	define	ALIGN(N) __attribute__((aligned(N)))
#	define AWM_INLINE __attribute__((always_inline)) inline static
#	ifndef _countof
#		define _countof(A) (sizeof(A)/sizeof(*(A)))
#	endif
#endif
#if defined _M_X64 || defined __x86_64__
#define FLOOR_LOG2(X)\
	(sizeof(X)==8?63-(int32_t)_lzcnt_u64(X):31-_lzcnt_u32((uint32_t)(X)))
#else
AWM_INLINE int floor_log2_64(uint64_t n)
{
	int	logn=-!n;
	int	sh=(n>=1ULL<<32)<<5;	logn+=sh, n>>=sh;
		sh=(n>=1<<16)<<4;	logn+=sh, n>>=sh;
		sh=(n>=1<< 8)<<3;	logn+=sh, n>>=sh;
		sh=(n>=1<< 4)<<2;	logn+=sh, n>>=sh;
		sh=(n>=1<< 2)<<1;	logn+=sh, n>>=sh;
		sh= n>=1<< 1;		logn+=sh;
	return logn;
}
AWM_INLINE int floor_log2_32(uint32_t n)
{
	int	logn=-!n;
	int	sh=(n>=1<<16)<<4;	logn+=sh, n>>=sh;
		sh=(n>=1<< 8)<<3;	logn+=sh, n>>=sh;
		sh=(n>=1<< 4)<<2;	logn+=sh, n>>=sh;
		sh=(n>=1<< 2)<<1;	logn+=sh, n>>=sh;
		sh= n>=1<< 1;		logn+=sh;
	return logn;
}
#define FLOOR_LOG2(X)\
	(sizeof(X)==8?floor_log2_64(X):floor_log2_32((uint32_t)(X)))
#endif
#define CVTFP32_I32(X)  _mm_cvt_ss2si(_mm_set_ss(X))
#define CVTTFP32_I32(X) _mm_cvtt_ss2si(_mm_set_ss(X))
#define CVTFP64_I64(X)  _mm_cvtsd_si64(_mm_set_sd(X))
#define CVTTFP64_I64(X) _mm_cvttsd_si64(_mm_set_sd(X))
static void crash(const char *file, int line, const char *format, ...)
{
	printf("%s(%d):\n", file, line);
	if(format)
	{
		va_list args;
		va_start(args, format);
		vprintf(format, args);
		va_end(args);
	}
	printf("\n");
	exit(1);
}
#define CRASH(FORMAT, ...) crash(__FILE__, __LINE__, FORMAT,##__VA_ARGS__)
static double time_sec(void)
{
#ifdef _WIN32
	static long long t0=0;
	LARGE_INTEGER li;
	double t;
	QueryPerformanceCounter(&li);
	if(!t0)
		t0=li.QuadPart;
	t=(double)(li.QuadPart-t0);
	QueryPerformanceFrequency(&li);
	t/=(double)li.QuadPart;
	return t;
#else
	struct timespec t;
	clock_gettime(CLOCK_REALTIME, &t);//<time.h>
	return t.tv_sec+t.tv_nsec*1e-9;
#endif
}
#ifdef ENABLE_GUIDE
static int g_iw=0, g_ih=0;
static uint8_t *g_image=0;
static double g_sqe[3]={0};
static void guide_save(uint8_t *image, int iw, int ih)
{
	int size=3*iw*ih;
	g_iw=iw;
	g_ih=ih;
	g_image=(uint8_t*)malloc(size);
	if(!g_image)
	{
		CRASH("Alloc error");
		return;
	}
	memcpy(g_image, image, size);
}
#endif
#endif


//#ifdef _MSC_VER
//static int ctx_ctr=0, renorm_ctr=0;
//#endif
#ifdef FIFOVAL
static ptrdiff_t fifoidx=0, fifocap=0, fifoidx2=0;
static uint32_t *fifoval=0;
static void valfifo_enqueue(uint32_t val)
{
	if(fifoidx+1>=fifocap)
	{
		void *p=0;

		if(!fifocap)
			fifocap=1;
		fifocap<<=1;
		p=realloc(fifoval, fifocap*sizeof(uint32_t));
		if(!p)
		{
			CRASH("Alloc error");
			return;
		}
		fifoval=(uint32_t*)p;
	}
	fifoval[fifoidx++]=val;
}
static void valfifo_check(uint32_t val)
{
	uint32_t val0=fifoval[fifoidx2++];
	if(val!=val0)
	{
		--fifoidx2;
		printf(
			"\n"
			"FIFO Error  at %10lld,  remaining %10lld\n"
			"    0x%08X  !=  original 0x%08X\n"
			"\n"
			, fifoidx2
			, fifoidx-fifoidx2//current element was not decoded successfully
			, val, val0
		);
		for(int k=-32;k<32;++k)
		{
			ptrdiff_t idx=fifoidx2+k;
			if((size_t)idx<(size_t)fifoidx)
			{
				printf(
					"%10td  0x%08X"
					, idx
					, fifoval[idx]
				);
				if(idx<fifoidx2)
					printf("  OK");
				if(idx==fifoidx2)
					printf("  !=  corrupt 0x%08X", val);
				printf("\n");
			}
		}
		CRASH("");
	}
}
#endif


#if defined _MSC_VER && 0
static double sum_before[3][BLOCK0X*BLOCK0Y], sum_after[3][BLOCK0X*BLOCK0Y];
#endif
#if 1
static const float qtable0[3][BLOCK0X*BLOCK0Y]=
{
	{
	     3689.862f,        5.257f,        1.844f,        1.301f,        0.870f,        0.704f,        0.566f,        0.487f,        0.417f,        0.365f,        0.326f,        0.296f,        0.276f,        0.259f,        0.234f,        0.218f,        0.202f,        0.191f,        0.190f,        0.180f,        0.178f,        0.179f,        0.165f,        0.149f,        0.144f,        0.136f,        0.131f,        0.125f,        0.120f,        0.119f,        0.114f,        0.109f,
		3.711f,        1.697f,        1.179f,        0.892f,        0.702f,        0.572f,        0.482f,        0.418f,        0.370f,        0.331f,        0.298f,        0.271f,        0.248f,        0.232f,        0.215f,        0.202f,        0.184f,        0.175f,        0.167f,        0.158f,        0.148f,        0.142f,        0.136f,        0.132f,        0.128f,        0.123f,        0.120f,        0.115f,        0.113f,        0.110f,        0.107f,        0.104f,
		1.365f,        1.082f,        0.882f,        0.717f,        0.591f,        0.499f,        0.436f,        0.382f,        0.343f,        0.306f,        0.277f,        0.254f,        0.233f,        0.218f,        0.203f,        0.189f,        0.175f,        0.164f,        0.156f,        0.149f,        0.140f,        0.134f,        0.129f,        0.125f,        0.122f,        0.117f,        0.113f,        0.111f,        0.108f,        0.105f,        0.103f,        0.100f,
		0.995f,        0.801f,        0.684f,        0.587f,        0.505f,        0.445f,        0.393f,        0.348f,        0.316f,        0.283f,        0.261f,        0.240f,        0.222f,        0.205f,        0.190f,        0.180f,        0.165f,        0.157f,        0.150f,        0.141f,        0.134f,        0.129f,        0.122f,        0.119f,        0.117f,        0.113f,        0.109f,        0.107f,        0.105f,        0.102f,        0.099f,        0.097f,
		0.706f,        0.631f,        0.567f,        0.498f,        0.440f,        0.397f,        0.351f,        0.318f,        0.293f,        0.268f,        0.244f,        0.226f,        0.209f,        0.193f,        0.181f,        0.172f,        0.158f,        0.150f,        0.142f,        0.136f,        0.130f,        0.124f,        0.118f,        0.115f,        0.112f,        0.107f,        0.105f,        0.103f,        0.100f,        0.097f,        0.096f,        0.093f,
		0.587f,        0.523f,        0.474f,        0.431f,        0.389f,        0.354f,        0.321f,        0.293f,        0.273f,        0.250f,        0.231f,        0.215f,        0.198f,        0.186f,        0.174f,        0.164f,        0.152f,        0.145f,        0.137f,        0.131f,        0.123f,        0.119f,        0.114f,        0.111f,        0.108f,        0.104f,        0.101f,        0.099f,        0.097f,        0.095f,        0.093f,        0.090f,
		0.481f,        0.445f,        0.409f,        0.376f,        0.346f,        0.322f,        0.293f,        0.273f,        0.253f,        0.235f,        0.218f,        0.202f,        0.188f,        0.177f,        0.165f,        0.156f,        0.146f,        0.138f,        0.132f,        0.126f,        0.120f,        0.114f,        0.109f,        0.107f,        0.104f,        0.101f,        0.097f,        0.096f,        0.093f,        0.091f,        0.090f,        0.087f,
		0.422f,        0.383f,        0.360f,        0.332f,        0.309f,        0.290f,        0.269f,        0.252f,        0.237f,        0.218f,        0.204f,        0.191f,        0.179f,        0.168f,        0.158f,        0.149f,        0.140f,        0.133f,        0.127f,        0.121f,        0.115f,        0.110f,        0.106f,        0.103f,        0.100f,        0.097f,        0.095f,        0.092f,        0.090f,        0.088f,        0.087f,        0.084f,
		0.357f,        0.339f,        0.320f,        0.297f,        0.280f,        0.263f,        0.245f,        0.232f,        0.219f,        0.204f,        0.193f,        0.180f,        0.170f,        0.160f,        0.152f,        0.144f,        0.134f,        0.128f,        0.122f,        0.116f,        0.110f,        0.106f,        0.102f,        0.098f,        0.096f,        0.092f,        0.090f,        0.088f,        0.086f,        0.084f,        0.083f,        0.080f,
		0.325f,        0.304f,        0.287f,        0.268f,        0.255f,        0.241f,        0.227f,        0.215f,        0.203f,        0.193f,        0.180f,        0.172f,        0.160f,        0.152f,        0.143f,        0.136f,        0.128f,        0.122f,        0.116f,        0.111f,        0.105f,        0.102f,        0.096f,        0.094f,        0.092f,        0.089f,        0.086f,        0.085f,        0.083f,        0.081f,        0.079f,        0.078f,
		0.293f,        0.278f,        0.262f,        0.248f,        0.234f,        0.225f,        0.212f,        0.203f,        0.190f,        0.180f,        0.173f,        0.164f,        0.154f,        0.145f,        0.138f,        0.131f,        0.122f,        0.116f,        0.111f,        0.107f,        0.101f,        0.098f,        0.094f,        0.091f,        0.089f,        0.086f,        0.084f,        0.082f,        0.080f,        0.079f,        0.077f,        0.074f,
		0.269f,        0.251f,        0.242f,        0.230f,        0.218f,        0.209f,        0.198f,        0.189f,        0.180f,        0.171f,        0.163f,        0.156f,        0.146f,        0.138f,        0.131f,        0.124f,        0.117f,        0.112f,        0.107f,        0.102f,        0.098f,        0.094f,        0.091f,        0.087f,        0.086f,        0.082f,        0.081f,        0.079f,        0.077f,        0.075f,        0.073f,        0.072f,
		0.246f,        0.229f,        0.220f,        0.210f,        0.201f,        0.192f,        0.184f,        0.176f,        0.168f,        0.161f,        0.152f,        0.146f,        0.139f,        0.131f,        0.125f,        0.118f,        0.112f,        0.106f,        0.102f,        0.098f,        0.093f,        0.090f,        0.087f,        0.084f,        0.083f,        0.079f,        0.077f,        0.076f,        0.073f,        0.072f,        0.070f,        0.069f,
		0.235f,        0.214f,        0.205f,        0.196f,        0.188f,        0.181f,        0.172f,        0.166f,        0.158f,        0.150f,        0.145f,        0.138f,        0.131f,        0.126f,        0.119f,        0.113f,        0.106f,        0.102f,        0.098f,        0.095f,        0.090f,        0.087f,        0.083f,        0.081f,        0.079f,        0.077f,        0.074f,        0.073f,        0.071f,        0.069f,        0.068f,        0.066f,
		0.209f,        0.196f,        0.188f,        0.181f,        0.172f,        0.166f,        0.160f,        0.154f,        0.146f,        0.141f,        0.135f,        0.130f,        0.124f,        0.118f,        0.113f,        0.109f,        0.101f,        0.097f,        0.094f,        0.089f,        0.085f,        0.083f,        0.080f,        0.078f,        0.076f,        0.073f,        0.071f,        0.069f,        0.068f,        0.066f,        0.065f,        0.064f,
		0.194f,        0.183f,        0.175f,        0.168f,        0.162f,        0.156f,        0.149f,        0.143f,        0.138f,        0.134f,        0.128f,        0.121f,        0.117f,        0.111f,        0.106f,        0.102f,        0.096f,        0.092f,        0.089f,        0.086f,        0.081f,        0.080f,        0.077f,        0.074f,        0.072f,        0.070f,        0.068f,        0.067f,        0.065f,        0.063f,        0.062f,        0.060f,
		0.179f,        0.170f,        0.163f,        0.156f,        0.151f,        0.145f,        0.139f,        0.135f,        0.128f,        0.125f,        0.121f,        0.116f,        0.111f,        0.106f,        0.101f,        0.097f,        0.092f,        0.089f,        0.085f,        0.082f,        0.078f,        0.076f,        0.073f,        0.071f,        0.069f,        0.067f,        0.065f,        0.064f,        0.062f,        0.061f,        0.060f,        0.058f,
		0.172f,        0.162f,        0.156f,        0.150f,        0.143f,        0.138f,        0.134f,        0.129f,        0.123f,        0.120f,        0.116f,        0.111f,        0.107f,        0.101f,        0.097f,        0.094f,        0.088f,        0.086f,        0.083f,        0.080f,        0.076f,        0.073f,        0.071f,        0.069f,        0.067f,        0.065f,        0.064f,        0.062f,        0.061f,        0.059f,        0.058f,        0.056f,
		0.161f,        0.152f,        0.145f,        0.140f,        0.135f,        0.131f,        0.125f,        0.121f,        0.116f,        0.112f,        0.109f,        0.106f,        0.100f,        0.097f,        0.093f,        0.090f,        0.084f,        0.082f,        0.079f,        0.076f,        0.073f,        0.070f,        0.068f,        0.066f,        0.064f,        0.062f,        0.061f,        0.060f,        0.059f,        0.057f,        0.056f,        0.054f,
		0.157f,        0.146f,        0.139f,        0.134f,        0.129f,        0.124f,        0.120f,        0.116f,        0.111f,        0.108f,        0.105f,        0.101f,        0.096f,        0.093f,        0.089f,        0.086f,        0.082f,        0.079f,        0.076f,        0.074f,        0.071f,        0.069f,        0.066f,        0.064f,        0.063f,        0.061f,        0.060f,        0.058f,        0.057f,        0.056f,        0.055f,        0.053f,
		0.152f,        0.138f,        0.132f,        0.126f,        0.121f,        0.118f,        0.114f,        0.110f,        0.105f,        0.102f,        0.099f,        0.095f,        0.091f,        0.087f,        0.085f,        0.082f,        0.078f,        0.075f,        0.073f,        0.071f,        0.068f,        0.067f,        0.064f,        0.062f,        0.061f,        0.059f,        0.057f,        0.056f,        0.055f,        0.054f,        0.053f,        0.051f,
		0.157f,        0.134f,        0.127f,        0.121f,        0.117f,        0.113f,        0.109f,        0.106f,        0.102f,        0.098f,        0.095f,        0.092f,        0.088f,        0.085f,        0.082f,        0.079f,        0.075f,        0.074f,        0.071f,        0.069f,        0.067f,        0.067f,        0.064f,        0.061f,        0.060f,        0.058f,        0.057f,        0.055f,        0.054f,        0.053f,        0.052f,        0.050f,
		0.148f,        0.128f,        0.122f,        0.117f,        0.113f,        0.109f,        0.105f,        0.102f,        0.098f,        0.095f,        0.092f,        0.089f,        0.085f,        0.082f,        0.079f,        0.076f,        0.073f,        0.070f,        0.068f,        0.066f,        0.064f,        0.064f,        0.061f,        0.059f,        0.058f,        0.056f,        0.055f,        0.054f,        0.052f,        0.052f,        0.051f,        0.049f,
		0.132f,        0.121f,        0.117f,        0.112f,        0.108f,        0.105f,        0.101f,        0.098f,        0.094f,        0.090f,        0.088f,        0.085f,        0.082f,        0.079f,        0.076f,        0.073f,        0.070f,        0.068f,        0.066f,        0.064f,        0.062f,        0.061f,        0.059f,        0.058f,        0.056f,        0.055f,        0.054f,        0.053f,        0.052f,        0.051f,        0.050f,        0.048f,
		0.123f,        0.116f,        0.112f,        0.109f,        0.104f,        0.102f,        0.098f,        0.095f,        0.091f,        0.088f,        0.085f,        0.083f,        0.079f,        0.076f,        0.073f,        0.071f,        0.068f,        0.066f,        0.064f,        0.062f,        0.060f,        0.059f,        0.058f,        0.057f,        0.055f,        0.054f,        0.053f,        0.053f,        0.051f,        0.051f,        0.050f,        0.048f,
		0.121f,        0.114f,        0.110f,        0.106f,        0.103f,        0.100f,        0.097f,        0.093f,        0.090f,        0.087f,        0.084f,        0.082f,        0.078f,        0.075f,        0.073f,        0.071f,        0.067f,        0.065f,        0.063f,        0.061f,        0.060f,        0.058f,        0.057f,        0.056f,        0.055f,        0.054f,        0.053f,        0.052f,        0.051f,        0.051f,        0.050f,        0.048f,
		0.117f,        0.110f,        0.107f,        0.104f,        0.100f,        0.097f,        0.094f,        0.091f,        0.088f,        0.086f,        0.082f,        0.080f,        0.076f,        0.074f,        0.071f,        0.069f,        0.066f,        0.064f,        0.062f,        0.060f,        0.058f,        0.057f,        0.056f,        0.055f,        0.054f,        0.053f,        0.053f,        0.051f,        0.051f,        0.050f,        0.049f,        0.048f,
		0.112f,        0.107f,        0.104f,        0.100f,        0.097f,        0.095f,        0.091f,        0.089f,        0.085f,        0.082f,        0.080f,        0.077f,        0.074f,        0.071f,        0.069f,        0.067f,        0.064f,        0.062f,        0.061f,        0.059f,        0.057f,        0.056f,        0.054f,        0.054f,        0.053f,        0.052f,        0.052f,        0.051f,        0.050f,        0.049f,        0.049f,        0.048f,
		0.108f,        0.104f,        0.101f,        0.098f,        0.094f,        0.093f,        0.089f,        0.087f,        0.084f,        0.081f,        0.078f,        0.076f,        0.072f,        0.070f,        0.067f,        0.065f,        0.063f,        0.060f,        0.058f,        0.058f,        0.056f,        0.054f,        0.054f,        0.053f,        0.052f,        0.051f,        0.051f,        0.050f,        0.049f,        0.049f,        0.048f,        0.047f,
		0.107f,        0.103f,        0.101f,        0.096f,        0.094f,        0.091f,        0.088f,        0.085f,        0.082f,        0.079f,        0.077f,        0.074f,        0.071f,        0.069f,        0.066f,        0.063f,        0.061f,        0.059f,        0.058f,        0.056f,        0.055f,        0.053f,        0.053f,        0.053f,        0.051f,        0.051f,        0.050f,        0.050f,        0.049f,        0.048f,        0.048f,        0.047f,
		0.103f,        0.100f,        0.097f,        0.094f,        0.092f,        0.089f,        0.086f,        0.083f,        0.081f,        0.078f,        0.075f,        0.073f,        0.069f,        0.067f,        0.065f,        0.062f,        0.060f,        0.058f,        0.057f,        0.055f,        0.054f,        0.053f,        0.052f,        0.051f,        0.050f,        0.050f,        0.049f,        0.049f,        0.048f,        0.048f,        0.048f,        0.046f,
		0.101f,        0.097f,        0.095f,        0.092f,        0.088f,        0.086f,        0.084f,        0.081f,        0.078f,        0.075f,        0.073f,        0.071f,        0.067f,        0.065f,        0.062f,        0.061f,        0.059f,        0.056f,        0.055f,        0.053f,        0.052f,        0.051f,        0.050f,        0.050f,        0.050f,        0.048f,        0.048f,        0.048f,        0.047f,        0.047f,        0.046f,        0.045f,
	},
	{
	      424.973f,        2.657f,        1.241f,        0.834f,        0.608f,        0.478f,        0.389f,        0.335f,        0.295f,        0.262f,        0.231f,        0.213f,        0.196f,        0.184f,        0.171f,        0.157f,        0.143f,        0.140f,        0.138f,        0.128f,        0.124f,        0.119f,        0.110f,        0.106f,        0.101f,        0.094f,        0.088f,        0.084f,        0.081f,        0.078f,        0.076f,        0.071f,
		1.667f,        1.063f,        0.791f,        0.600f,        0.480f,        0.402f,        0.340f,        0.300f,        0.267f,        0.237f,        0.213f,        0.196f,        0.180f,        0.167f,        0.157f,        0.144f,        0.131f,        0.126f,        0.120f,        0.110f,        0.105f,        0.099f,        0.094f,        0.091f,        0.089f,        0.085f,        0.081f,        0.079f,        0.075f,        0.073f,        0.071f,        0.066f,
		0.803f,        0.689f,        0.570f,        0.467f,        0.394f,        0.341f,        0.298f,        0.262f,        0.238f,        0.212f,        0.193f,        0.177f,        0.164f,        0.152f,        0.142f,        0.131f,        0.120f,        0.115f,        0.108f,        0.100f,        0.094f,        0.089f,        0.085f,        0.082f,        0.081f,        0.078f,        0.075f,        0.072f,        0.070f,        0.067f,        0.065f,        0.061f,
		0.593f,        0.531f,        0.458f,        0.390f,        0.342f,        0.303f,        0.269f,        0.240f,        0.220f,        0.198f,        0.180f,        0.165f,        0.153f,        0.142f,        0.133f,        0.122f,        0.113f,        0.107f,        0.101f,        0.093f,        0.090f,        0.085f,        0.081f,        0.078f,        0.076f,        0.074f,        0.071f,        0.069f,        0.067f,        0.065f,        0.063f,        0.059f,
		0.449f,        0.419f,        0.375f,        0.334f,        0.297f,        0.267f,        0.241f,        0.218f,        0.200f,        0.182f,        0.166f,        0.153f,        0.141f,        0.130f,        0.122f,        0.113f,        0.104f,        0.098f,        0.093f,        0.087f,        0.083f,        0.079f,        0.076f,        0.074f,        0.072f,        0.070f,        0.068f,        0.066f,        0.064f,        0.062f,        0.060f,        0.057f,
		0.382f,        0.359f,        0.326f,        0.292f,        0.265f,        0.242f,        0.219f,        0.199f,        0.184f,        0.167f,        0.152f,        0.141f,        0.131f,        0.120f,        0.114f,        0.105f,        0.096f,        0.091f,        0.086f,        0.081f,        0.078f,        0.074f,        0.072f,        0.070f,        0.068f,        0.066f,        0.064f,        0.062f,        0.061f,        0.059f,        0.058f,        0.055f,
		0.317f,        0.304f,        0.281f,        0.258f,        0.238f,        0.217f,        0.198f,        0.182f,        0.168f,        0.153f,        0.140f,        0.129f,        0.120f,        0.111f,        0.104f,        0.096f,        0.090f,        0.084f,        0.080f,        0.075f,        0.072f,        0.070f,        0.067f,        0.066f,        0.065f,        0.063f,        0.062f,        0.059f,        0.058f,        0.057f,        0.055f,        0.052f,
		0.288f,        0.273f,        0.253f,        0.233f,        0.214f,        0.198f,        0.181f,        0.168f,        0.154f,        0.141f,        0.130f,        0.120f,        0.112f,        0.103f,        0.097f,        0.090f,        0.083f,        0.079f,        0.075f,        0.071f,        0.068f,        0.066f,        0.064f,        0.063f,        0.062f,        0.060f,        0.059f,        0.058f,        0.056f,        0.055f,        0.054f,        0.051f,
		0.249f,        0.240f,        0.221f,        0.207f,        0.192f,        0.177f,        0.163f,        0.151f,        0.141f,        0.129f,        0.119f,        0.111f,        0.103f,        0.097f,        0.090f,        0.084f,        0.078f,        0.074f,        0.070f,        0.066f,        0.064f,        0.062f,        0.060f,        0.059f,        0.058f,        0.057f,        0.056f,        0.055f,        0.054f,        0.053f,        0.052f,        0.049f,
		0.230f,        0.220f,        0.202f,        0.187f,        0.173f,        0.161f,        0.149f,        0.138f,        0.129f,        0.119f,        0.110f,        0.103f,        0.096f,        0.090f,        0.085f,        0.079f,        0.074f,        0.070f,        0.066f,        0.064f,        0.061f,        0.059f,        0.058f,        0.057f,        0.057f,        0.055f,        0.054f,        0.053f,        0.052f,        0.052f,        0.050f,        0.048f,
		0.204f,        0.197f,        0.184f,        0.170f,        0.159f,        0.149f,        0.139f,        0.129f,        0.120f,        0.111f,        0.105f,        0.099f,        0.092f,        0.087f,        0.082f,        0.076f,        0.071f,        0.067f,        0.063f,        0.061f,        0.059f,        0.058f,        0.056f,        0.055f,        0.055f,        0.054f,        0.053f,        0.052f,        0.051f,        0.050f,        0.049f,        0.047f,
		0.191f,        0.181f,        0.170f,        0.158f,        0.147f,        0.137f,        0.128f,        0.119f,        0.112f,        0.104f,        0.098f,        0.093f,        0.088f,        0.083f,        0.079f,        0.073f,        0.069f,        0.065f,        0.063f,        0.060f,        0.058f,        0.056f,        0.055f,        0.054f,        0.053f,        0.052f,        0.051f,        0.051f,        0.050f,        0.049f,        0.048f,        0.046f,
		0.170f,        0.165f,        0.153f,        0.144f,        0.135f,        0.126f,        0.118f,        0.110f,        0.103f,        0.097f,        0.092f,        0.088f,        0.084f,        0.079f,        0.076f,        0.071f,        0.067f,        0.064f,        0.061f,        0.058f,        0.056f,        0.055f,        0.053f,        0.052f,        0.052f,        0.051f,        0.050f,        0.049f,        0.049f,        0.048f,        0.047f,        0.045f,
		0.163f,        0.155f,        0.144f,        0.134f,        0.126f,        0.117f,        0.109f,        0.102f,        0.096f,        0.091f,        0.086f,        0.083f,        0.079f,        0.076f,        0.073f,        0.069f,        0.066f,        0.063f,        0.060f,        0.058f,        0.056f,        0.054f,        0.053f,        0.052f,        0.051f,        0.050f,        0.049f,        0.049f,        0.048f,        0.047f,        0.046f,        0.044f,
		0.147f,        0.142f,        0.132f,        0.124f,        0.115f,        0.109f,        0.101f,        0.095f,        0.090f,        0.085f,        0.081f,        0.078f,        0.075f,        0.073f,        0.070f,        0.067f,        0.064f,        0.061f,        0.059f,        0.057f,        0.055f,        0.053f,        0.052f,        0.051f,        0.050f,        0.049f,        0.048f,        0.048f,        0.047f,        0.046f,        0.045f,        0.043f,
		0.137f,        0.132f,        0.125f,        0.115f,        0.108f,        0.101f,        0.094f,        0.088f,        0.083f,        0.079f,        0.075f,        0.073f,        0.071f,        0.069f,        0.067f,        0.065f,        0.063f,        0.060f,        0.058f,        0.056f,        0.054f,        0.053f,        0.051f,        0.050f,        0.050f,        0.048f,        0.048f,        0.047f,        0.046f,        0.045f,        0.045f,        0.043f,
		0.124f,        0.121f,        0.113f,        0.106f,        0.100f,        0.093f,        0.087f,        0.081f,        0.077f,        0.073f,        0.070f,        0.068f,        0.067f,        0.065f,        0.064f,        0.062f,        0.060f,        0.058f,        0.057f,        0.055f,        0.053f,        0.051f,        0.050f,        0.049f,        0.048f,        0.047f,        0.047f,        0.046f,        0.045f,        0.044f,        0.044f,        0.042f,
		0.120f,        0.115f,        0.108f,        0.101f,        0.094f,        0.087f,        0.082f,        0.077f,        0.073f,        0.070f,        0.067f,        0.065f,        0.063f,        0.063f,        0.062f,        0.060f,        0.059f,        0.057f,        0.056f,        0.054f,        0.052f,        0.051f,        0.050f,        0.049f,        0.048f,        0.047f,        0.046f,        0.045f,        0.045f,        0.044f,        0.043f,        0.041f,
		0.111f,        0.107f,        0.100f,        0.093f,        0.087f,        0.082f,        0.077f,        0.073f,        0.069f,        0.066f,        0.064f,        0.062f,        0.061f,        0.060f,        0.059f,        0.058f,        0.056f,        0.055f,        0.055f,        0.053f,        0.051f,        0.050f,        0.049f,        0.048f,        0.047f,        0.046f,        0.046f,        0.045f,        0.044f,        0.043f,        0.042f,        0.041f,
		0.108f,        0.102f,        0.096f,        0.089f,        0.084f,        0.079f,        0.073f,        0.069f,        0.066f,        0.063f,        0.060f,        0.059f,        0.059f,        0.058f,        0.057f,        0.056f,        0.055f,        0.054f,        0.053f,        0.052f,        0.051f,        0.050f,        0.049f,        0.048f,        0.047f,        0.046f,        0.045f,        0.044f,        0.044f,        0.043f,        0.042f,        0.040f,
		0.100f,        0.096f,        0.090f,        0.084f,        0.079f,        0.075f,        0.070f,        0.067f,        0.064f,        0.061f,        0.059f,        0.057f,        0.056f,        0.056f,        0.055f,        0.054f,        0.053f,        0.052f,        0.052f,        0.051f,        0.050f,        0.049f,        0.048f,        0.047f,        0.046f,        0.045f,        0.044f,        0.044f,        0.043f,        0.043f,        0.042f,        0.040f,
		0.100f,        0.093f,        0.087f,        0.081f,        0.076f,        0.072f,        0.068f,        0.065f,        0.062f,        0.059f,        0.057f,        0.056f,        0.055f,        0.054f,        0.054f,        0.053f,        0.052f,        0.051f,        0.050f,        0.050f,        0.049f,        0.049f,        0.048f,        0.047f,        0.046f,        0.045f,        0.044f,        0.044f,        0.043f,        0.042f,        0.041f,        0.039f,
		0.093f,        0.088f,        0.082f,        0.078f,        0.073f,        0.069f,        0.066f,        0.063f,        0.060f,        0.057f,        0.056f,        0.055f,        0.054f,        0.053f,        0.052f,        0.051f,        0.050f,        0.050f,        0.049f,        0.049f,        0.048f,        0.048f,        0.047f,        0.046f,        0.045f,        0.045f,        0.044f,        0.043f,        0.042f,        0.042f,        0.041f,        0.039f,
		0.089f,        0.085f,        0.080f,        0.075f,        0.071f,        0.068f,        0.064f,        0.061f,        0.059f,        0.056f,        0.055f,        0.054f,        0.053f,        0.051f,        0.051f,        0.050f,        0.049f,        0.049f,        0.048f,        0.048f,        0.047f,        0.047f,        0.046f,        0.046f,        0.045f,        0.044f,        0.043f,        0.043f,        0.042f,        0.042f,        0.040f,        0.039f,
		0.083f,        0.080f,        0.076f,        0.072f,        0.069f,        0.065f,        0.062f,        0.060f,        0.057f,        0.056f,        0.054f,        0.052f,        0.052f,        0.051f,        0.050f,        0.049f,        0.049f,        0.048f,        0.047f,        0.047f,        0.046f,        0.046f,        0.045f,        0.045f,        0.044f,        0.043f,        0.043f,        0.042f,        0.042f,        0.041f,        0.040f,        0.039f,
		0.082f,        0.079f,        0.074f,        0.071f,        0.067f,        0.064f,        0.062f,        0.059f,        0.057f,        0.055f,        0.054f,        0.053f,        0.052f,        0.051f,        0.050f,        0.049f,        0.048f,        0.047f,        0.047f,        0.046f,        0.046f,        0.045f,        0.045f,        0.044f,        0.044f,        0.043f,        0.043f,        0.042f,        0.042f,        0.041f,        0.040f,        0.039f,
		0.077f,        0.075f,        0.072f,        0.068f,        0.065f,        0.063f,        0.060f,        0.058f,        0.056f,        0.054f,        0.053f,        0.052f,        0.051f,        0.050f,        0.049f,        0.048f,        0.047f,        0.047f,        0.046f,        0.045f,        0.045f,        0.044f,        0.044f,        0.044f,        0.043f,        0.043f,        0.042f,        0.042f,        0.041f,        0.041f,        0.040f,        0.038f,
		0.075f,        0.074f,        0.070f,        0.067f,        0.064f,        0.061f,        0.059f,        0.057f,        0.056f,        0.054f,        0.052f,        0.051f,        0.050f,        0.049f,        0.049f,        0.048f,        0.046f,        0.046f,        0.046f,        0.045f,        0.044f,        0.044f,        0.043f,        0.043f,        0.043f,        0.042f,        0.042f,        0.042f,        0.041f,        0.041f,        0.040f,        0.038f,
		0.071f,        0.070f,        0.067f,        0.065f,        0.062f,        0.060f,        0.058f,        0.056f,        0.054f,        0.053f,        0.051f,        0.050f,        0.049f,        0.049f,        0.048f,        0.047f,        0.046f,        0.045f,        0.045f,        0.044f,        0.044f,        0.044f,        0.043f,        0.043f,        0.042f,        0.042f,        0.042f,        0.041f,        0.040f,        0.040f,        0.039f,        0.038f,
		0.072f,        0.069f,        0.066f,        0.063f,        0.061f,        0.059f,        0.057f,        0.055f,        0.054f,        0.052f,        0.051f,        0.050f,        0.049f,        0.048f,        0.047f,        0.046f,        0.045f,        0.045f,        0.045f,        0.044f,        0.043f,        0.043f,        0.042f,        0.042f,        0.042f,        0.042f,        0.041f,        0.041f,        0.040f,        0.040f,        0.039f,        0.038f,
		0.067f,        0.067f,        0.064f,        0.061f,        0.059f,        0.057f,        0.055f,        0.054f,        0.052f,        0.051f,        0.050f,        0.049f,        0.048f,        0.047f,        0.046f,        0.046f,        0.045f,        0.044f,        0.044f,        0.043f,        0.042f,        0.042f,        0.042f,        0.042f,        0.041f,        0.041f,        0.041f,        0.040f,        0.040f,        0.039f,        0.039f,        0.037f,
		0.066f,        0.064f,        0.061f,        0.059f,        0.057f,        0.055f,        0.054f,        0.052f,        0.051f,        0.049f,        0.048f,        0.048f,        0.047f,        0.046f,        0.045f,        0.044f,        0.043f,        0.043f,        0.042f,        0.042f,        0.041f,        0.041f,        0.041f,        0.040f,        0.040f,        0.040f,        0.039f,        0.039f,        0.039f,        0.038f,        0.038f,        0.036f,
	},
	{
	      335.175f,        1.876f,        0.930f,        0.633f,        0.470f,        0.375f,        0.306f,        0.266f,        0.235f,        0.208f,        0.186f,        0.170f,        0.158f,        0.148f,        0.138f,        0.127f,        0.115f,        0.113f,        0.109f,        0.102f,        0.097f,        0.093f,        0.087f,        0.083f,        0.078f,        0.074f,        0.069f,        0.066f,        0.063f,        0.061f,        0.059f,        0.055f,
		1.219f,        0.835f,        0.618f,        0.471f,        0.383f,        0.322f,        0.274f,        0.241f,        0.213f,        0.192f,        0.171f,        0.158f,        0.146f,        0.136f,        0.129f,        0.117f,        0.108f,        0.103f,        0.098f,        0.090f,        0.085f,        0.079f,        0.075f,        0.073f,        0.070f,        0.068f,        0.065f,        0.062f,        0.059f,        0.057f,        0.055f,        0.051f,
		0.638f,        0.549f,        0.452f,        0.373f,        0.317f,        0.277f,        0.241f,        0.214f,        0.192f,        0.172f,        0.157f,        0.144f,        0.134f,        0.124f,        0.116f,        0.107f,        0.099f,        0.094f,        0.088f,        0.081f,        0.077f,        0.072f,        0.069f,        0.066f,        0.064f,        0.062f,        0.060f,        0.058f,        0.055f,        0.053f,        0.051f,        0.047f,
		0.473f,        0.430f,        0.369f,        0.316f,        0.277f,        0.246f,        0.219f,        0.196f,        0.177f,        0.161f,        0.146f,        0.135f,        0.125f,        0.116f,        0.107f,        0.100f,        0.093f,        0.087f,        0.082f,        0.077f,        0.072f,        0.068f,        0.065f,        0.063f,        0.061f,        0.059f,        0.057f,        0.055f,        0.053f,        0.051f,        0.049f,        0.046f,
		0.361f,        0.343f,        0.305f,        0.271f,        0.241f,        0.217f,        0.195f,        0.176f,        0.161f,        0.147f,        0.135f,        0.124f,        0.114f,        0.106f,        0.098f,        0.091f,        0.085f,        0.079f,        0.075f,        0.070f,        0.067f,        0.064f,        0.061f,        0.059f,        0.057f,        0.056f,        0.054f,        0.052f,        0.050f,        0.048f,        0.047f,        0.043f,
		0.312f,        0.295f,        0.267f,        0.238f,        0.216f,        0.196f,        0.178f,        0.163f,        0.148f,        0.135f,        0.124f,        0.114f,        0.106f,        0.098f,        0.091f,        0.084f,        0.078f,        0.074f,        0.070f,        0.065f,        0.062f,        0.060f,        0.057f,        0.056f,        0.054f,        0.053f,        0.051f,        0.050f,        0.048f,        0.047f,        0.045f,        0.042f,
		0.261f,        0.252f,        0.230f,        0.210f,        0.192f,        0.176f,        0.161f,        0.146f,        0.135f,        0.124f,        0.114f,        0.105f,        0.098f,        0.090f,        0.084f,        0.078f,        0.072f,        0.068f,        0.064f,        0.061f,        0.058f,        0.056f,        0.054f,        0.052f,        0.051f,        0.050f,        0.048f,        0.047f,        0.046f,        0.044f,        0.043f,        0.040f,
		0.236f,        0.227f,        0.208f,        0.190f,        0.174f,        0.161f,        0.148f,        0.135f,        0.124f,        0.114f,        0.105f,        0.098f,        0.090f,        0.084f,        0.078f,        0.072f,        0.067f,        0.063f,        0.060f,        0.057f,        0.054f,        0.052f,        0.050f,        0.049f,        0.048f,        0.047f,        0.046f,        0.045f,        0.044f,        0.043f,        0.041f,        0.039f,
		0.204f,        0.200f,        0.185f,        0.170f,        0.158f,        0.145f,        0.134f,        0.123f,        0.113f,        0.104f,        0.097f,        0.091f,        0.084f,        0.078f,        0.072f,        0.067f,        0.063f,        0.059f,        0.056f,        0.054f,        0.051f,        0.049f,        0.048f,        0.047f,        0.046f,        0.045f,        0.044f,        0.043f,        0.042f,        0.041f,        0.040f,        0.038f,
		0.189f,        0.180f,        0.167f,        0.154f,        0.143f,        0.132f,        0.122f,        0.112f,        0.104f,        0.096f,        0.089f,        0.084f,        0.078f,        0.073f,        0.068f,        0.063f,        0.059f,        0.056f,        0.053f,        0.051f,        0.049f,        0.047f,        0.046f,        0.044f,        0.044f,        0.043f,        0.043f,        0.042f,        0.041f,        0.040f,        0.039f,        0.037f,
		0.169f,        0.164f,        0.152f,        0.141f,        0.131f,        0.121f,        0.113f,        0.105f,        0.097f,        0.090f,        0.084f,        0.079f,        0.074f,        0.069f,        0.065f,        0.061f,        0.057f,        0.053f,        0.051f,        0.049f,        0.047f,        0.046f,        0.044f,        0.043f,        0.043f,        0.042f,        0.041f,        0.041f,        0.040f,        0.039f,        0.038f,        0.036f,
		0.157f,        0.152f,        0.141f,        0.130f,        0.121f,        0.112f,        0.104f,        0.096f,        0.090f,        0.084f,        0.079f,        0.074f,        0.070f,        0.066f,        0.062f,        0.058f,        0.055f,        0.052f,        0.049f,        0.047f,        0.046f,        0.044f,        0.043f,        0.042f,        0.042f,        0.041f,        0.040f,        0.040f,        0.039f,        0.038f,        0.037f,        0.035f,
		0.143f,        0.139f,        0.128f,        0.120f,        0.110f,        0.104f,        0.096f,        0.089f,        0.084f,        0.079f,        0.074f,        0.071f,        0.067f,        0.064f,        0.060f,        0.056f,        0.053f,        0.051f,        0.048f,        0.046f,        0.044f,        0.043f,        0.042f,        0.041f,        0.040f,        0.040f,        0.039f,        0.038f,        0.038f,        0.037f,        0.036f,        0.034f,
		0.135f,        0.129f,        0.121f,        0.111f,        0.103f,        0.096f,        0.090f,        0.083f,        0.078f,        0.073f,        0.070f,        0.066f,        0.064f,        0.061f,        0.058f,        0.055f,        0.052f,        0.050f,        0.048f,        0.046f,        0.044f,        0.042f,        0.041f,        0.040f,        0.040f,        0.039f,        0.039f,        0.038f,        0.037f,        0.036f,        0.036f,        0.033f,
		0.122f,        0.118f,        0.110f,        0.103f,        0.096f,        0.089f,        0.083f,        0.077f,        0.072f,        0.068f,        0.065f,        0.062f,        0.060f,        0.058f,        0.055f,        0.053f,        0.051f,        0.048f,        0.047f,        0.045f,        0.043f,        0.042f,        0.040f,        0.040f,        0.039f,        0.038f,        0.037f,        0.037f,        0.036f,        0.036f,        0.035f,        0.033f,
		0.114f,        0.111f,        0.104f,        0.096f,        0.089f,        0.082f,        0.077f,        0.072f,        0.067f,        0.064f,        0.061f,        0.059f,        0.057f,        0.055f,        0.053f,        0.051f,        0.049f,        0.047f,        0.046f,        0.044f,        0.042f,        0.041f,        0.040f,        0.039f,        0.038f,        0.038f,        0.037f,        0.036f,        0.036f,        0.035f,        0.034f,        0.032f,
		0.104f,        0.102f,        0.095f,        0.089f,        0.083f,        0.076f,        0.072f,        0.067f,        0.063f,        0.059f,        0.056f,        0.055f,        0.053f,        0.052f,        0.051f,        0.049f,        0.047f,        0.046f,        0.045f,        0.043f,        0.042f,        0.041f,        0.039f,        0.039f,        0.038f,        0.037f,        0.037f,        0.036f,        0.035f,        0.034f,        0.034f,        0.032f,
		0.100f,        0.097f,        0.090f,        0.084f,        0.078f,        0.072f,        0.067f,        0.063f,        0.059f,        0.056f,        0.054f,        0.052f,        0.051f,        0.050f,        0.049f,        0.047f,        0.046f,        0.045f,        0.044f,        0.042f,        0.041f,        0.040f,        0.039f,        0.038f,        0.037f,        0.037f,        0.036f,        0.035f,        0.035f,        0.034f,        0.033f,        0.031f,
		0.091f,        0.089f,        0.083f,        0.077f,        0.072f,        0.067f,        0.063f,        0.059f,        0.056f,        0.053f,        0.051f,        0.049f,        0.048f,        0.047f,        0.047f,        0.046f,        0.045f,        0.044f,        0.043f,        0.042f,        0.040f,        0.039f,        0.038f,        0.037f,        0.037f,        0.036f,        0.036f,        0.035f,        0.034f,        0.034f,        0.032f,        0.031f,
		0.089f,        0.086f,        0.080f,        0.074f,        0.069f,        0.064f,        0.060f,        0.056f,        0.053f,        0.050f,        0.049f,        0.047f,        0.046f,        0.045f,        0.045f,        0.044f,        0.043f,        0.042f,        0.042f,        0.041f,        0.040f,        0.039f,        0.038f,        0.037f,        0.036f,        0.036f,        0.035f,        0.034f,        0.034f,        0.033f,        0.032f,        0.030f,
		0.083f,        0.080f,        0.074f,        0.070f,        0.065f,        0.061f,        0.057f,        0.054f,        0.051f,        0.048f,        0.047f,        0.045f,        0.044f,        0.043f,        0.043f,        0.042f,        0.042f,        0.041f,        0.040f,        0.040f,        0.039f,        0.038f,        0.038f,        0.037f,        0.036f,        0.035f,        0.034f,        0.034f,        0.034f,        0.033f,        0.032f,        0.030f,
		0.081f,        0.077f,        0.071f,        0.066f,        0.062f,        0.058f,        0.055f,        0.052f,        0.049f,        0.047f,        0.045f,        0.044f,        0.043f,        0.042f,        0.042f,        0.041f,        0.040f,        0.040f,        0.039f,        0.039f,        0.038f,        0.038f,        0.037f,        0.036f,        0.035f,        0.035f,        0.034f,        0.034f,        0.033f,        0.032f,        0.032f,        0.030f,
		0.075f,        0.072f,        0.067f,        0.063f,        0.059f,        0.056f,        0.053f,        0.049f,        0.047f,        0.045f,        0.044f,        0.043f,        0.042f,        0.041f,        0.041f,        0.040f,        0.039f,        0.039f,        0.038f,        0.038f,        0.037f,        0.037f,        0.036f,        0.036f,        0.035f,        0.035f,        0.034f,        0.033f,        0.033f,        0.032f,        0.031f,        0.029f,
		0.072f,        0.070f,        0.065f,        0.061f,        0.057f,        0.054f,        0.051f,        0.048f,        0.046f,        0.044f,        0.043f,        0.042f,        0.041f,        0.040f,        0.040f,        0.039f,        0.038f,        0.038f,        0.038f,        0.037f,        0.036f,        0.036f,        0.035f,        0.035f,        0.035f,        0.034f,        0.033f,        0.033f,        0.032f,        0.032f,        0.031f,        0.029f,
		0.068f,        0.066f,        0.062f,        0.059f,        0.056f,        0.053f,        0.050f,        0.047f,        0.045f,        0.043f,        0.042f,        0.041f,        0.040f,        0.040f,        0.039f,        0.039f,        0.038f,        0.037f,        0.037f,        0.036f,        0.036f,        0.035f,        0.035f,        0.035f,        0.034f,        0.034f,        0.033f,        0.033f,        0.032f,        0.032f,        0.031f,        0.029f,
		0.066f,        0.065f,        0.061f,        0.057f,        0.054f,        0.051f,        0.049f,        0.047f,        0.045f,        0.043f,        0.042f,        0.041f,        0.040f,        0.039f,        0.039f,        0.038f,        0.037f,        0.037f,        0.037f,        0.036f,        0.035f,        0.035f,        0.035f,        0.034f,        0.034f,        0.033f,        0.033f,        0.032f,        0.032f,        0.032f,        0.031f,        0.029f,
		0.063f,        0.062f,        0.058f,        0.055f,        0.053f,        0.050f,        0.048f,        0.046f,        0.044f,        0.043f,        0.041f,        0.040f,        0.040f,        0.039f,        0.038f,        0.038f,        0.037f,        0.036f,        0.036f,        0.035f,        0.035f,        0.034f,        0.034f,        0.034f,        0.033f,        0.033f,        0.033f,        0.032f,        0.032f,        0.031f,        0.030f,        0.028f,
		0.061f,        0.060f,        0.057f,        0.053f,        0.051f,        0.049f,        0.046f,        0.045f,        0.043f,        0.042f,        0.041f,        0.040f,        0.039f,        0.038f,        0.038f,        0.037f,        0.036f,        0.036f,        0.035f,        0.035f,        0.035f,        0.034f,        0.033f,        0.033f,        0.033f,        0.033f,        0.032f,        0.032f,        0.032f,        0.031f,        0.030f,        0.029f,
		0.057f,        0.057f,        0.054f,        0.051f,        0.049f,        0.047f,        0.046f,        0.044f,        0.042f,        0.041f,        0.040f,        0.039f,        0.038f,        0.038f,        0.037f,        0.036f,        0.036f,        0.035f,        0.035f,        0.034f,        0.034f,        0.034f,        0.033f,        0.033f,        0.033f,        0.032f,        0.032f,        0.032f,        0.031f,        0.031f,        0.030f,        0.028f,
		0.057f,        0.056f,        0.053f,        0.051f,        0.048f,        0.047f,        0.045f,        0.043f,        0.042f,        0.041f,        0.040f,        0.039f,        0.038f,        0.037f,        0.037f,        0.036f,        0.035f,        0.035f,        0.034f,        0.034f,        0.033f,        0.033f,        0.033f,        0.033f,        0.033f,        0.032f,        0.032f,        0.031f,        0.031f,        0.031f,        0.030f,        0.028f,
		0.053f,        0.053f,        0.050f,        0.048f,        0.046f,        0.045f,        0.043f,        0.042f,        0.041f,        0.040f,        0.039f,        0.038f,        0.037f,        0.037f,        0.036f,        0.035f,        0.035f,        0.034f,        0.034f,        0.033f,        0.033f,        0.032f,        0.032f,        0.032f,        0.031f,        0.031f,        0.031f,        0.031f,        0.030f,        0.030f,        0.029f,        0.028f,
		0.052f,        0.051f,        0.049f,        0.046f,        0.044f,        0.043f,        0.041f,        0.040f,        0.039f,        0.038f,        0.037f,        0.036f,        0.036f,        0.035f,        0.034f,        0.034f,        0.033f,        0.033f,        0.032f,        0.032f,        0.031f,        0.031f,        0.031f,        0.031f,        0.030f,        0.030f,        0.030f,        0.030f,        0.029f,        0.029f,        0.028f,        0.027f,
	},
};
static const float qtable1[3][BLOCK1X*BLOCK1Y]=
{
	{
	     3038.169f,       31.551f,       11.801f,        7.303f,        4.710f,        3.634f,        2.870f,        2.458f,        2.118f,        1.918f,        1.736f,        1.584f,        1.448f,        1.350f,        1.250f,        1.295f,
	       25.503f,       11.331f,        7.096f,        4.789f,        3.541f,        2.832f,        2.400f,        2.099f,        1.875f,        1.717f,        1.580f,        1.464f,        1.360f,        1.271f,        1.191f,        1.143f,
	       10.196f,        6.803f,        5.056f,        3.794f,        3.002f,        2.509f,        2.183f,        1.952f,        1.766f,        1.641f,        1.525f,        1.417f,        1.319f,        1.234f,        1.157f,        1.120f,
		6.392f,        4.550f,        3.711f,        3.056f,        2.573f,        2.245f,        2.001f,        1.826f,        1.679f,        1.576f,        1.463f,        1.373f,        1.281f,        1.204f,        1.129f,        1.088f,
		4.267f,        3.385f,        2.929f,        2.553f,        2.263f,        2.033f,        1.853f,        1.722f,        1.599f,        1.513f,        1.410f,        1.326f,        1.240f,        1.165f,        1.101f,        1.056f,
		3.343f,        2.729f,        2.452f,        2.213f,        2.020f,        1.864f,        1.735f,        1.633f,        1.532f,        1.448f,        1.364f,        1.279f,        1.208f,        1.126f,        1.072f,        1.020f,
		2.697f,        2.328f,        2.135f,        1.976f,        1.846f,        1.733f,        1.635f,        1.551f,        1.467f,        1.393f,        1.314f,        1.241f,        1.155f,        1.095f,        1.026f,        0.991f,
		2.320f,        2.039f,        1.904f,        1.796f,        1.700f,        1.616f,        1.544f,        1.471f,        1.397f,        1.330f,        1.254f,        1.192f,        1.111f,        1.055f,        0.986f,        0.949f,
		2.028f,        1.822f,        1.725f,        1.649f,        1.586f,        1.523f,        1.457f,        1.395f,        1.335f,        1.275f,        1.198f,        1.131f,        1.066f,        0.997f,        0.951f,        0.915f,
		1.840f,        1.675f,        1.598f,        1.545f,        1.481f,        1.436f,        1.384f,        1.325f,        1.270f,        1.211f,        1.152f,        1.082f,        1.023f,        0.957f,        0.905f,        0.867f,
		1.682f,        1.543f,        1.484f,        1.440f,        1.392f,        1.349f,        1.306f,        1.256f,        1.201f,        1.143f,        1.087f,        1.029f,        0.965f,        0.903f,        0.866f,        0.832f,
		1.551f,        1.427f,        1.382f,        1.343f,        1.309f,        1.266f,        1.228f,        1.178f,        1.130f,        1.079f,        1.026f,        0.963f,        0.911f,        0.852f,        0.811f,        0.775f,
		1.410f,        1.326f,        1.298f,        1.257f,        1.221f,        1.185f,        1.147f,        1.107f,        1.057f,        1.012f,        0.965f,        0.902f,        0.857f,        0.805f,        0.761f,        0.748f,
		1.314f,        1.238f,        1.214f,        1.186f,        1.148f,        1.121f,        1.080f,        1.049f,        1.003f,        0.953f,        0.906f,        0.852f,        0.801f,        0.755f,        0.728f,        0.704f,
		1.232f,        1.169f,        1.145f,        1.120f,        1.083f,        1.052f,        1.026f,        0.985f,        0.951f,        0.902f,        0.857f,        0.803f,        0.764f,        0.726f,        0.695f,        0.676f,
		1.284f,        1.128f,        1.101f,        1.077f,        1.055f,        1.012f,        0.982f,        0.949f,        0.915f,        0.868f,        0.828f,        0.782f,        0.732f,        0.707f,        0.678f,        0.661f,
	},
	{
	      255.579f,        7.223f,        3.151f,        2.075f,        1.525f,        1.214f,        1.011f,        0.863f,        0.734f,        0.655f,        0.573f,        0.503f,        0.446f,        0.399f,        0.361f,        0.336f,
		5.424f,        2.873f,        2.007f,        1.506f,        1.210f,        0.996f,        0.852f,        0.733f,        0.632f,        0.559f,        0.490f,        0.436f,        0.395f,        0.359f,        0.329f,        0.307f,
		2.608f,        1.921f,        1.536f,        1.238f,        1.027f,        0.864f,        0.746f,        0.646f,        0.562f,        0.498f,        0.443f,        0.399f,        0.364f,        0.335f,        0.310f,        0.290f,
		1.806f,        1.434f,        1.216f,        1.025f,        0.869f,        0.742f,        0.644f,        0.561f,        0.491f,        0.441f,        0.396f,        0.361f,        0.334f,        0.310f,        0.290f,        0.274f,
		1.380f,        1.147f,        0.997f,        0.856f,        0.737f,        0.635f,        0.559f,        0.492f,        0.435f,        0.393f,        0.358f,        0.330f,        0.308f,        0.289f,        0.273f,        0.261f,
		1.123f,        0.949f,        0.835f,        0.725f,        0.632f,        0.554f,        0.496f,        0.443f,        0.395f,        0.361f,        0.331f,        0.308f,        0.290f,        0.274f,        0.262f,        0.251f,
		0.936f,        0.806f,        0.715f,        0.624f,        0.549f,        0.491f,        0.449f,        0.409f,        0.372f,        0.341f,        0.315f,        0.294f,        0.278f,        0.264f,        0.254f,        0.244f,
		0.799f,        0.697f,        0.621f,        0.545f,        0.485f,        0.439f,        0.409f,        0.381f,        0.352f,        0.327f,        0.304f,        0.284f,        0.269f,        0.257f,        0.247f,        0.239f,
		0.682f,        0.600f,        0.538f,        0.477f,        0.427f,        0.392f,        0.369f,        0.351f,        0.331f,        0.312f,        0.292f,        0.275f,        0.261f,        0.250f,        0.241f,        0.234f,
		0.592f,        0.522f,        0.472f,        0.422f,        0.383f,        0.354f,        0.337f,        0.324f,        0.310f,        0.297f,        0.281f,        0.267f,        0.254f,        0.244f,        0.235f,        0.229f,
		0.529f,        0.466f,        0.425f,        0.384f,        0.350f,        0.327f,        0.312f,        0.301f,        0.291f,        0.281f,        0.270f,        0.259f,        0.248f,        0.238f,        0.231f,        0.225f,
		0.471f,        0.418f,        0.385f,        0.351f,        0.324f,        0.305f,        0.292f,        0.282f,        0.274f,        0.267f,        0.259f,        0.251f,        0.242f,        0.234f,        0.227f,        0.222f,
		0.419f,        0.379f,        0.352f,        0.325f,        0.304f,        0.287f,        0.277f,        0.269f,        0.261f,        0.255f,        0.249f,        0.243f,        0.236f,        0.229f,        0.223f,        0.218f,
		0.379f,        0.349f,        0.327f,        0.305f,        0.287f,        0.275f,        0.265f,        0.258f,        0.251f,        0.246f,        0.241f,        0.235f,        0.230f,        0.225f,        0.220f,        0.216f,
		0.345f,        0.320f,        0.304f,        0.287f,        0.273f,        0.263f,        0.256f,        0.250f,        0.243f,        0.239f,        0.234f,        0.229f,        0.225f,        0.221f,        0.217f,        0.214f,
		0.326f,        0.303f,        0.288f,        0.274f,        0.263f,        0.255f,        0.248f,        0.243f,        0.237f,        0.233f,        0.229f,        0.224f,        0.221f,        0.217f,        0.214f,        0.213f,
	},
	{
	      171.141f,        5.042f,        2.322f,        1.545f,        1.151f,        0.920f,        0.772f,        0.659f,        0.562f,        0.503f,        0.442f,        0.390f,        0.349f,        0.310f,        0.282f,        0.263f,
		3.890f,        2.163f,        1.534f,        1.159f,        0.933f,        0.765f,        0.655f,        0.565f,        0.486f,        0.431f,        0.379f,        0.337f,        0.308f,        0.280f,        0.257f,        0.240f,
		1.989f,        1.489f,        1.192f,        0.961f,        0.795f,        0.667f,        0.574f,        0.497f,        0.433f,        0.384f,        0.342f,        0.308f,        0.283f,        0.260f,        0.241f,        0.226f,
		1.400f,        1.123f,        0.951f,        0.799f,        0.674f,        0.574f,        0.497f,        0.433f,        0.378f,        0.339f,        0.305f,        0.279f,        0.259f,        0.241f,        0.225f,        0.213f,
		1.080f,        0.902f,        0.780f,        0.669f,        0.573f,        0.493f,        0.432f,        0.380f,        0.335f,        0.302f,        0.275f,        0.254f,        0.238f,        0.224f,        0.212f,        0.202f,
		0.886f,        0.750f,        0.655f,        0.566f,        0.491f,        0.430f,        0.383f,        0.341f,        0.305f,        0.277f,        0.255f,        0.238f,        0.224f,        0.213f,        0.203f,        0.194f,
		0.741f,        0.638f,        0.560f,        0.487f,        0.427f,        0.381f,        0.348f,        0.317f,        0.287f,        0.263f,        0.243f,        0.226f,        0.215f,        0.205f,        0.196f,        0.189f,
		0.634f,        0.552f,        0.487f,        0.425f,        0.376f,        0.340f,        0.317f,        0.295f,        0.273f,        0.252f,        0.234f,        0.219f,        0.207f,        0.198f,        0.191f,        0.184f,
		0.538f,        0.474f,        0.422f,        0.372f,        0.331f,        0.303f,        0.286f,        0.272f,        0.256f,        0.240f,        0.225f,        0.212f,        0.201f,        0.193f,        0.186f,        0.180f,
		0.467f,        0.412f,        0.370f,        0.329f,        0.297f,        0.273f,        0.260f,        0.250f,        0.240f,        0.229f,        0.217f,        0.205f,        0.196f,        0.188f,        0.182f,        0.176f,
		0.417f,        0.368f,        0.333f,        0.299f,        0.272f,        0.252f,        0.241f,        0.233f,        0.225f,        0.217f,        0.209f,        0.200f,        0.191f,        0.184f,        0.178f,        0.173f,
		0.371f,        0.330f,        0.302f,        0.274f,        0.251f,        0.235f,        0.226f,        0.218f,        0.212f,        0.206f,        0.200f,        0.193f,        0.187f,        0.180f,        0.174f,        0.170f,
		0.332f,        0.300f,        0.277f,        0.254f,        0.236f,        0.223f,        0.214f,        0.207f,        0.202f,        0.197f,        0.192f,        0.187f,        0.182f,        0.176f,        0.172f,        0.167f,
		0.301f,        0.276f,        0.257f,        0.239f,        0.224f,        0.213f,        0.206f,        0.200f,        0.194f,        0.190f,        0.185f,        0.181f,        0.177f,        0.173f,        0.169f,        0.166f,
		0.274f,        0.254f,        0.239f,        0.225f,        0.213f,        0.204f,        0.198f,        0.193f,        0.188f,        0.184f,        0.180f,        0.176f,        0.173f,        0.170f,        0.167f,        0.164f,
		0.258f,        0.239f,        0.226f,        0.214f,        0.204f,        0.197f,        0.192f,        0.187f,        0.183f,        0.179f,        0.175f,        0.172f,        0.169f,        0.167f,        0.164f,        0.162f,
	},
};
static const float qtable2[3][BLOCK2X*BLOCK2Y]=
{
	{
	     1016.583f,       20.144f,        8.278f,        4.853f,        3.302f,        2.473f,        1.951f,        1.627f,
	       18.286f,        8.204f,        5.097f,        3.469f,        2.645f,        2.106f,        1.742f,        1.477f,
		7.646f,        4.981f,        3.716f,        2.855f,        2.325f,        1.939f,        1.632f,        1.401f,
		4.519f,        3.361f,        2.811f,        2.379f,        2.050f,        1.770f,        1.515f,        1.309f,
		3.115f,        2.544f,        2.268f,        2.028f,        1.802f,        1.590f,        1.374f,        1.195f,
		2.364f,        2.038f,        1.893f,        1.747f,        1.579f,        1.403f,        1.219f,        1.060f,
		1.875f,        1.688f,        1.594f,        1.488f,        1.358f,        1.212f,        1.051f,        0.919f,
		1.570f,        1.439f,        1.368f,        1.283f,        1.179f,        1.051f,        0.916f,        0.812f,
	},
	{
	      117.461f,        5.459f,        2.922f,        1.941f,        1.371f,        0.987f,        0.712f,        0.534f,
		4.971f,        2.838f,        2.034f,        1.470f,        1.094f,        0.816f,        0.611f,        0.480f,
		2.713f,        1.984f,        1.553f,        1.178f,        0.903f,        0.698f,        0.544f,        0.448f,
		1.807f,        1.413f,        1.156f,        0.916f,        0.730f,        0.590f,        0.484f,        0.418f,
		1.283f,        1.046f,        0.880f,        0.724f,        0.601f,        0.507f,        0.436f,        0.392f,
		0.927f,        0.781f,        0.680f,        0.582f,        0.505f,        0.445f,        0.399f,        0.370f,
		0.676f,        0.590f,        0.533f,        0.479f,        0.435f,        0.400f,        0.371f,        0.352f,
		0.516f,        0.469f,        0.442f,        0.416f,        0.391f,        0.371f,        0.353f,        0.341f,
	},
	{
	       89.684f,        4.100f,        2.227f,        1.502f,        1.067f,        0.770f,        0.564f,        0.432f,
		3.729f,        2.192f,        1.582f,        1.149f,        0.854f,        0.639f,        0.486f,        0.388f,
		2.090f,        1.551f,        1.217f,        0.926f,        0.708f,        0.550f,        0.435f,        0.363f,
		1.413f,        1.112f,        0.911f,        0.723f,        0.578f,        0.469f,        0.389f,        0.339f,
		1.007f,        0.823f,        0.694f,        0.574f,        0.480f,        0.408f,        0.354f,        0.319f,
		0.728f,        0.616f,        0.538f,        0.465f,        0.407f,        0.361f,        0.326f,        0.302f,
		0.537f,        0.471f,        0.428f,        0.386f,        0.353f,        0.326f,        0.303f,        0.288f,
		0.417f,        0.381f,        0.359f,        0.338f,        0.319f,        0.303f,        0.289f,        0.278f,
	},
};
static const float qtable3[3][BLOCK3X*BLOCK3Y]=
{
	{
	      572.882f,       37.509f,       18.714f,       10.107f,
	       34.428f,       19.003f,       12.542f,        7.719f,
	       16.837f,       11.945f,        9.016f,        6.080f,
		9.036f,        7.120f,        5.833f,        4.252f,
	},
	{
	      115.816f,       11.342f,        5.576f,        2.855f,
	       10.939f,        6.152f,        3.766f,        2.177f,
		5.305f,        3.680f,        2.573f,        1.688f,
		2.689f,        2.092f,        1.658f,        1.267f,
	},
	{
	      113.775f,       10.541f,        5.128f,        2.519f,
	       10.172f,        5.665f,        3.385f,        1.860f,
		4.873f,        3.302f,        2.236f,        1.398f,
		2.365f,        1.781f,        1.371f,        1.018f,
	},
};
#endif
#if 0
static const float qtable_luma[]=
{
	16, 10, 12, 16,//v15
	10, 10, 16, 24,
	12, 16, 24, 24,
	16, 24, 24, 24,

	//10, 12, 14, 16,//v14
	//12, 20, 32, 32,
	//14, 32, 32, 32,
	//16, 32, 32, 32,

	//10, 24, 28, 32,
	//24, 28, 32, 32,
	//28, 32, 32, 32,
	//32, 32, 32, 32,

	//16, 18, 18, 14,//nice
	//18, 18, 14, 12,
	//18, 14, 12, 12,
	//14, 12, 12, 12,

	//16, 16, 14, 12,//good
	//16, 14, 12, 12,
	//14, 12, 12, 12,
	//12, 12, 12, 12,

	//10, 7, 7, 7,
	// 7, 7, 7, 7,
	// 7, 7, 7, 7,
	// 7, 7, 7, 7,

	//12, 13, 14, 15,
	//13, 14, 15, 16,
	//14, 15, 16, 16,
	//15, 16, 16, 16,

	//12, 12, 14, 16,
	//12, 14, 16, 32,
	//14, 16, 24, 32,
	//16, 32, 32, 32,

	//5, 6, 7, 8,//CRASH overflow
	//6, 7, 8, 9,
	//7, 8, 8, 9,
	//8, 9, 9, 9,

	//5, 3, 4, 5,
	//3, 4, 5, 6,
	//4, 5, 5, 6,
	//5, 6, 6, 6,

	//16, 24, 32, 48,
	//24, 32, 48, 64,
	//32, 48, 48, 64,
	//48, 64, 64, 64,
};
static const float qtable_chroma[]=
{
	16, 10, 12, 12,//v14
	10, 10, 12, 12,
	12, 12, 12, 12,
	12, 12, 12, 12,

	//10, 12, 14, 16,
	//12, 20, 32, 32,
	//14, 32, 32, 32,
	//16, 32, 32, 32,

	//12, 12, 10, 10,
	//12, 10, 10, 10,
	//10, 10, 10, 10,
	//10, 10, 10, 10,

	//12, 12, 13, 13,
	//12, 13, 15, 16,
	//13, 15, 16, 16,
	//13, 16, 16, 16,

	//10, 7, 7, 7,
	// 7, 7, 7, 7,
	// 7, 7, 7, 7,
	// 7, 7, 7, 7,

	//10, 4, 3, 2,
	// 4, 3, 2, 1,
	// 3, 2, 1, 1,
	// 2, 1, 1, 1,

	//12, 13, 14, 15,
	//13, 14, 15, 15,
	//14, 15, 15, 15,
	//15, 15, 15, 15,

	//12, 12, 14, 16,
	//12, 14, 16, 16,
	//14, 16, 16, 16,
	//16, 16, 16, 16,

	//5, 6, 7, 8,//CRASH overflow
	//6, 7, 8, 8,
	//7, 8, 8, 8,
	//8, 8, 8, 8,

	//5, 3, 4, 4,
	//3, 4, 4, 4,
	//4, 4, 4, 4,
	//4, 4, 4, 4,

	//16, 24, 32, 32,
	//24, 32, 32, 32,
	//32, 32, 32, 32,
	//32, 32, 32, 32,
};
#endif
AWM_INLINE void cvti2f(float *block)
{
	__m128i a[4];

	a[0]=_mm_load_si128((__m128i*)block+0);
	a[1]=_mm_load_si128((__m128i*)block+1);
	a[2]=_mm_load_si128((__m128i*)block+2);
	a[3]=_mm_load_si128((__m128i*)block+3);

	_mm_store_ps(block+0*4, _mm_cvtepi32_ps(a[0]));
	_mm_store_ps(block+1*4, _mm_cvtepi32_ps(a[1]));
	_mm_store_ps(block+2*4, _mm_cvtepi32_ps(a[2]));
	_mm_store_ps(block+3*4, _mm_cvtepi32_ps(a[3]));
}
AWM_INLINE void cvtf2i(float *block)
{
	__m128 a[8];

	a[0]=_mm_load_ps(block+0*4);
	a[1]=_mm_load_ps(block+1*4);
	a[2]=_mm_load_ps(block+2*4);
	a[3]=_mm_load_ps(block+3*4);

	_mm_store_si128((__m128i*)block+0, _mm_cvtps_epi32(a[0]));
	_mm_store_si128((__m128i*)block+1, _mm_cvtps_epi32(a[1]));
	_mm_store_si128((__m128i*)block+2, _mm_cvtps_epi32(a[2]));
	_mm_store_si128((__m128i*)block+3, _mm_cvtps_epi32(a[3]));
}
AWM_INLINE void rgb2yuv(float *c0, float *c1, float *c2)
{
	__m128 half=_mm_set1_ps(128);
	for(int k=0;k<4;++k)
	{
		__m128 rgb[3], yuv[3];

		rgb[0]=_mm_load_ps(c0+k*4);
		rgb[1]=_mm_load_ps(c1+k*4);
		rgb[2]=_mm_load_ps(c2+k*4);
		
		//https://en.wikipedia.org/wiki/YCbCr
		yuv[0]=_mm_mul_ps(_mm_set1_ps(+0.299000f), rgb[0]);
		yuv[1]=_mm_mul_ps(_mm_set1_ps(-0.168736f), rgb[0]);
		yuv[2]=_mm_mul_ps(_mm_set1_ps(+0.500000f), rgb[0]);
		yuv[0]=_mm_add_ps(yuv[0], _mm_mul_ps(_mm_set1_ps(+0.587000f), rgb[1]));
		yuv[1]=_mm_add_ps(yuv[1], _mm_mul_ps(_mm_set1_ps(-0.331264f), rgb[1]));
		yuv[2]=_mm_add_ps(yuv[2], _mm_mul_ps(_mm_set1_ps(-0.418688f), rgb[1]));
		yuv[0]=_mm_add_ps(yuv[0], _mm_mul_ps(_mm_set1_ps(+0.114000f), rgb[2]));
		yuv[1]=_mm_add_ps(yuv[1], _mm_mul_ps(_mm_set1_ps(+0.500000f), rgb[2]));
		yuv[2]=_mm_add_ps(yuv[2], _mm_mul_ps(_mm_set1_ps(-0.081312f), rgb[2]));
		
		yuv[0]=_mm_sub_ps(yuv[0], half);
	//	yuv[1]=_mm_add_ps(yuv[1], half);
	//	yuv[2]=_mm_add_ps(yuv[2], half);

		_mm_store_ps(c0+k*4, yuv[0]);
		_mm_store_ps(c1+k*4, yuv[1]);
		_mm_store_ps(c2+k*4, yuv[2]);
	}
}
AWM_INLINE void yuv2rgb(float *c0, float *c1, float *c2)
{
	__m128 half=_mm_set1_ps(128);
	__m128 vmin=_mm_setzero_ps();
	__m128 vmax=_mm_set1_ps(255);
	for(int k=0;k<4;++k)
	{
		__m128 rgb[3], yuv[3];

		yuv[0]=_mm_load_ps(c0+k*4);
		yuv[1]=_mm_load_ps(c1+k*4);
		yuv[2]=_mm_load_ps(c2+k*4);
		
		yuv[0]=_mm_add_ps(yuv[0], half);
	//	yuv[1]=_mm_sub_ps(yuv[1], half);
	//	yuv[2]=_mm_sub_ps(yuv[2], half);

		rgb[1]=_mm_add_ps(yuv[0], _mm_mul_ps(_mm_set1_ps(-0.344136f), yuv[1]));
		rgb[2]=_mm_add_ps(yuv[0], _mm_mul_ps(_mm_set1_ps(+1.772f), yuv[1]));
		rgb[0]=_mm_add_ps(yuv[0], _mm_mul_ps(_mm_set1_ps(+1.402f), yuv[2]));
		rgb[1]=_mm_add_ps(rgb[1], _mm_mul_ps(_mm_set1_ps(-0.714136f), yuv[2]));

		rgb[0]=_mm_min_ps(rgb[0], vmax);
		rgb[1]=_mm_min_ps(rgb[1], vmax);
		rgb[2]=_mm_min_ps(rgb[2], vmax);
		rgb[0]=_mm_max_ps(rgb[0], vmin);
		rgb[1]=_mm_max_ps(rgb[1], vmin);
		rgb[2]=_mm_max_ps(rgb[2], vmin);
		_mm_store_ps(c0+k*4, rgb[0]);
		_mm_store_ps(c1+k*4, rgb[1]);
		_mm_store_ps(c2+k*4, rgb[2]);
	}
}

AWM_INLINE void dct4y4_fwd(float *block)//DCT-II
{
	__m128 c3=_mm_set1_ps(0.3826834323650897717284599840304f);//cosd(90*3/4) = sind(90*1/4) = s1
	__m128 c2=_mm_set1_ps(0.7071067811865475244008443621048f);//cosd(90*2/4) = sind(90*2/4) = s2 = sqrt(2)
	__m128 c1=_mm_set1_ps(0.9238795325112867561281831893968f);//cosd(90*1/4) = sind(90*3/4) = s3

	__m128 a[4], b[4];

	a[0]=_mm_load_ps(block+0*4);
	a[1]=_mm_load_ps(block+1*4);
	a[2]=_mm_load_ps(block+2*4);
	a[3]=_mm_load_ps(block+3*4);

	b[0]=_mm_add_ps(a[0], a[3]);//step 1
	b[1]=_mm_add_ps(a[1], a[2]);
	b[2]=_mm_sub_ps(a[1], a[2]);
	b[3]=_mm_sub_ps(a[0], a[3]);

	a[0]=_mm_add_ps(b[0], b[1]);//step 2
	a[1]=_mm_mul_ps(_mm_sub_ps(b[0], b[1]), c2);
	a[2]=_mm_add_ps(_mm_mul_ps(b[3], c1), _mm_mul_ps(b[2], c3));
	a[3]=_mm_sub_ps(_mm_mul_ps(b[3], c3), _mm_mul_ps(b[2], c1));

	_mm_store_ps(block+0*4, a[0]);
	_mm_store_ps(block+2*4, a[1]);
	_mm_store_ps(block+1*4, a[2]);
	_mm_store_ps(block+3*4, a[3]);
}
AWM_INLINE void dct4y4_inv(float *block)//DCT-III
{
	__m128 half=_mm_set1_ps(0.5f);
	__m128 c3=_mm_set1_ps(0.3826834323650897717284599840304f);//cosd(90*3/4) = sind(90*1/4) = s1
	__m128 c2=_mm_set1_ps(0.7071067811865475244008443621048f);//cosd(90*2/4) = sind(90*2/4) = s2 = sqrt(2)
	__m128 c1=_mm_set1_ps(0.9238795325112867561281831893968f);//cosd(90*1/4) = sind(90*3/4) = s3

	__m128 a[4], b[4];

	a[0]=_mm_load_ps(block+0*4);
	a[1]=_mm_load_ps(block+2*4);
	a[2]=_mm_load_ps(block+1*4);
	a[3]=_mm_load_ps(block+3*4);
	
	/*
	matrix					inverse
	M0 = [1 1;1 -1]				same/2
	M1: [a0;a1] = [1 1;c2 -c2][b0;b1]	[b0;b1] = [1/2 c2;1/2 -c2][a0;a1]
	M2: [a2;a3] = [c3 c1;-c1 c3][b2;b3]	transpose [b2;b3] = [c3 -c1;c1 c3][a2;a3]
	*/
	a[0]=_mm_mul_ps(a[0], half);
	a[1]=_mm_mul_ps(a[1], c2);

	b[0]=_mm_add_ps(a[0], a[1]);//step 2
	b[1]=_mm_sub_ps(a[0], a[1]);
	b[2]=_mm_sub_ps(_mm_mul_ps(a[2], c3), _mm_mul_ps(a[3], c1));
	b[3]=_mm_add_ps(_mm_mul_ps(a[2], c1), _mm_mul_ps(a[3], c3));

	a[0]=_mm_add_ps(b[0], b[3]);//step 1
	a[1]=_mm_add_ps(b[1], b[2]);
	a[2]=_mm_sub_ps(b[1], b[2]);
	a[3]=_mm_sub_ps(b[0], b[3]);

	_mm_store_ps(block+0*4, a[0]);
	_mm_store_ps(block+1*4, a[1]);
	_mm_store_ps(block+2*4, a[2]);
	_mm_store_ps(block+3*4, a[3]);
}
AWM_INLINE void dct8y8_fwd(float *block)//DCT-II
{
	/*
	DCTii8 =

	DCTii4		0
	0		C * DCTii4
	
	where C = diag(cos(pi*1/16), cos(pi*3/16), cos(pi*5/16), cos(pi*7/16))
	*/

	//Chen factorization
	__m256 c7=_mm256_set1_ps(0.1950903220161282678482848684770f);//cosd(90*7/8) = sind(90*1/8) = s1
	__m256 c6=_mm256_set1_ps(0.3826834323650897717284599840304f);//cosd(90*6/8) = sind(90*2/8) = s2
	__m256 c5=_mm256_set1_ps(0.5555702330196022247428308139485f);//cosd(90*5/8) = sind(90*3/8) = s3
	__m256 c4=_mm256_set1_ps(0.7071067811865475244008443621048f);//cosd(90*4/8) = sind(90*4/8) = s4 = sqrt(2)
	__m256 c3=_mm256_set1_ps(0.8314696123025452370787883776179f);//cosd(90*3/8) = sind(90*5/8) = s5
	__m256 c2=_mm256_set1_ps(0.9238795325112867561281831893968f);//cosd(90*2/8) = sind(90*6/8) = s6
	__m256 c1=_mm256_set1_ps(0.9807852804032304491261822361342f);//cosd(90*1/8) = sind(90*7/8) = s7

	__m256 a[8], b[8];

	a[0]=_mm256_load_ps(block+0*8);
	a[1]=_mm256_load_ps(block+1*8);
	a[2]=_mm256_load_ps(block+2*8);
	a[3]=_mm256_load_ps(block+3*8);
	a[4]=_mm256_load_ps(block+4*8);
	a[5]=_mm256_load_ps(block+5*8);
	a[6]=_mm256_load_ps(block+6*8);
	a[7]=_mm256_load_ps(block+7*8);

	b[0]=_mm256_add_ps(a[0], a[7]);//step 1
	b[1]=_mm256_add_ps(a[1], a[6]);
	b[2]=_mm256_add_ps(a[2], a[5]);
	b[3]=_mm256_add_ps(a[3], a[4]);
	b[4]=_mm256_sub_ps(a[3], a[4]);
	b[5]=_mm256_sub_ps(a[2], a[5]);
	b[6]=_mm256_sub_ps(a[1], a[6]);
	b[7]=_mm256_sub_ps(a[0], a[7]);
	
	a[0]=_mm256_add_ps(b[0], b[3]);//step 2
	a[1]=_mm256_add_ps(b[1], b[2]);
	a[2]=_mm256_sub_ps(b[1], b[2]);
	a[3]=_mm256_sub_ps(b[0], b[3]);
	a[4]=b[4];
	a[5]=_mm256_mul_ps(_mm256_sub_ps(b[6], b[5]), c4);//M0
	a[6]=_mm256_mul_ps(_mm256_add_ps(b[6], b[5]), c4);
	a[7]=b[7];
	
	b[0]=_mm256_add_ps(a[0], a[1]);//step 3
	b[1]=_mm256_mul_ps(_mm256_sub_ps(a[0], a[1]), c4);
	b[2]=_mm256_add_ps(_mm256_mul_ps(a[3], c2), _mm256_mul_ps(a[2], c6));//M1
	b[3]=_mm256_sub_ps(_mm256_mul_ps(a[3], c6), _mm256_mul_ps(a[2], c2));
	b[4]=_mm256_add_ps(a[4], a[5]);
	b[5]=_mm256_sub_ps(a[4], a[5]);
	b[6]=_mm256_sub_ps(a[7], a[6]);
	b[7]=_mm256_add_ps(a[7], a[6]);
	
	a[0]=b[0];//step 4
	a[1]=b[1];
	a[2]=b[2];
	a[3]=b[3];
	a[4]=_mm256_add_ps(_mm256_mul_ps(b[7], c1), _mm256_mul_ps(b[4], c7));//M2
	a[5]=_mm256_add_ps(_mm256_mul_ps(b[6], c5), _mm256_mul_ps(b[5], c3));//M3
	a[6]=_mm256_sub_ps(_mm256_mul_ps(b[6], c3), _mm256_mul_ps(b[5], c5));
	a[7]=_mm256_sub_ps(_mm256_mul_ps(b[7], c7), _mm256_mul_ps(b[4], c1));

	_mm256_store_ps(block+0*8, a[0]);
	_mm256_store_ps(block+4*8, a[1]);
	_mm256_store_ps(block+2*8, a[2]);
	_mm256_store_ps(block+6*8, a[3]);
	_mm256_store_ps(block+1*8, a[4]);
	_mm256_store_ps(block+5*8, a[5]);
	_mm256_store_ps(block+3*8, a[6]);
	_mm256_store_ps(block+7*8, a[7]);
}
AWM_INLINE void dct8y8_inv(float *block)//DCT-III
{
	//Chen factorization
	__m256 c7=_mm256_set1_ps(0.1950903220161282678482848684770f);//cosd(90*7/8) = sind(90*1/8) = s1
	__m256 c6=_mm256_set1_ps(0.3826834323650897717284599840304f);//cosd(90*6/8) = sind(90*2/8) = s2
	__m256 c5=_mm256_set1_ps(0.5555702330196022247428308139485f);//cosd(90*5/8) = sind(90*3/8) = s3
	__m256 c4=_mm256_set1_ps(0.7071067811865475244008443621048f);//cosd(90*4/8) = sind(90*4/8) = s4 = sqrt(2)
	__m256 c3=_mm256_set1_ps(0.8314696123025452370787883776179f);//cosd(90*3/8) = sind(90*5/8) = s5
	__m256 c2=_mm256_set1_ps(0.9238795325112867561281831893968f);//cosd(90*2/8) = sind(90*6/8) = s6
	__m256 c1=_mm256_set1_ps(0.9807852804032304491261822361342f);//cosd(90*1/8) = sind(90*7/8) = s7

	__m256 a[8], b[8];

	b[0]=_mm256_load_ps(block+0*8);
	b[1]=_mm256_load_ps(block+4*8);
	b[2]=_mm256_load_ps(block+2*8);
	b[3]=_mm256_load_ps(block+6*8);
	b[4]=_mm256_load_ps(block+1*8);
	b[5]=_mm256_load_ps(block+5*8);
	b[6]=_mm256_load_ps(block+3*8);
	b[7]=_mm256_load_ps(block+7*8);

	/*
	matrix					inverse
	M0 = [c4 c4;c4 -c4]			itself (scaled)
	M1: [a2;a3] = [c6 c2;-c2 c6][b2;b3]	transpose [b2;b3] = [c6 -c2;c2 c6][a2;a3]
	M2: [a4;a7] = [c7 c1;-c1 c7][b4;b7]	transpose [a4;a7] = [c7 -c1;c1 c7][b4;b7]
	M3: [a5;a6] = [c3 c5;-c5 c3][b5;b6]	transpose [a5;a6] = [c3 -c5;c5 c3][b5;b6]
	*/
	a[0]=b[0];//step 4
	a[1]=b[1];
	a[2]=b[2];
	a[3]=b[3];
	a[4]=_mm256_sub_ps(_mm256_mul_ps(b[4], c7), _mm256_mul_ps(b[7], c1));//M2 (transposed)
	a[5]=_mm256_sub_ps(_mm256_mul_ps(b[5], c3), _mm256_mul_ps(b[6], c5));//M3 (transposed)
	a[6]=_mm256_add_ps(_mm256_mul_ps(b[5], c5), _mm256_mul_ps(b[6], c3));
	a[7]=_mm256_add_ps(_mm256_mul_ps(b[4], c1), _mm256_mul_ps(b[7], c7));

	a[0]=_mm256_mul_ps(a[0], _mm256_set1_ps(0.5f));
	a[1]=_mm256_mul_ps(a[1], c4);
	
	b[0]=_mm256_add_ps(a[0], a[1]);//step 3
	b[1]=_mm256_sub_ps(a[0], a[1]);
	b[2]=_mm256_sub_ps(_mm256_mul_ps(a[2], c6), _mm256_mul_ps(a[3], c2));//M1
	b[3]=_mm256_add_ps(_mm256_mul_ps(a[2], c2), _mm256_mul_ps(a[3], c6));
	b[4]=_mm256_add_ps(a[4], a[5]);
	b[5]=_mm256_sub_ps(a[4], a[5]);
	b[6]=_mm256_sub_ps(a[7], a[6]);
	b[7]=_mm256_add_ps(a[7], a[6]);
	
	a[0]=_mm256_add_ps(b[0], b[3]);//step 2
	a[1]=_mm256_add_ps(b[1], b[2]);
	a[2]=_mm256_sub_ps(b[1], b[2]);
	a[3]=_mm256_sub_ps(b[0], b[3]);
	a[4]=b[4];
	a[5]=_mm256_mul_ps(_mm256_sub_ps(b[6], b[5]), c4);//M0
	a[6]=_mm256_mul_ps(_mm256_add_ps(b[6], b[5]), c4);
	a[7]=b[7];
	
	b[0]=_mm256_add_ps(a[0], a[7]);//step 1
	b[1]=_mm256_add_ps(a[1], a[6]);
	b[2]=_mm256_add_ps(a[2], a[5]);
	b[3]=_mm256_add_ps(a[3], a[4]);
	b[4]=_mm256_sub_ps(a[3], a[4]);
	b[5]=_mm256_sub_ps(a[2], a[5]);
	b[6]=_mm256_sub_ps(a[1], a[6]);
	b[7]=_mm256_sub_ps(a[0], a[7]);

	_mm256_store_ps(block+0*8, b[0]);
	_mm256_store_ps(block+1*8, b[1]);
	_mm256_store_ps(block+2*8, b[2]);
	_mm256_store_ps(block+3*8, b[3]);
	_mm256_store_ps(block+4*8, b[4]);
	_mm256_store_ps(block+5*8, b[5]);
	_mm256_store_ps(block+6*8, b[6]);
	_mm256_store_ps(block+7*8, b[7]);
}

AWM_INLINE void dctii_4(float *data, const int stride)
{
	__m128 a[4], b[4];

	a[0]=_mm_load_ps(data+0*stride);
	a[1]=_mm_load_ps(data+1*stride);
	a[2]=_mm_load_ps(data+2*stride);
	a[3]=_mm_load_ps(data+3*stride);

	//Hbar		Add/SubReverse
	b[0]=_mm_add_ps(a[0], a[3]);
	b[1]=_mm_add_ps(a[1], a[2]);
	b[2]=_mm_sub_ps(a[0], a[3]);
	b[3]=_mm_sub_ps(a[1], a[2]);
	//b[0]=_mm_mul_ps(b[0], _mm_set1_ps(0.7071067811865475244008443621048f));
	//b[1]=_mm_mul_ps(b[1], _mm_set1_ps(0.7071067811865475244008443621048f));
	//b[2]=_mm_mul_ps(b[2], _mm_set1_ps(0.7071067811865475244008443621048f));
	//b[3]=_mm_mul_ps(b[3], _mm_set1_ps(0.7071067811865475244008443621048f));

	//Wc		Multiply
	b[2]=_mm_mul_ps(b[2], _mm_set1_ps(0.5411961001461969843997232053664f));//0.5 sec( 1 pi/(2*4))
	b[3]=_mm_mul_ps(b[3], _mm_set1_ps(1.3065629648763765278566431734272f));//0.5 sec( 3 pi/(2*4))

	//two half-DCTIIs
	a[0]=_mm_add_ps(b[0], b[1]);
	a[1]=_mm_sub_ps(b[0], b[1]);
	a[2]=_mm_add_ps(b[2], b[3]);
	a[3]=_mm_sub_ps(b[2], b[3]);
	//a[0]=_mm_mul_ps(a[0], _mm_set1_ps(0.7071067811865475244008443621048f));
	//a[1]=_mm_mul_ps(a[1], _mm_set1_ps(0.7071067811865475244008443621048f));
	//a[2]=_mm_mul_ps(a[2], _mm_set1_ps(0.7071067811865475244008443621048f));
	//a[3]=_mm_mul_ps(a[3], _mm_set1_ps(0.7071067811865475244008443621048f));

	//Bc		B
	a[2]=_mm_add_ps(_mm_mul_ps(a[2], _mm_set1_ps(1.4142135623730950488016887242097f)), a[3]);//sqrt2

	//PeoT
	_mm_store_ps(data+0*stride, a[0]);
	_mm_store_ps(data+1*stride, a[2]);
	_mm_store_ps(data+2*stride, a[1]);
	_mm_store_ps(data+3*stride, a[3]);
}
AWM_INLINE void dctiii_4(float *data, const int stride)
{
	__m128 a[4], b[4];

	//Peo
	a[0]=_mm_load_ps(data+0*stride);
	a[2]=_mm_load_ps(data+1*stride);
	a[1]=_mm_load_ps(data+2*stride);
	a[3]=_mm_load_ps(data+3*stride);

	//BcT
	a[3]=_mm_add_ps(a[3], a[2]);
	a[2]=_mm_mul_ps(a[2], _mm_set1_ps(1.4142135623730950488016887242097f));
	
	//two half-DCTIIIs
	//a[0]=_mm_mul_ps(a[0], _mm_set1_ps(0.7071067811865475244008443621048f));
	//a[1]=_mm_mul_ps(a[1], _mm_set1_ps(0.7071067811865475244008443621048f));
	//a[2]=_mm_mul_ps(a[2], _mm_set1_ps(0.7071067811865475244008443621048f));
	//a[3]=_mm_mul_ps(a[3], _mm_set1_ps(0.7071067811865475244008443621048f));
	b[0]=_mm_add_ps(a[0], a[1]);
	b[1]=_mm_sub_ps(a[0], a[1]);
	b[2]=_mm_add_ps(a[2], a[3]);
	b[3]=_mm_sub_ps(a[2], a[3]);

	//Wc
	b[2]=_mm_mul_ps(b[2], _mm_set1_ps(0.5411961001461969843997232053664f));//0.5 sec( 1 pi/(2*4))
	b[3]=_mm_mul_ps(b[3], _mm_set1_ps(1.3065629648763765278566431734272f));//0.5 sec( 3 pi/(2*4))

	//HbarT
	a[0]=_mm_add_ps(b[0], b[2]);
	a[1]=_mm_add_ps(b[1], b[3]);
	a[2]=_mm_sub_ps(b[1], b[3]);
	a[3]=_mm_sub_ps(b[0], b[2]);
	//a[0]=_mm_mul_ps(a[0], _mm_set1_ps(0.7071067811865475244008443621048f));
	//a[1]=_mm_mul_ps(a[1], _mm_set1_ps(0.7071067811865475244008443621048f));
	//a[2]=_mm_mul_ps(a[2], _mm_set1_ps(0.7071067811865475244008443621048f));
	//a[3]=_mm_mul_ps(a[3], _mm_set1_ps(0.7071067811865475244008443621048f));

	_mm_store_ps(data+0*stride, a[0]);
	_mm_store_ps(data+1*stride, a[1]);
	_mm_store_ps(data+2*stride, a[2]);
	_mm_store_ps(data+3*stride, a[3]);
}
AWM_INLINE void dctii_8(float *data, const int stride)
{
	__m128 a[8], b[8];
	
	a[0]=_mm_load_ps(data+0*stride);
	a[1]=_mm_load_ps(data+1*stride);
	a[2]=_mm_load_ps(data+2*stride);
	a[3]=_mm_load_ps(data+3*stride);
	a[4]=_mm_load_ps(data+4*stride);
	a[5]=_mm_load_ps(data+5*stride);
	a[6]=_mm_load_ps(data+6*stride);
	a[7]=_mm_load_ps(data+7*stride);

	//Hbar
	b[0]=_mm_add_ps(a[0], a[7]);
	b[1]=_mm_add_ps(a[1], a[6]);
	b[2]=_mm_add_ps(a[2], a[5]);
	b[3]=_mm_add_ps(a[3], a[4]);
	b[4]=_mm_sub_ps(a[0], a[7]);
	b[5]=_mm_sub_ps(a[1], a[6]);
	b[6]=_mm_sub_ps(a[2], a[5]);
	b[7]=_mm_sub_ps(a[3], a[4]);

	//Wc
	b[4]=_mm_mul_ps(b[4], _mm_set1_ps(0.50979557910415916894193980398784f));//0.5 sec(1 pi/(2*8))
	b[5]=_mm_mul_ps(b[5], _mm_set1_ps(0.60134488693504528054372182390922f));//0.5 sec(3 pi/(2*8))
	b[6]=_mm_mul_ps(b[6], _mm_set1_ps(0.89997622313641570463850954094189f));//0.5 sec(5 pi/(2*8))
	b[7]=_mm_mul_ps(b[7], _mm_set1_ps(2.56291544774150617879608629617770f));//0.5 sec(7 pi/(2*8))

	dctii_4((float*)(b+0*4), sizeof(__m128)/sizeof(float));
	dctii_4((float*)(b+1*4), sizeof(__m128)/sizeof(float));

	//Bc
	b[4]=_mm_add_ps(_mm_mul_ps(b[4], _mm_set1_ps(1.4142135623730950488016887242097f)), b[5]);//sqrt2
	b[5]=_mm_add_ps(b[5], b[6]);
	b[6]=_mm_add_ps(b[6], b[7]);

	//PeoT
	_mm_store_ps(data+0*stride, b[0]);
	_mm_store_ps(data+1*stride, b[4]);
	_mm_store_ps(data+2*stride, b[1]);
	_mm_store_ps(data+3*stride, b[5]);
	_mm_store_ps(data+4*stride, b[2]);
	_mm_store_ps(data+5*stride, b[6]);
	_mm_store_ps(data+6*stride, b[3]);
	_mm_store_ps(data+7*stride, b[7]);
#if 0
	__m128 w34=_mm_set1_ps(1.3065629648763765278566431734272f);//Wij = 0.5 sec(i*Pi/(2j))
	__m128 w14=_mm_set1_ps(0.5411961001461969843997232053664f);
	__m128 sqrt2=_mm_set1_ps(1.4142135623730950488016887242097f);

	__m128 a[8], b[8];

	a[0]=_mm_load_ps(data+0*stride);
	a[1]=_mm_load_ps(data+1*stride);
	a[2]=_mm_load_ps(data+2*stride);
	a[3]=_mm_load_ps(data+3*stride);
	a[4]=_mm_load_ps(data+4*stride);
	a[5]=_mm_load_ps(data+5*stride);
	a[6]=_mm_load_ps(data+6*stride);
	a[7]=_mm_load_ps(data+7*stride);

	b[0]=_mm_add_ps(a[0], a[7]);
	b[1]=_mm_add_ps(a[1], a[6]);
	b[2]=_mm_add_ps(a[2], a[5]);
	b[3]=_mm_add_ps(a[3], a[4]);
	b[4]=_mm_sub_ps(a[3], a[4]);
	b[5]=_mm_sub_ps(a[2], a[5]);
	b[6]=_mm_sub_ps(a[1], a[6]);
	b[7]=_mm_sub_ps(a[0], a[7]);

	b[4]=_mm_mul_ps(b[4], _mm_set1_ps(2.5629154477415061787960862961777f));//w78
	b[5]=_mm_mul_ps(b[5], _mm_set1_ps(0.8999762231364157046385095409419f));//w58
	b[6]=_mm_mul_ps(b[6], _mm_set1_ps(0.6013448869350452805437218239092f));//w38
	b[7]=_mm_mul_ps(b[7], _mm_set1_ps(0.5097955791041591689419398039878f));//w18

	a[0]=_mm_add_ps(b[0], b[3]);
	a[1]=_mm_add_ps(b[1], b[2]);
	a[2]=_mm_sub_ps(b[1], b[2]);
	a[3]=_mm_sub_ps(b[0], b[3]);
	a[4]=_mm_sub_ps(b[7], b[4]);
	a[5]=_mm_sub_ps(b[6], b[5]);
	a[6]=_mm_add_ps(b[6], b[5]);
	a[7]=_mm_add_ps(b[7], b[4]);

	a[2]=_mm_mul_ps(a[2], w34);
	a[3]=_mm_mul_ps(a[3], w14);
	a[4]=_mm_mul_ps(a[4], w14);
	a[5]=_mm_mul_ps(a[5], w34);

	b[0]=_mm_add_ps(a[0], a[1]);
	b[1]=_mm_sub_ps(a[0], a[1]);
	b[2]=_mm_sub_ps(a[3], a[2]);
	b[3]=_mm_add_ps(a[3], a[2]);
	b[4]=_mm_add_ps(a[4], a[5]);
	b[5]=_mm_sub_ps(a[4], a[5]);
	b[6]=_mm_sub_ps(a[7], a[6]);
	b[7]=_mm_sub_ps(a[7], a[6]);

	b[3]=_mm_add_ps(_mm_mul_ps(b[3], sqrt2), b[2]);
	b[4]=_mm_add_ps(_mm_mul_ps(b[4], sqrt2), b[5]);

	b[7]=_mm_add_ps(_mm_mul_ps(b[7], sqrt2), b[4]);

	b[4]=_mm_add_ps(b[4], b[6]);

	b[6]=_mm_add_ps(b[6], b[5]);

	_mm_store_ps(data+0*stride, b[0]);
	_mm_store_ps(data+1*stride, b[7]);
	_mm_store_ps(data+2*stride, b[3]);
	_mm_store_ps(data+3*stride, b[4]);
	_mm_store_ps(data+4*stride, b[1]);
	_mm_store_ps(data+5*stride, b[6]);
	_mm_store_ps(data+6*stride, b[2]);
	_mm_store_ps(data+7*stride, b[5]);
#endif
}
AWM_INLINE void dctiii_8(float *data, const int stride)
{
	__m128 a[8], b[8];
	
	//Peo
	a[0]=_mm_load_ps(data+0*stride);
	a[4]=_mm_load_ps(data+1*stride);
	a[1]=_mm_load_ps(data+2*stride);
	a[5]=_mm_load_ps(data+3*stride);
	a[2]=_mm_load_ps(data+4*stride);
	a[6]=_mm_load_ps(data+5*stride);
	a[3]=_mm_load_ps(data+6*stride);
	a[7]=_mm_load_ps(data+7*stride);

	//BcT
	a[7]=_mm_add_ps(a[7], a[6]);
	a[6]=_mm_add_ps(a[6], a[5]);
	a[5]=_mm_add_ps(a[5], a[4]);
	a[4]=_mm_mul_ps(a[4], _mm_set1_ps(1.4142135623730950488016887242097f));
	
	dctiii_4((float*)(a+0*4), sizeof(__m128)/sizeof(float));
	dctiii_4((float*)(a+1*4), sizeof(__m128)/sizeof(float));

	//Wc
	a[4]=_mm_mul_ps(a[4], _mm_set1_ps(0.50979557910415916894193980398784f));//0.5 sec(1 pi/(2*8))
	a[5]=_mm_mul_ps(a[5], _mm_set1_ps(0.60134488693504528054372182390922f));//0.5 sec(3 pi/(2*8))
	a[6]=_mm_mul_ps(a[6], _mm_set1_ps(0.89997622313641570463850954094189f));//0.5 sec(5 pi/(2*8))
	a[7]=_mm_mul_ps(a[7], _mm_set1_ps(2.56291544774150617879608629617770f));//0.5 sec(7 pi/(2*8))

	//HbarT
	b[0]=_mm_add_ps(a[0], a[4]);
	b[1]=_mm_add_ps(a[1], a[5]);
	b[2]=_mm_add_ps(a[2], a[6]);
	b[3]=_mm_add_ps(a[3], a[7]);
	b[4]=_mm_sub_ps(a[3], a[7]);
	b[5]=_mm_sub_ps(a[2], a[6]);
	b[6]=_mm_sub_ps(a[1], a[5]);
	b[7]=_mm_sub_ps(a[0], a[4]);

	_mm_store_ps(data+0*stride, b[0]);
	_mm_store_ps(data+1*stride, b[1]);
	_mm_store_ps(data+2*stride, b[2]);
	_mm_store_ps(data+3*stride, b[3]);
	_mm_store_ps(data+4*stride, b[4]);
	_mm_store_ps(data+5*stride, b[5]);
	_mm_store_ps(data+6*stride, b[6]);
	_mm_store_ps(data+7*stride, b[7]);
#if 0
	__m128 w34=_mm_set1_ps(1.3065629648763765278566431734272f);//Wij = 0.5 sec(i*Pi/(2j))
	__m128 w14=_mm_set1_ps(0.5411961001461969843997232053664f);
	__m128 sqrt2=_mm_set1_ps(1.4142135623730950488016887242097f);

	__m128 a[8], b[8];

	a[0]=_mm_load_ps(data+0*stride);
	a[1]=_mm_load_ps(data+1*stride);
	a[2]=_mm_load_ps(data+2*stride);
	a[3]=_mm_load_ps(data+3*stride);
	a[4]=_mm_load_ps(data+4*stride);
	a[5]=_mm_load_ps(data+5*stride);
	a[6]=_mm_load_ps(data+6*stride);
	a[7]=_mm_load_ps(data+7*stride);

	b[0]=a[0];
	b[1]=_mm_mul_ps(sqrt2, a[1]);
	b[2]=a[2];
	b[3]=_mm_add_ps(a[1], a[3]);
	b[4]=a[4];
	b[5]=_mm_add_ps(a[3], a[5]);
	b[6]=a[6];
	b[7]=_mm_add_ps(a[5], a[7]);

	a[0]=b[0];
	a[1]=b[1];
	a[2]=_mm_mul_ps(sqrt2, b[2]);
	a[3]=_mm_mul_ps(sqrt2, b[3]);
	a[4]=b[4];
	a[5]=b[5];
	a[6]=_mm_add_ps(b[2], b[6]);
	a[7]=_mm_add_ps(b[3], b[7]);

	b[0]=_mm_add_ps(a[0], a[4]);
	b[1]=_mm_add_ps(a[1], a[5]);
	b[2]=_mm_add_ps(a[2], a[6]);
	b[3]=_mm_add_ps(a[3], a[7]);
	b[4]=_mm_sub_ps(a[0], a[4]);
	b[5]=_mm_sub_ps(a[1], a[5]);
	b[6]=_mm_sub_ps(a[2], a[6]);
	b[7]=_mm_sub_ps(a[3], a[7]);

	b[2]=_mm_mul_ps(b[2], w14);
	b[3]=_mm_mul_ps(b[3], w14);
	b[6]=_mm_mul_ps(b[6], w34);
	b[7]=_mm_mul_ps(b[7], w34);

	a[0]=_mm_add_ps(b[0], b[2]);
	a[1]=_mm_add_ps(b[1], b[3]);
	a[2]=_mm_sub_ps(b[0], b[2]);
	a[3]=_mm_sub_ps(b[1], b[3]);
	a[4]=_mm_add_ps(b[4], b[6]);
	a[5]=_mm_add_ps(b[5], b[7]);
	a[6]=_mm_sub_ps(b[4], b[6]);
	a[7]=_mm_sub_ps(b[5], b[7]);

	a[1]=_mm_mul_ps(a[1], _mm_set1_ps(0.5097955791041591689419398039878f));//w18
	a[3]=_mm_mul_ps(a[3], _mm_set1_ps(2.5629154477415061787960862961777f));//w78
	a[5]=_mm_mul_ps(a[5], _mm_set1_ps(0.6013448869350452805437218239092f));//w38
	a[7]=_mm_mul_ps(a[7], _mm_set1_ps(0.8999762231364157046385095409419f));//w58

	b[0]=_mm_add_ps(a[0], a[1]);
	b[1]=_mm_sub_ps(a[0], a[1]);
	b[2]=_mm_add_ps(a[2], a[3]);
	b[3]=_mm_sub_ps(a[2], a[3]);
	b[4]=_mm_add_ps(a[4], a[5]);
	b[5]=_mm_sub_ps(a[4], a[5]);
	b[6]=_mm_add_ps(a[6], a[7]);
	b[7]=_mm_sub_ps(a[6], a[7]);

	_mm_store_ps(data+0*stride, b[0]);
	_mm_store_ps(data+1*stride, b[4]);
	_mm_store_ps(data+2*stride, b[6]);
	_mm_store_ps(data+3*stride, b[2]);
	_mm_store_ps(data+4*stride, b[3]);
	_mm_store_ps(data+5*stride, b[7]);
	_mm_store_ps(data+6*stride, b[5]);
	_mm_store_ps(data+7*stride, b[1]);
#endif
}
AWM_INLINE void dctii_16(float *data, const int stride)
{
	__m128 a[16];

	//Hbar_16
	float *p1=data, *p2=data+15*stride;
	for(int k=0;k<8;++k)
	{
		__m128 t0=_mm_load_ps(p1);
		__m128 t1=_mm_load_ps(p2);
		p1+=stride;
		p2-=stride;
		a[k+0*8]=_mm_add_ps(t0, t1);
		a[k+1*8]=_mm_sub_ps(t0, t1);
	}

	//Wc_16
	a[0x8]=_mm_mul_ps(a[0x8], _mm_set1_ps(0.5024192861881557055116701192801f));//0.5 sec( 1 pi/(2*16))
	a[0x9]=_mm_mul_ps(a[0x9], _mm_set1_ps(0.5224986149396888806285753190567f));//0.5 sec( 3 pi/(2*16))
	a[0xA]=_mm_mul_ps(a[0xA], _mm_set1_ps(0.5669440348163577036805379151549f));//0.5 sec( 5 pi/(2*16))
	a[0xB]=_mm_mul_ps(a[0xB], _mm_set1_ps(0.6468217833599901295483601116520f));//0.5 sec( 7 pi/(2*16))
	a[0xC]=_mm_mul_ps(a[0xC], _mm_set1_ps(0.7881546234512502247339824871974f));//0.5 sec( 9 pi/(2*16))
	a[0xD]=_mm_mul_ps(a[0xD], _mm_set1_ps(1.0606776859903474713404517472331f));//0.5 sec(11 pi/(2*16))
	a[0xE]=_mm_mul_ps(a[0xE], _mm_set1_ps(1.7224470982383339278159153641566f));//0.5 sec(13 pi/(2*16))
	a[0xF]=_mm_mul_ps(a[0xF], _mm_set1_ps(5.1011486186891638581062454923454f));//0.5 sec(15 pi/(2*16))

	dctii_8((float*)(a+0*8), sizeof(__m128)/sizeof(float));
	dctii_8((float*)(a+1*8), sizeof(__m128)/sizeof(float));

	//Bc_16
	a[0x8]=_mm_add_ps(_mm_mul_ps(a[0x8], _mm_set1_ps(1.4142135623730950488016887242097f)), a[0x9]);//sqrt2
	a[0x9]=_mm_add_ps(a[0x9], a[0xA]);
	a[0xA]=_mm_add_ps(a[0xA], a[0xB]);
	a[0xB]=_mm_add_ps(a[0xB], a[0xC]);
	a[0xC]=_mm_add_ps(a[0xC], a[0xD]);
	a[0xD]=_mm_add_ps(a[0xD], a[0xE]);
	a[0xE]=_mm_add_ps(a[0xE], a[0xF]);

	//Peo16T
	for(int k=0;k<8;++k)
		_mm_store_ps(data+(2*k)*stride, a[k]);
	for(int k=0;k<8;++k)
		_mm_store_ps(data+(2*k+1)*stride, a[k+8]);
}
AWM_INLINE void dctiii_16(float *data, const int stride)
{
	__m128 a[16];

	//Peo16
	for(int k=0;k<8;++k)
		a[k]=_mm_load_ps(data+(2*k)*stride);
	for(int k=0;k<8;++k)
		a[k+8]=_mm_load_ps(data+(2*k+1)*stride);

	//Bc_16T
	a[0xF]=_mm_add_ps(a[0xF], a[0xE]);
	a[0xE]=_mm_add_ps(a[0xE], a[0xD]);
	a[0xD]=_mm_add_ps(a[0xD], a[0xC]);
	a[0xC]=_mm_add_ps(a[0xC], a[0xB]);
	a[0xB]=_mm_add_ps(a[0xB], a[0xA]);
	a[0xA]=_mm_add_ps(a[0xA], a[0x9]);
	a[0x9]=_mm_add_ps(a[0x9], a[0x8]);
	a[0x8]=_mm_mul_ps(a[0x8], _mm_set1_ps(1.4142135623730950488016887242097f));

	dctiii_8((float*)(a+0*8), sizeof(__m128)/sizeof(float));
	dctiii_8((float*)(a+1*8), sizeof(__m128)/sizeof(float));

	//Wc_16
	a[0x8]=_mm_mul_ps(a[0x8], _mm_set1_ps(0.5024192861881557055116701192801f));//0.5 sec( 1 pi/(2*16))
	a[0x9]=_mm_mul_ps(a[0x9], _mm_set1_ps(0.5224986149396888806285753190567f));//0.5 sec( 3 pi/(2*16))
	a[0xA]=_mm_mul_ps(a[0xA], _mm_set1_ps(0.5669440348163577036805379151549f));//0.5 sec( 5 pi/(2*16))
	a[0xB]=_mm_mul_ps(a[0xB], _mm_set1_ps(0.6468217833599901295483601116520f));//0.5 sec( 7 pi/(2*16))
	a[0xC]=_mm_mul_ps(a[0xC], _mm_set1_ps(0.7881546234512502247339824871974f));//0.5 sec( 9 pi/(2*16))
	a[0xD]=_mm_mul_ps(a[0xD], _mm_set1_ps(1.0606776859903474713404517472331f));//0.5 sec(11 pi/(2*16))
	a[0xE]=_mm_mul_ps(a[0xE], _mm_set1_ps(1.7224470982383339278159153641566f));//0.5 sec(13 pi/(2*16))
	a[0xF]=_mm_mul_ps(a[0xF], _mm_set1_ps(5.1011486186891638581062454923454f));//0.5 sec(15 pi/(2*16))

	//Hbar16T
	for(int k=0;k<8;++k)
		_mm_store_ps(data+k*stride, _mm_add_ps(a[k], a[k+8]));
	for(int k=0;k<8;++k)
		_mm_store_ps(data+(k+8)*stride, _mm_sub_ps(a[7-k], a[7-k+8]));
}
AWM_INLINE void dctii_32(float *data, const int stride)
{
	__m128 a[32];

	//Hbar_32
	float *p1=data, *p2=data+31*stride;
	for(int k=0;k<16;++k)
	{
		__m128 t0=_mm_load_ps(p1);
		__m128 t1=_mm_load_ps(p2);
		p1+=stride;
		p2-=stride;
		a[k+0*16]=_mm_add_ps(t0, t1);
		a[k+1*16]=_mm_sub_ps(t0, t1);
	}

	//Wc_32
	a[0x10]=_mm_mul_ps(a[0x10], _mm_set1_ps( 0.5006029982351963013455041067664f));//0.5 sec( 1 pi/(2*32))
	a[0x11]=_mm_mul_ps(a[0x11], _mm_set1_ps( 0.5054709598975436599844445856070f));//0.5 sec( 3 pi/(2*32))
	a[0x12]=_mm_mul_ps(a[0x12], _mm_set1_ps( 0.5154473099226245469749513056493f));//0.5 sec( 5 pi/(2*32))
	a[0x13]=_mm_mul_ps(a[0x13], _mm_set1_ps( 0.5310425910897841744757339323572f));//0.5 sec( 7 pi/(2*32))
	a[0x14]=_mm_mul_ps(a[0x14], _mm_set1_ps( 0.5531038960344445278293808381371f));//0.5 sec( 9 pi/(2*32))
	a[0x15]=_mm_mul_ps(a[0x15], _mm_set1_ps( 0.5829349682061338736738307012526f));//0.5 sec(11 pi/(2*32))
	a[0x16]=_mm_mul_ps(a[0x16], _mm_set1_ps( 0.6225041230356648161572561567628f));//0.5 sec(13 pi/(2*32))
	a[0x17]=_mm_mul_ps(a[0x17], _mm_set1_ps( 0.6748083414550057460259687110410f));//0.5 sec(15 pi/(2*32))
	a[0x18]=_mm_mul_ps(a[0x18], _mm_set1_ps( 0.7445362710022984497769811919729f));//0.5 sec(17 pi/(2*32))
	a[0x19]=_mm_mul_ps(a[0x19], _mm_set1_ps( 0.8393496454155270387392637466254f));//0.5 sec(19 pi/(2*32))
	a[0x1A]=_mm_mul_ps(a[0x1A], _mm_set1_ps( 0.9725682378619606936976894140525f));//0.5 sec(21 pi/(2*32))
	a[0x1B]=_mm_mul_ps(a[0x1B], _mm_set1_ps( 1.1694399334328849551557702840422f));//0.5 sec(23 pi/(2*32))
	a[0x1C]=_mm_mul_ps(a[0x1C], _mm_set1_ps( 1.4841646163141662772433269374281f));//0.5 sec(25 pi/(2*32))
	a[0x1D]=_mm_mul_ps(a[0x1D], _mm_set1_ps( 2.0577810099534115508565544797104f));//0.5 sec(27 pi/(2*32))
	a[0x1E]=_mm_mul_ps(a[0x1E], _mm_set1_ps( 3.4076084184687187857011913334591f));//0.5 sec(29 pi/(2*32))
	a[0x1F]=_mm_mul_ps(a[0x1F], _mm_set1_ps(10.1900081235480568112121092010356f));//0.5 sec(31 pi/(2*32))

	dctii_16((float*)(a+0*16), sizeof(__m128)/sizeof(float));
	dctii_16((float*)(a+1*16), sizeof(__m128)/sizeof(float));

	//Bc_16
	a[0x10]=_mm_add_ps(_mm_mul_ps(a[0x10], _mm_set1_ps(1.4142135623730950488016887242097f)), a[0x11]);//sqrt2
	a[0x11]=_mm_add_ps(a[0x11], a[0x12]);
	a[0x12]=_mm_add_ps(a[0x12], a[0x13]);
	a[0x13]=_mm_add_ps(a[0x13], a[0x14]);
	a[0x14]=_mm_add_ps(a[0x14], a[0x15]);
	a[0x15]=_mm_add_ps(a[0x15], a[0x16]);
	a[0x16]=_mm_add_ps(a[0x16], a[0x17]);
	a[0x17]=_mm_add_ps(a[0x17], a[0x18]);
	a[0x18]=_mm_add_ps(a[0x18], a[0x19]);
	a[0x19]=_mm_add_ps(a[0x19], a[0x1A]);
	a[0x1A]=_mm_add_ps(a[0x1A], a[0x1B]);
	a[0x1B]=_mm_add_ps(a[0x1B], a[0x1C]);
	a[0x1C]=_mm_add_ps(a[0x1C], a[0x1D]);
	a[0x1D]=_mm_add_ps(a[0x1D], a[0x1E]);
	a[0x1E]=_mm_add_ps(a[0x1E], a[0x1F]);

	//Peo16T
	for(int k=0;k<16;++k)
		_mm_store_ps(data+(2*k)*stride, a[k]);
	for(int k=0;k<16;++k)
		_mm_store_ps(data+(2*k+1)*stride, a[k+16]);
}
AWM_INLINE void dctiii_32(float *data, const int stride)
{
	__m128 a[32];

	//Peo16
	for(int k=0;k<16;++k)
		a[k]=_mm_load_ps(data+(2*k)*stride);
	for(int k=0;k<16;++k)
		a[k+16]=_mm_load_ps(data+(2*k+1)*stride);

	//Bc_16T
	a[0x1F]=_mm_add_ps(a[0x1F], a[0x1E]);
	a[0x1E]=_mm_add_ps(a[0x1E], a[0x1D]);
	a[0x1D]=_mm_add_ps(a[0x1D], a[0x1C]);
	a[0x1C]=_mm_add_ps(a[0x1C], a[0x1B]);
	a[0x1B]=_mm_add_ps(a[0x1B], a[0x1A]);
	a[0x1A]=_mm_add_ps(a[0x1A], a[0x19]);
	a[0x19]=_mm_add_ps(a[0x19], a[0x18]);
	a[0x18]=_mm_add_ps(a[0x18], a[0x17]);
	a[0x17]=_mm_add_ps(a[0x17], a[0x16]);
	a[0x16]=_mm_add_ps(a[0x16], a[0x15]);
	a[0x15]=_mm_add_ps(a[0x15], a[0x14]);
	a[0x14]=_mm_add_ps(a[0x14], a[0x13]);
	a[0x13]=_mm_add_ps(a[0x13], a[0x12]);
	a[0x12]=_mm_add_ps(a[0x12], a[0x11]);
	a[0x11]=_mm_add_ps(a[0x11], a[0x10]);
	a[0x10]=_mm_mul_ps(a[0x10], _mm_set1_ps(1.4142135623730950488016887242097f));

	dctiii_16((float*)(a+0*16), sizeof(__m128)/sizeof(float));
	dctiii_16((float*)(a+1*16), sizeof(__m128)/sizeof(float));

	//Wc_16
	a[0x10]=_mm_mul_ps(a[0x10], _mm_set1_ps( 0.5006029982351963013455041067664f));//0.5 sec( 1 pi/(2*32))
	a[0x11]=_mm_mul_ps(a[0x11], _mm_set1_ps( 0.5054709598975436599844445856070f));//0.5 sec( 3 pi/(2*32))
	a[0x12]=_mm_mul_ps(a[0x12], _mm_set1_ps( 0.5154473099226245469749513056493f));//0.5 sec( 5 pi/(2*32))
	a[0x13]=_mm_mul_ps(a[0x13], _mm_set1_ps( 0.5310425910897841744757339323572f));//0.5 sec( 7 pi/(2*32))
	a[0x14]=_mm_mul_ps(a[0x14], _mm_set1_ps( 0.5531038960344445278293808381371f));//0.5 sec( 9 pi/(2*32))
	a[0x15]=_mm_mul_ps(a[0x15], _mm_set1_ps( 0.5829349682061338736738307012526f));//0.5 sec(11 pi/(2*32))
	a[0x16]=_mm_mul_ps(a[0x16], _mm_set1_ps( 0.6225041230356648161572561567628f));//0.5 sec(13 pi/(2*32))
	a[0x17]=_mm_mul_ps(a[0x17], _mm_set1_ps( 0.6748083414550057460259687110410f));//0.5 sec(15 pi/(2*32))
	a[0x18]=_mm_mul_ps(a[0x18], _mm_set1_ps( 0.7445362710022984497769811919729f));//0.5 sec(17 pi/(2*32))
	a[0x19]=_mm_mul_ps(a[0x19], _mm_set1_ps( 0.8393496454155270387392637466254f));//0.5 sec(19 pi/(2*32))
	a[0x1A]=_mm_mul_ps(a[0x1A], _mm_set1_ps( 0.9725682378619606936976894140525f));//0.5 sec(21 pi/(2*32))
	a[0x1B]=_mm_mul_ps(a[0x1B], _mm_set1_ps( 1.1694399334328849551557702840422f));//0.5 sec(23 pi/(2*32))
	a[0x1C]=_mm_mul_ps(a[0x1C], _mm_set1_ps( 1.4841646163141662772433269374281f));//0.5 sec(25 pi/(2*32))
	a[0x1D]=_mm_mul_ps(a[0x1D], _mm_set1_ps( 2.0577810099534115508565544797104f));//0.5 sec(27 pi/(2*32))
	a[0x1E]=_mm_mul_ps(a[0x1E], _mm_set1_ps( 3.4076084184687187857011913334591f));//0.5 sec(29 pi/(2*32))
	a[0x1F]=_mm_mul_ps(a[0x1F], _mm_set1_ps(10.1900081235480568112121092010356f));//0.5 sec(31 pi/(2*32))

	//Hbar16T
	for(int k=0;k<16;++k)
		_mm_store_ps(data+k*stride, _mm_add_ps(a[k], a[k+16]));
	for(int k=0;k<16;++k)
		_mm_store_ps(data+(k+16)*stride, _mm_sub_ps(a[15-k], a[15-k+16]));
}

AWM_INLINE void transpose4x4(float *block)
{
	__m128 a[4];
	
	a[0]=_mm_load_ps(block+0*4);
	a[1]=_mm_load_ps(block+1*4);
	a[2]=_mm_load_ps(block+2*4);
	a[3]=_mm_load_ps(block+3*4);
	
	_MM_TRANSPOSE4_PS(a[0], a[1], a[2], a[3]);

	_mm_store_ps(block+0*4, a[0]);
	_mm_store_ps(block+1*4, a[1]);
	_mm_store_ps(block+2*4, a[2]);
	_mm_store_ps(block+3*4, a[3]);
}
AWM_INLINE void transpose8x8(float *block)
{
	__m128 a[4], b[4];

	//	A	B
	//	C	D
	
	//transpose A
	a[0]=_mm_load_ps(block+0*8);
	a[1]=_mm_load_ps(block+1*8);
	a[2]=_mm_load_ps(block+2*8);
	a[3]=_mm_load_ps(block+3*8);
	
	_MM_TRANSPOSE4_PS(a[0], a[1], a[2], a[3]);

	_mm_store_ps(block+0*8, a[0]);
	_mm_store_ps(block+1*8, a[1]);
	_mm_store_ps(block+2*8, a[2]);
	_mm_store_ps(block+3*8, a[3]);

	//transpose B and C
	a[0]=_mm_load_ps(block+0*8+4);//load B
	a[1]=_mm_load_ps(block+1*8+4);
	a[2]=_mm_load_ps(block+2*8+4);
	a[3]=_mm_load_ps(block+3*8+4);
	
	_MM_TRANSPOSE4_PS(a[0], a[1], a[2], a[3]);

	b[0]=_mm_load_ps(block+4*8);//load C
	b[1]=_mm_load_ps(block+5*8);
	b[2]=_mm_load_ps(block+6*8);
	b[3]=_mm_load_ps(block+7*8);
	_mm_store_ps(block+4*8, a[0]);//store C
	_mm_store_ps(block+5*8, a[1]);
	_mm_store_ps(block+6*8, a[2]);
	_mm_store_ps(block+7*8, a[3]);

	_MM_TRANSPOSE4_PS(b[0], b[1], b[2], b[3]);

	_mm_store_ps(block+0*8+4, b[0]);//store B
	_mm_store_ps(block+1*8+4, b[1]);
	_mm_store_ps(block+2*8+4, b[2]);
	_mm_store_ps(block+3*8+4, b[3]);

	//transpose D
	a[0]=_mm_load_ps(block+4*8+4);
	a[1]=_mm_load_ps(block+5*8+4);
	a[2]=_mm_load_ps(block+6*8+4);
	a[3]=_mm_load_ps(block+7*8+4);
	
	_MM_TRANSPOSE4_PS(a[0], a[1], a[2], a[3]);

	_mm_store_ps(block+4*8+4, a[0]);
	_mm_store_ps(block+5*8+4, a[1]);
	_mm_store_ps(block+6*8+4, a[2]);
	_mm_store_ps(block+7*8+4, a[3]);
}
AWM_INLINE void transpose16x16(float *block)
{
	__m128 a[4], b[4];
	
#define TRANSPOSE_DIAG(IDX)\
	do\
	{\
		a[0]=_mm_load_ps(block+(0+4*(IDX))*16+4*(IDX));\
		a[1]=_mm_load_ps(block+(1+4*(IDX))*16+4*(IDX));\
		a[2]=_mm_load_ps(block+(2+4*(IDX))*16+4*(IDX));\
		a[3]=_mm_load_ps(block+(3+4*(IDX))*16+4*(IDX));\
		_MM_TRANSPOSE4_PS(a[0], a[1], a[2], a[3]);\
		_mm_store_ps(block+(0+4*(IDX))*16+4*(IDX), a[0]);\
		_mm_store_ps(block+(1+4*(IDX))*16+4*(IDX), a[1]);\
		_mm_store_ps(block+(2+4*(IDX))*16+4*(IDX), a[2]);\
		_mm_store_ps(block+(3+4*(IDX))*16+4*(IDX), a[3]);\
	}while(0)
#define TRANSPOSE_NOND(Y, X)\
	do\
	{\
		a[0]=_mm_load_ps(block+(0+4*(Y))*16+4*(X));\
		a[1]=_mm_load_ps(block+(1+4*(Y))*16+4*(X));\
		a[2]=_mm_load_ps(block+(2+4*(Y))*16+4*(X));\
		a[3]=_mm_load_ps(block+(3+4*(Y))*16+4*(X));\
		b[0]=_mm_load_ps(block+(0+4*(X))*16+4*(Y));\
		b[1]=_mm_load_ps(block+(1+4*(X))*16+4*(Y));\
		b[2]=_mm_load_ps(block+(2+4*(X))*16+4*(Y));\
		b[3]=_mm_load_ps(block+(3+4*(X))*16+4*(Y));\
		_MM_TRANSPOSE4_PS(a[0], a[1], a[2], a[3]);\
		_MM_TRANSPOSE4_PS(b[0], b[1], b[2], b[3]);\
		_mm_store_ps(block+(0+4*(Y))*16+4*(X), b[0]);\
		_mm_store_ps(block+(1+4*(Y))*16+4*(X), b[1]);\
		_mm_store_ps(block+(2+4*(Y))*16+4*(X), b[2]);\
		_mm_store_ps(block+(3+4*(Y))*16+4*(X), b[3]);\
		_mm_store_ps(block+(0+4*(X))*16+4*(Y), a[0]);\
		_mm_store_ps(block+(1+4*(X))*16+4*(Y), a[1]);\
		_mm_store_ps(block+(2+4*(X))*16+4*(Y), a[2]);\
		_mm_store_ps(block+(3+4*(X))*16+4*(Y), a[3]);\
	}while(0)
	
	//	0	1	2	3
	//	4	5	6	7
	//	8	9	A	B
	//	C	D	E	F
	TRANSPOSE_DIAG(0);
	TRANSPOSE_DIAG(1);
	TRANSPOSE_DIAG(2);
	TRANSPOSE_DIAG(3);
	TRANSPOSE_NOND(0, 1);
	TRANSPOSE_NOND(0, 2);
	TRANSPOSE_NOND(0, 3);
	TRANSPOSE_NOND(1, 2);
	TRANSPOSE_NOND(1, 3);
	TRANSPOSE_NOND(2, 3);

#undef  TRANSPOSE_DIAG
#undef  TRANSPOSE_NOND
}
AWM_INLINE void transpose32x32(float *block)
{
	__m128 a[4], b[4];
	
#define TRANSPOSE_DIAG(IDX)\
	do\
	{\
		a[0]=_mm_load_ps(block+(0+4*(IDX))*32+4*(IDX));\
		a[1]=_mm_load_ps(block+(1+4*(IDX))*32+4*(IDX));\
		a[2]=_mm_load_ps(block+(2+4*(IDX))*32+4*(IDX));\
		a[3]=_mm_load_ps(block+(3+4*(IDX))*32+4*(IDX));\
		_MM_TRANSPOSE4_PS(a[0], a[1], a[2], a[3]);\
		_mm_store_ps(block+(0+4*(IDX))*32+4*(IDX), a[0]);\
		_mm_store_ps(block+(1+4*(IDX))*32+4*(IDX), a[1]);\
		_mm_store_ps(block+(2+4*(IDX))*32+4*(IDX), a[2]);\
		_mm_store_ps(block+(3+4*(IDX))*32+4*(IDX), a[3]);\
	}while(0)
#define TRANSPOSE_NOND(Y, X)\
	do\
	{\
		a[0]=_mm_load_ps(block+(0+4*(Y))*32+4*(X));\
		a[1]=_mm_load_ps(block+(1+4*(Y))*32+4*(X));\
		a[2]=_mm_load_ps(block+(2+4*(Y))*32+4*(X));\
		a[3]=_mm_load_ps(block+(3+4*(Y))*32+4*(X));\
		b[0]=_mm_load_ps(block+(0+4*(X))*32+4*(Y));\
		b[1]=_mm_load_ps(block+(1+4*(X))*32+4*(Y));\
		b[2]=_mm_load_ps(block+(2+4*(X))*32+4*(Y));\
		b[3]=_mm_load_ps(block+(3+4*(X))*32+4*(Y));\
		_MM_TRANSPOSE4_PS(a[0], a[1], a[2], a[3]);\
		_MM_TRANSPOSE4_PS(b[0], b[1], b[2], b[3]);\
		_mm_store_ps(block+(0+4*(Y))*32+4*(X), b[0]);\
		_mm_store_ps(block+(1+4*(Y))*32+4*(X), b[1]);\
		_mm_store_ps(block+(2+4*(Y))*32+4*(X), b[2]);\
		_mm_store_ps(block+(3+4*(Y))*32+4*(X), b[3]);\
		_mm_store_ps(block+(0+4*(X))*32+4*(Y), a[0]);\
		_mm_store_ps(block+(1+4*(X))*32+4*(Y), a[1]);\
		_mm_store_ps(block+(2+4*(X))*32+4*(Y), a[2]);\
		_mm_store_ps(block+(3+4*(X))*32+4*(Y), a[3]);\
	}while(0)
	
	//	00	01	02	03	04	05	06	07
	//	08	09	0A	0B	0C	0D	0E	0F
	//	10	11	12	13	14	15	16	17
	//	18	19	1A	1B	1C	1D	1E	1F
	//	20	21	22	23	24	25	26	27
	//	28	29	2A	2B	2C	2D	2E	2F
	//	30	31	32	33	34	35	36	37
	//	38	39	3A	3B	3C	3D	3E	3F
	TRANSPOSE_DIAG(0);
	TRANSPOSE_DIAG(1);
	TRANSPOSE_DIAG(2);
	TRANSPOSE_DIAG(3);
	TRANSPOSE_DIAG(4);
	TRANSPOSE_DIAG(5);
	TRANSPOSE_DIAG(6);
	TRANSPOSE_DIAG(7);
	TRANSPOSE_NOND(0, 1);
	TRANSPOSE_NOND(0, 2);
	TRANSPOSE_NOND(0, 3);
	TRANSPOSE_NOND(0, 4);
	TRANSPOSE_NOND(0, 5);
	TRANSPOSE_NOND(0, 6);
	TRANSPOSE_NOND(0, 7);

	TRANSPOSE_NOND(1, 2);
	TRANSPOSE_NOND(1, 3);
	TRANSPOSE_NOND(1, 4);
	TRANSPOSE_NOND(1, 5);
	TRANSPOSE_NOND(1, 6);
	TRANSPOSE_NOND(1, 7);

	TRANSPOSE_NOND(2, 3);
	TRANSPOSE_NOND(2, 4);
	TRANSPOSE_NOND(2, 5);
	TRANSPOSE_NOND(2, 6);
	TRANSPOSE_NOND(2, 7);

	TRANSPOSE_NOND(3, 4);
	TRANSPOSE_NOND(3, 5);
	TRANSPOSE_NOND(3, 6);
	TRANSPOSE_NOND(3, 7);

	TRANSPOSE_NOND(4, 5);
	TRANSPOSE_NOND(4, 6);
	TRANSPOSE_NOND(4, 7);

	TRANSPOSE_NOND(5, 6);
	TRANSPOSE_NOND(5, 7);

	TRANSPOSE_NOND(6, 7);

#undef  TRANSPOSE_DIAG
#undef  TRANSPOSE_NOND
}
AWM_INLINE void gain(float *block, const float *g)
{
	__m128 a[4];

	a[0]=_mm_load_ps(block+0*4);
	a[1]=_mm_load_ps(block+1*4);
	a[2]=_mm_load_ps(block+2*4);
	a[3]=_mm_load_ps(block+3*4);

	a[0]=_mm_mul_ps(a[0], _mm_load_ps(g+0*4));
	a[1]=_mm_mul_ps(a[1], _mm_load_ps(g+1*4));
	a[2]=_mm_mul_ps(a[2], _mm_load_ps(g+2*4));
	a[3]=_mm_mul_ps(a[3], _mm_load_ps(g+3*4));

	_mm_store_ps(block+0*4, a[0]);
	_mm_store_ps(block+1*4, a[1]);
	_mm_store_ps(block+2*4, a[2]);
	_mm_store_ps(block+3*4, a[3]);
}

#if 0
AWM_INLINE void dc_predict(int16_t **rows, int32_t *weights, int32_t *estim, int32_t *ret_p1, int32_t *ret_pred, int32_t *ret_ctx)
{
	int
		NNN	=rows[3][0+0*NCH*NROWS*NVAL],
		NN	=rows[2][0+0*NCH*NROWS*NVAL],
		NNE	=rows[2][0+1*NCH*NROWS*NVAL],
		NW	=rows[1][0-1*NCH*NROWS*NVAL],
		N	=rows[1][0+0*NCH*NROWS*NVAL],
		NE	=rows[1][0+1*NCH*NROWS*NVAL],
		NEE	=rows[1][0+2*NCH*NROWS*NVAL],
		NEEE	=rows[1][0+3*NCH*NROWS*NVAL],
		NEEEE	=rows[1][0+4*NCH*NROWS*NVAL],
		WWWW	=rows[0][0-4*NCH*NROWS*NVAL],
		WWW	=rows[0][0-3*NCH*NROWS*NVAL],
		WW	=rows[0][0-2*NCH*NROWS*NVAL],
		W	=rows[0][0-1*NCH*NROWS*NVAL],
		eW	=rows[0][1-1*NCH*NROWS*NVAL];
	int ctx=FLOOR_LOG2(eW*eW+1);
	int pred=1<<SHIFT>>1, j=0, p1;
	int vmax=N, vmin=W;

	if(ctx>NCTX_DC-1)
		ctx=NCTX_DC-1;
	if(N<W)vmin=N, vmax=W;
#ifdef USE_L1
	if(vmin>NE)vmin=NE;
	if(vmax<NE)vmax=NE;
	if(vmin>NEEE)vmin=NEEE;
	if(vmax<NEEE)vmax=NEEE;
#define PRED(E) estim[j]=E; pred+=weights[j]*estim[j]; ++j;
	j=0;
	PREDLIST
#undef  PRED
	pred>>=SHIFT;
	p1=pred;
#else
	pred=N=W-NW;
#endif
	CLAMP2(pred, vmin, vmax);
	*ret_p1=p1;
	*ret_pred=pred;
	*ret_ctx=ctx;
}
AWM_INLINE void dc_update(int16_t **rows, int32_t *weights, int32_t *estim, int32_t p1, int32_t curr, int32_t error)
{
	int
		eNEEE	=rows[1][1+3*NCH*NROWS*NVAL],
		eW	=rows[0][1-1*NCH*NROWS*NVAL];
#ifdef USE_L1
	int e=(curr>p1)-(curr<p1), j=0;
#define PRED(...) weights[j]+=e*estim[j]; ++j;
	j=0;
	PREDLIST
#undef  PRED
#endif
	rows[0][1]=(2*eW+((error<<1^error>>31)<<GRBITS)+eNEEE)>>2;
}
#endif


#if 0
#define TEST3
static uint32_t stream[256], symbuf[256];
static void test3()
{
	int testsize=1000, declag=128;
	int bumpidx=64;

	uint64_t dlow=0, drange=0xFFFFFFFFFFFF, dcode=0;
	uint64_t elow=0, erange=0xFFFFFFFFFFFF;
	int estreamidx=0, eidx=0;
	int dstreamidx=0, didx=0;
	int freq=0, cdf=0;

	for(int k=0;k<testsize+declag;++k)
	{
		if(k==declag)
		{
			dcode=0;
			dcode=dcode<<32|stream[dstreamidx];
			dstreamidx=(dstreamidx+1)&((int)_countof(stream)-1);
			dcode=dcode<<32|stream[dstreamidx];
			dstreamidx=(dstreamidx+1)&((int)_countof(stream)-1);
			printf(" dec load %016llX", dcode);
		}
		if(k>=declag)
		{
			if(drange<=0xFFFF)
			{
				printf(" dec renorm %08X", (int)(dlow>>32));
				dcode=dcode<<32|stream[dstreamidx];
				dstreamidx=(dstreamidx+1)&((int)_countof(stream)-1);
				dlow<<=32;
				drange=drange<<32|0xFFFFFFFF;
				if(drange>~dlow)
					drange=~dlow;
			}
			int sym=(int)(((dcode-dlow)*16+15)/drange);
			sym=sym>=8;
			printf(" dec [%d] %d", didx, sym);
			if(sym!=symbuf[didx])
				CRASH("ERROR");

			cdf=0;
			freq=8;
			if(sym)
			{
				cdf=8;
				freq=1;
			}
			valfifo_check(freq<<16|cdf);
			dlow+=drange*cdf>>4;
			drange=(drange*freq>>4)-1;

			didx=(didx+1)&((int)_countof(symbuf)-1);
		}
		if(k<testsize)
		{
			if(erange<=0xFFFF)
			{
				printf(" enc renorm %08X", (int)(elow>>32));
				stream[estreamidx]=(uint32_t)(elow>>32);
				estreamidx=(estreamidx+1)&((int)_countof(stream)-1);
				elow<<=32;
				erange=erange<<32|0xFFFFFFFF;
				if(erange>~elow)
					erange=~elow;
			}
			cdf=0;
			freq=8;
			int sym=k==bumpidx;
			if(sym)
			{
				cdf=8;
				freq=1;
			}
			printf(" enc [%d] %d", eidx, sym);
			valfifo_enqueue(freq<<16|cdf);
			elow+=erange*cdf>>4;
			erange=(erange*freq>>4)-1;

			symbuf[eidx]=sym;
			eidx=(eidx+1)&((int)_countof(symbuf)-1);
		}
		if(k==testsize)
		{
			printf(" enc flush %08X", (int)(elow>>32));
			printf(" enc flush %08X", (int)(elow));
			stream[estreamidx]=(uint32_t)(elow>>32);
			estreamidx=(estreamidx+1)&((int)_countof(stream)-1);
			elow<<=32;
			stream[estreamidx]=(uint32_t)(elow>>32);
			estreamidx=(estreamidx+1)&((int)_countof(stream)-1);
			elow<<=32;
		}
		printf("\n");
	}
	printf("SUCCESS\n");
	exit(0);
}
#endif
#if 0
#include"util.h"
#define TEST2
enum
{
	TESTSIZE=32,
};
static const char *g_paths[]=
{
	"C:/Projects/datasets/dataset-LPCB-ppm",
	"C:/Projects/datasets/dataset-DIV2K-ppm",
	"C:/Projects/datasets/dataset-CLIC303-ppm",
	"C:/Projects/datasets/dataset-GDCC2020-ppm",

//	"C:/Projects/datasets/dataset-kodak-ppm",
};
static const char *ext[]={"ppm"};
ALIGN(32) static float testblocks[3][TESTSIZE*TESTSIZE];
static int64_t blockcount=0;
static double SADmean[3]={0}, thresholds[3][3];
static double DCT4mean[3][4*4], DCT8mean[3][8*8], DCT16mean[3][16*16], DCT32mean[3][32*32];
static int qmatrix4[3][4*4], qmatrix8[3][8*8], qmatrix16[3][16*16], qmatrix32[3][32*32];
static void calc_sad(double *sad)
{
	sad[0]=0;
	sad[1]=0;
	sad[2]=0;
	for(int ky=0;ky<TESTSIZE;++ky)
	{
		for(int kx=1;kx<TESTSIZE;++kx)
		{
			sad[0]+=fabsf(testblocks[0][TESTSIZE*ky+kx]-testblocks[0][TESTSIZE*ky+kx-1]);
			sad[1]+=fabsf(testblocks[1][TESTSIZE*ky+kx]-testblocks[1][TESTSIZE*ky+kx-1]);
			sad[2]+=fabsf(testblocks[2][TESTSIZE*ky+kx]-testblocks[2][TESTSIZE*ky+kx-1]);
		}
	}
	for(int ky=1;ky<TESTSIZE;++ky)
	{
		for(int kx=0;kx<TESTSIZE;++kx)
		{
			sad[0]+=fabsf(testblocks[0][TESTSIZE*ky+kx]-testblocks[0][TESTSIZE*(ky-1)+kx]);
			sad[1]+=fabsf(testblocks[1][TESTSIZE*ky+kx]-testblocks[1][TESTSIZE*(ky-1)+kx]);
			sad[2]+=fabsf(testblocks[2][TESTSIZE*ky+kx]-testblocks[2][TESTSIZE*(ky-1)+kx]);
		}
	}
	sad[0]*=1./(2*TESTSIZE*(TESTSIZE-1));
	sad[1]*=1./(2*TESTSIZE*(TESTSIZE-1));
	sad[2]*=1./(2*TESTSIZE*(TESTSIZE-1));
}
static int classify_dct(double sad, int kc)
{
	int flag=DCTsize32;
	if(sad>thresholds[kc][0])flag=DCTsize16;
	if(sad>thresholds[kc][1])flag=DCTsize8;
	if(sad>thresholds[kc][2])flag=DCTsize4;
	return flag;
}
static void test_SADmean(void)
{
	double sad[3]={0};
	calc_sad(sad);
	SADmean[0]+=sad[0];
	SADmean[1]+=sad[1];
	SADmean[2]+=sad[2];
}
#if 0
static void test_SADsdev(void)
{
	double sad[3]={0};
	calc_sad(sad);
	double x=0;
	x=sad[0]-SADmean[0], SADsdev[0]+=x*x;
	x=sad[1]-SADmean[1], SADsdev[1]+=x*x;
	x=sad[2]-SADmean[2], SADsdev[2]+=x*x;
}
#endif
static void test_DCTmean(void)
{
	double sad[3]={0};
	calc_sad(sad);

	//DCT flag	0	1	2	3
	//DCT size	32	16	8	4
	int dctflag[3]={0};
	for(int kc=0;kc<3;++kc)
	{
		dctflag[kc]=classify_dct(sad[kc], kc);
		switch(dctflag[kc])
		{
		case DCTsize32:
			for(int k=0;k<32/4;++k)
				dctii_32(testblocks[kc]+4*k, 32);
			transpose32x32(testblocks[kc]);
			for(int k=0;k<32/4;++k)
				dctii_32(testblocks[kc]+4*k, 32);

			for(int k=0;k<32*32;++k)
				DCT32mean[kc][k]+=fabs(testblocks[kc][k]);
			break;
		case DCTsize16:
			for(int by=0;by<32/16;++by)
			{
				for(int bx=0;bx<32/16;++bx)
				{
					float *block=testblocks[kc]+16*(32*by+bx);
					for(int k=0;k<16/4;++k)
						dctii_16(block+4*k, 32);
				}
			}
			transpose32x32(testblocks[kc]);
			for(int by=0;by<32/16;++by)
			{
				for(int bx=0;bx<32/16;++bx)
				{
					float *block=testblocks[kc]+16*(32*by+bx);
					for(int k=0;k<16/4;++k)
						dctii_16(block+4*k, 32);

					for(int ky=0;ky<16;++ky)
					{
						for(int kx=0;kx<16;++kx)
							DCT16mean[kc][16*ky+kx]+=fabs(block[32*ky+kx]);
					}
				}
			}
			break;
		case DCTsize8:
			for(int by=0;by<32/8;++by)
			{
				for(int bx=0;bx<32/8;++bx)
				{
					float *block=testblocks[kc]+8*(32*by+bx);
					for(int k=0;k<8/4;++k)
						dctii_8(block+4*k, 32);
				}
			}
			transpose32x32(testblocks[kc]);
			for(int by=0;by<32/8;++by)
			{
				for(int bx=0;bx<32/8;++bx)
				{
					float *block=testblocks[kc]+8*(32*by+bx);
					for(int k=0;k<8/4;++k)
						dctii_8(block+4*k, 32);

					for(int ky=0;ky<8;++ky)
					{
						for(int kx=0;kx<8;++kx)
							DCT8mean[kc][8*ky+kx]+=fabs(block[32*ky+kx]);
					}
				}
			}
			break;
		case DCTsize4:
			for(int by=0;by<32/4;++by)
			{
				for(int bx=0;bx<32/4;++bx)
				{
					float *block=testblocks[kc]+4*(32*by+bx);
					for(int k=0;k<4/4;++k)
						dctii_4(block+4*k, 32);
				}
			}
			transpose32x32(testblocks[kc]);
			for(int by=0;by<32/4;++by)
			{
				for(int bx=0;bx<32/4;++bx)
				{
					float *block=testblocks[kc]+4*(32*by+bx);
					for(int k=0;k<4/4;++k)
						dctii_4(block+4*k, 32);

					for(int ky=0;ky<4;++ky)
					{
						for(int kx=0;kx<4;++kx)
							DCT4mean[kc][4*ky+kx]+=fabs(block[32*ky+kx]);
					}
				}
			}
			break;
		}
	}
}
static uint8_t* load_ppm(const char *fn, int *ret_iw, int *ret_ih)
{
	int iw=0, ih=0, c=0;
	FILE *fsrc=0;

	fsrc=fopen(fn, "rb");
	if(!fsrc)
	{
		CRASH("Cannot open \"%s\"", fn);
		return 0;
	}
	fread(&c, 1, 3, fsrc);
	if(c!=('P'|'6'<<8|'\n'<<16))
	{
		CRASH("Unsupported PPM \"%s\"", fn);
		return 0;
	}
	c=fgetc(fsrc);
	while(c=='#')
	{
		c=fgetc(fsrc);
		while(c!='\n')
			c=fgetc(fsrc);
		c=fgetc(fsrc);
	}
	iw=0;
	while((uint32_t)(c-'0')<10)
	{
		iw=10*iw+c-'0';
		c=fgetc(fsrc);
	}
	while(c<=' ')
		c=fgetc(fsrc);
	ih=0;
	while((uint32_t)(c-'0')<10)
	{
		ih=10*ih+c-'0';
		c=fgetc(fsrc);
	}
	while(c<=' ')
		c=fgetc(fsrc);
	while(c=='#')
	{
		c=fgetc(fsrc);
		while(c!='\n')
			c=fgetc(fsrc);
		c=fgetc(fsrc);
	}
	c=c<<8|fgetc(fsrc);
	c=c<<8|fgetc(fsrc);
	c=c<<8|fgetc(fsrc);
	if(c!=('2'<<24|'5'<<16|'5'<<8|'\n')||iw<1||ih<1)
	{
		CRASH("Unsupported PPM \"%s\"", fn);
		return 0;
	}
	ptrdiff_t size=(ptrdiff_t)3*iw*ih;
	unsigned char *image=(unsigned char*)malloc(size+sizeof(__m256i));
	fread(image, 1, size, fsrc);//read image
	fclose(fsrc);
	if(ret_iw)*ret_iw=iw;
	if(ret_ih)*ret_ih=ih;
	return image;
}
static void block_loop(ArrayHandle filenames, void (*test)(void), const char *label)
{
	blockcount=0;
	for(int k=0;k<(int)filenames->count;++k)
	{
		int iw=0, ih=0;
		ArrayHandle *fn=(ArrayHandle*)array_at(&filenames, k);
		uint8_t *image=load_ppm((char*)fn[0]->data, &iw, &ih);
		if(!image)
		{
			CRASH("");
			return;
		}
		if(label)
			printf("%s %5d/%5d\r"
				, label
				, k+1
				, (int)filenames->count
			);
		for(int ky=0;ky<ih-(TESTSIZE-1);ky+=TESTSIZE)
		{
			for(int kx=0;kx<iw-(TESTSIZE-1);kx+=TESTSIZE)
			{
				for(int ky2=0;ky2<TESTSIZE;++ky2)
				{
					uint8_t *ptr=image+3*(iw*(ky+ky2)+kx);
					for(int kx2=0;kx2<TESTSIZE;++kx2, ptr+=3)
					{
						((int*)testblocks[0])[TESTSIZE*ky2+kx2]=ptr[0];
						((int*)testblocks[1])[TESTSIZE*ky2+kx2]=ptr[1];
						((int*)testblocks[2])[TESTSIZE*ky2+kx2]=ptr[2];
					}
				}
				for(int kc=0;kc<3;++kc)
				{
					for(int k=0;k<TESTSIZE*TESTSIZE/16;++k)
						cvti2f(((float*)testblocks[kc])+16*k);
				}
				for(int k=0;k<TESTSIZE*TESTSIZE/16;++k)
					rgb2yuv(
						((float*)testblocks[0])+16*k,
						((float*)testblocks[1])+16*k,
						((float*)testblocks[2])+16*k
					);
				test();
				++blockcount;
			}
		}
		free(image);
	}
	if(label)
		printf("\n");
}
static void print_qmatrix(double *mean, int *qmatrix, int size)
{
	for(int ky=0;ky<size;++ky)
	{
		for(int kx=0;kx<size;++kx)
		{
			printf(" %12.3lff,", mean[size*ky+kx]);
			//qmatrix[size*ky+kx]=(int)CVTFP64_I64(ceil(mean[size*ky+kx]));
			//printf("%10d", qmatrix[size*ky+kx]);
		}
		printf("\n");
	}
	printf("\n");
}
static void test2()
{
	ArrayHandle filenames=0;
	for(int k=0;k<(int)_countof(g_paths);++k)
	{
		ArrayHandle fns=get_filenames(g_paths[k], (char**)ext, _countof(ext), 1);
		if(!fns)
		{
			CRASH("");
			return;
		}
		array_append(&filenames, fns->data, fns->esize, fns->count, 1, 0, free_str);
		free(fns);//shallow free
	}
	if(!filenames||!filenames->count)
	{
		CRASH("");
		return;
	}
	printf("Found %d images\n", (int)filenames->count);

	memset(SADmean, 0, sizeof(SADmean));
	block_loop(filenames, test_SADmean, "SAD mean");
	SADmean[0]/=(double)blockcount;
	SADmean[1]/=(double)blockcount;
	SADmean[2]/=(double)blockcount;
	printf("SAD mean  %12.6lf %12.6lf %12.6lf\n"
		, SADmean[0]
		, SADmean[1]
		, SADmean[2]
	);

#if 0
	block_loop(filenames, test_SADsdev, "SAD sdev");
	SADsdev[0]/=(double)blockcount;
	SADsdev[1]/=(double)blockcount;
	SADsdev[2]/=(double)blockcount;
	SADsdev[0]=sqrt(SADsdev[0]);
	SADsdev[1]=sqrt(SADsdev[1]);
	SADsdev[2]=sqrt(SADsdev[2]);
	printf("SAD sdev  %12.6lf %12.6lf %12.6lf\n"
		, SADsdev[0]
		, SADsdev[1]
		, SADsdev[2]
	);
#endif

	printf("Thresholds:\n");
	for(int kc=0;kc<3;++kc)
	{
		thresholds[kc][0]=SADmean[kc]/16;
		thresholds[kc][1]=SADmean[kc]/4;
		thresholds[kc][2]=SADmean[kc]/2;
		//thresholds[kc][0]=SADmean[kc]*0.5;
		//thresholds[kc][1]=SADmean[kc];
		//thresholds[kc][2]=SADmean[kc]*2;
		//thresholds[kc][0]=SADmean[kc]-SADsdev[kc];
		//thresholds[kc][1]=SADmean[kc];
		//thresholds[kc][2]=SADmean[kc]+SADsdev[kc];

		printf("%c  %12.6lf %12.6lf %12.6lf\n"
			, "YUV"[kc]
			, thresholds[kc][0]
			, thresholds[kc][1]
			, thresholds[kc][2]
		);
	}
	
	block_loop(filenames, test_DCTmean, "DCT mean");
	for(int kc=0;kc<3;++kc)
	{
		for(int k=0;k<32*32;++k)
			DCT32mean[kc][k]/=(double)blockcount;
		for(int k=0;k<16*16;++k)
			DCT16mean[kc][k]/=(32./16)*(32./16)*blockcount;
		for(int k=0;k<8*8;++k)
			DCT8mean[kc][k]/=(32./8)*(32./8)*blockcount;
		for(int k=0;k<4*4;++k)
			DCT4mean[kc][k]/=(32./4)*(32./4)*blockcount;
	}
	for(int kc=0;kc<3;++kc)
		print_qmatrix(DCT32mean[kc], qmatrix32[kc], 32);
	for(int kc=0;kc<3;++kc)
		print_qmatrix(DCT16mean[kc], qmatrix16[kc], 16);
	for(int kc=0;kc<3;++kc)
		print_qmatrix(DCT8mean[kc], qmatrix8[kc], 8);
	for(int kc=0;kc<3;++kc)
		print_qmatrix(DCT4mean[kc], qmatrix4[kc], 4);

	exit(0);
}
#endif
#if 0
#define TEST
ALIGN(32) static float testb0[32*32], testb1[32*32], testb2[32*32], testb3[32*32], testb4[32*32];
static void print_data(const float *data, int cx, int cy, const char *label)
{
	if(label)
		printf("%s\n", label);
	for(int ky=0;ky<cy;++ky)
	{
		for(int kx=0;kx<cx;++kx)
			printf("%12.2f", data[cx*ky+kx]);
		printf("\n");
	}
	printf("\n");
}
static void dcttest()
{
	//32
#if 1
	enum
	{
		SIZE=32,
	};
	//for(int ky=0;ky<SIZE;++ky)
	//	for(int kx=0;kx<SIZE;++kx)
	//		testb1[ky*SIZE+kx]=cosf(M_PI/SIZE*kx)*cosf(M_PI/SIZE*ky)+1;
	for(int k=0;k<32*32;++k)
		testb1[k]=(float)k;
	//	//testb1[k]=(float)rand();

	memcpy(testb0, testb1, sizeof(testb0));
	memcpy(testb2, testb1, sizeof(testb2));

	print_data(testb1, SIZE, SIZE, "Original data");

	for(int kl=0;kl<SIZE;++kl)
	{
		for(int kd=0;kd<SIZE;++kd)
		{
			float x=0;
			for(int ks=0;ks<SIZE;++ks)
				x+=(float)cos(M_PI/SIZE*(ks+0.5f)*kd)*testb1[SIZE*ks+kl];
			testb3[SIZE*kd+kl]=x;
		}
	}
	print_data(testb3, SIZE, SIZE, "Wikipedia DCTII 1D");

	for(int kl=0;kl<SIZE;++kl)
	{
		for(int kd=0;kd<SIZE;++kd)
		{
			float x=testb3[SIZE*0+kl]/2;
			for(int ks=1;ks<SIZE;++ks)
				x+=(float)cos(M_PI/SIZE*(kd+0.5f)*ks)*testb3[SIZE*ks+kl];
			testb4[SIZE*kd+kl]=x;
		}
	}
	print_data(testb4, SIZE, SIZE, "Wikipedia DCTIII 1D");

	for(int k=0;k<SIZE/4;++k)
		dctii_32(testb1+k*4, SIZE);
	transpose32x32(testb1);
	for(int k=0;k<SIZE/4;++k)
		dctii_32(testb1+k*4, SIZE);
	print_data(testb1, SIZE, SIZE, "Perera DCT");
	
	for(int k=0;k<SIZE/4;++k)
		dctiii_32(testb1+k*4, SIZE);
	transpose32x32(testb1);
	for(int k=0;k<SIZE/4;++k)
		dctiii_32(testb1+k*4, SIZE);
	print_data(testb1, SIZE, SIZE, "Recovered");
	
	for(int k=0;k<SIZE*SIZE;++k)
	{
		if(fabsf(testb1[k]/(SIZE*SIZE)-testb0[k])>1e-2)
			CRASH("ERROR");
	}
#endif

	//16
#if 0
	enum
	{
		SIZE=16,
	};
	for(int k=0;k<32*32;++k)
		testb1[k]=(float)k;
		//testb1[k]=(float)rand();

	memcpy(testb0, testb1, sizeof(testb0));
	memcpy(testb2, testb1, sizeof(testb2));

	print_data(testb1, SIZE, SIZE, "Original data");

	for(int kl=0;kl<SIZE;++kl)
	{
		for(int kd=0;kd<SIZE;++kd)
		{
			float x=0;
			for(int ks=0;ks<SIZE;++ks)
				x+=(float)cos(M_PI/SIZE*(ks+0.5f)*kd)*testb1[SIZE*ks+kl];
			testb3[SIZE*kd+kl]=x;
		}
	}
	print_data(testb3, SIZE, SIZE, "Wikipedia DCTII");

	for(int kl=0;kl<SIZE;++kl)
	{
		for(int kd=0;kd<SIZE;++kd)
		{
			float x=testb3[SIZE*0+kl]/2;
			for(int ks=1;ks<SIZE;++ks)
				x+=(float)cos(M_PI/SIZE*(kd+0.5f)*ks)*testb3[SIZE*ks+kl];
			testb4[SIZE*kd+kl]=x;
		}
	}
	print_data(testb4, SIZE, SIZE, "Wikipedia DCTIII");

	for(int k=0;k<SIZE/4;++k)
		dctii_16(testb1+k*4, SIZE);
	transpose16x16(testb1);
	for(int k=0;k<SIZE/4;++k)
		dctii_16(testb1+k*4, SIZE);
	print_data(testb1, SIZE, SIZE, "Perera DCT");
	
	for(int k=0;k<SIZE/4;++k)
		dctiii_16(testb1+k*4, SIZE);
	transpose16x16(testb1);
	for(int k=0;k<SIZE/4;++k)
		dctiii_16(testb1+k*4, SIZE);
	print_data(testb1, SIZE, SIZE, "Recovered");
	
	for(int k=0;k<SIZE*SIZE;++k)
	{
		if(fabsf(testb1[k]/(SIZE*SIZE)-testb0[k])>1e-2)
			CRASH("ERROR");
	}
#endif

	//8
#if 0
	enum
	{
		SIZE=8,
	};
	for(int k=0;k<32*32;++k)
		testb1[k]=(float)k;
		//testb1[k]=(float)rand();

	memcpy(testb0, testb1, sizeof(testb0));
	memcpy(testb2, testb1, sizeof(testb2));

	print_data(testb1, SIZE, SIZE, "Original data");

	for(int kl=0;kl<SIZE;++kl)
	{
		for(int kd=0;kd<SIZE;++kd)
		{
			float x=0;
			for(int ks=0;ks<SIZE;++ks)
				x+=(float)cos(M_PI/SIZE*(ks+0.5f)*kd)*testb1[SIZE*ks+kl];
			testb3[SIZE*kd+kl]=x;
		}
	}
	print_data(testb3, SIZE, SIZE, "Wikipedia DCTII");

	for(int kl=0;kl<SIZE;++kl)
	{
		for(int kd=0;kd<SIZE;++kd)
		{
			float x=testb3[SIZE*0+kl]/2;
			for(int ks=1;ks<SIZE;++ks)
				x+=(float)cos(M_PI/SIZE*(kd+0.5f)*ks)*testb3[SIZE*ks+kl];
			testb4[SIZE*kd+kl]=x;
		}
	}
	print_data(testb4, SIZE, SIZE, "Wikipedia DCTIII");
	
	dct8y8_fwd(testb2);
	transpose8x8(testb2);
	dct8y8_fwd(testb2);
	print_data(testb2, SIZE, SIZE, "ChatGPT DCT");

	dctii_8(testb1, SIZE);
	dctii_8(testb1+4, SIZE);
	transpose8x8(testb1);
	dctii_8(testb1, SIZE);
	dctii_8(testb1+4, SIZE);
	print_data(testb1, SIZE, SIZE, "Perera DCT");
	
	dctiii_8(testb1, SIZE);
	dctiii_8(testb1+4, SIZE);
	transpose8x8(testb1);
	dctiii_8(testb1, SIZE);
	dctiii_8(testb1+4, SIZE);
	print_data(testb1, SIZE, SIZE, "Recovered");
	
	for(int k=0;k<SIZE*SIZE;++k)
	{
		if(fabsf(testb1[k]/(SIZE*SIZE)-testb0[k])>1e-2)
			CRASH("ERROR");
	}
#endif

	//4
#if 0
	for(int k=0;k<32*32;++k)
		testb1[k]=(float)k;
		//testb1[k]=(float)rand();

	memcpy(testb0, testb1, sizeof(testb0));
	memcpy(testb2, testb1, sizeof(testb2));

	print_data(testb1, 4, 4, "Original data");

	for(int kl=0;kl<4;++kl)
	{
		for(int kd=0;kd<4;++kd)
		{
			float x=0;
			for(int ks=0;ks<4;++ks)
				x+=cos(M_PI/4*(ks+0.5f)*kd)*testb1[4*ks+kl];
			testb3[4*kd+kl]=x;
		}
	}
	print_data(testb3, 4, 4, "Wikipedia DCT");

	dct4y4_fwd(testb2);
	transpose4x4(testb2);
	dct4y4_fwd(testb2);
	print_data(testb2, 4, 4, "ChatGPT DCT");
	
	dctii_4(testb1, 4);
	transpose4x4(testb1);
	dctii_4(testb1, 4);
	print_data(testb1, 4, 4, "Perera DCT");
	
	dctiii_4(testb1, 4);
	transpose4x4(testb1);
	dctiii_4(testb1, 4);
	print_data(testb1, 4, 4, "Recovered");


	for(int k=0;k<16;++k)
	{
		if(fabsf(testb1[k]/16-testb0[k])>1e-2)
			CRASH("ERROR");
	}
#endif
	printf("SUCCESS\n");
	exit(0);
}
#endif


#ifdef PROFILE_SIZE
static double csizes[3][4]={0};//{DC, LFO, AC, flags}
#endif

static const int lforadii[]={25, 16, 9, 4};
static uint32_t hweight[3*NCTX];
static uint32_t hists[3*NCTX*NLEVELS];
ALIGN(32) static float blocks[3][BLOCK0X*BLOCK0Y]={0},
	qtable0a[3][BLOCK0X*BLOCK0Y],
	qtable1a[3][BLOCK1X*BLOCK1Y],
	qtable2a[3][BLOCK2X*BLOCK2Y],
	qtable3a[3][BLOCK3X*BLOCK3Y];
int c48_codec(int argc, char **argv)
{
#ifdef TEST3
	test3();
#endif
#ifdef TEST2
	test2();
#endif
#ifdef TEST
	dcttest();//
#endif

	const uint16_t tag='4'|'7'<<8;

	const char *srcfn=0, *dstfn=0;
	FILE *fsrc=0, *fdst=0;
	uint64_t c=0;
	int fwd=0, iw=0, ih=0;
	int64_t usize=0, ccap=0, csize=0;
	//int psize=0;
	//int16_t *pixels=0;
	int xdc=0, ydc=0, dcsize=0;
	int16_t *dcbuf=0;
	uint8_t *image=0, *imptr=0, *stream=0, *streamptr=0;
#ifdef _MSC_VER
	uint8_t *streamend=0;
#endif
	int32_t weights[3][NPREDS]={0}, estim[NPREDS]={0};
	int32_t pred=0, ctx=0, error=0, sym=0, curr=0, cdf=0, freq=0;
	uint64_t low=0, range=0xFFFFFFFFFFFF, code=0;
#ifdef LOUD
	double t=0;
#endif

	if(argc!=3)
	{
		printf(
			"Usage:  \"%s\"  src  dst\n"
			"Only for 24-bit PPM images\n"
			"Built on %s %s\n"
			, argv[0]
			, __DATE__, __TIME__
		);
		return 1;
	}
#ifdef LOUD
	t=time_sec();
#endif
	srcfn=argv[1];
	dstfn=argv[2];
	
	fsrc=fopen(srcfn, "rb");
	if(!fsrc)
	{
		CRASH("Cannot open \"%s\"", srcfn);
		return 1;
	}
	fread(&c, 1, 2, fsrc);
	fwd=c==('P'|'6'<<8);
	if(!fwd&&c!=tag)
	{
		CRASH("Unsupported file \"%s\"", srcfn);
		return 1;
	}
	if(fwd)//parse header
	{
		c=fgetc(fsrc);
		if(c!='\n')
		{
			CRASH("Unsupported PPM file");
			return 1;
		}
		c=fgetc(fsrc);
		while(c=='#')
		{
			c=fgetc(fsrc);
			while(c!='\n')
				c=fgetc(fsrc);
			c=fgetc(fsrc);
		}
		iw=0;
		while((uint32_t)(c-'0')<10)
		{
			iw=10*iw+(int32_t)c-'0';
			c=fgetc(fsrc);
		}
		while(c<=' ')
			c=fgetc(fsrc);
		ih=0;
		while((uint32_t)(c-'0')<10)
		{
			ih=10*ih+(int32_t)c-'0';
			c=fgetc(fsrc);
		}
		while(c=='#')
		{
			c=fgetc(fsrc);
			while(c!='\n')
				c=fgetc(fsrc);
			c=fgetc(fsrc);
		}
		c|=(int64_t)fgetc(fsrc)<<8*1;
		c|=(int64_t)fgetc(fsrc)<<8*2;
		c|=(int64_t)fgetc(fsrc)<<8*3;
		c|=(int64_t)fgetc(fsrc)<<8*4;
		if(c!=(
			(uint64_t)'\n'<<8*0|
			(uint64_t) '2'<<8*1|
			(uint64_t) '5'<<8*2|
			(uint64_t) '5'<<8*3|
			(uint64_t)'\n'<<8*4
		))
		{
			CRASH("Unsupported PPM file");
			return 1;
		}
		ccap=(int64_t)4*iw*ih;
	}
	else
	{
		iw=0;
		ih=0;
		fread(&iw, 1, 3, fsrc);
		fread(&ih, 1, 3, fsrc);
		{
			struct stat info={0};

			stat(srcfn, &info);
			ccap=(int64_t)info.st_size-ftell(fsrc);
		}
	}
	if(iw<1||ih<1)
	{
		CRASH("Unsupported source file");
		return 1;
	}
	usize=(int64_t)3*iw*ih;
	image=(uint8_t*)malloc(usize);
	stream=(uint8_t*)malloc(ccap);
	xdc=(iw+BLOCK3X-1)/BLOCK3X;
	ydc=(ih+BLOCK3Y-1)/BLOCK3Y;
	dcsize=xdc*ydc*(int)sizeof(int16_t[6]);
	dcbuf=(int16_t*)malloc(dcsize);
	//psize=(iw/BLOCK0X+2*XPAD)*(int)sizeof(int16_t[NCH*NROWS*NVAL]);
	//pixels=(int16_t*)malloc(psize);
	if(!image||!stream||!dcbuf)
	{
		CRASH("Alloc error");
		return 1;
	}
	streamptr=stream;
#ifdef _MSC_VER
	streamend=stream+ccap;
#endif
	if(fwd)
	{
		fread(image, 1, usize, fsrc);
#ifdef ENABLE_GUIDE
		//for(int ky=0;ky<ih;++ky)
		//{
		//	for(int kx=0;kx<iw;++kx)
		//	{
		//		image[3*(iw*ky+kx)+0]=64*(kx^ky);
		//		image[3*(iw*ky+kx)+1]=64*(kx^ky);
		//		image[3*(iw*ky+kx)+2]=64*(kx^ky);
		//	}
		//}
		//for(ptrdiff_t k=0;k<usize;++k)//
		//	image[k]=rand()>>8&15;

		guide_save(image, iw, ih);
#endif
	}
	else
	{
		c=fread(stream, 1, ccap, fsrc);
	}
	fclose(fsrc);

	for(int k=0;k<3*NPREDS;++k)
		((int32_t*)weights)[k]=(1<<SHIFT)/NPREDS;
	memset(dcbuf, 0, dcsize);
	//memset(pixels, 0, psize);
	memset(hists, 0, sizeof(hists));
	memset(hweight, 0, sizeof(hweight));
	const float dcgain0=1.f/1.5f, lfogain0=8, acgain0=64;
	const float dcgain1=1.f/1.5f, lfogain1=8, acgain1=48;
	const float dcgain2=1.f/1.5f, lfogain2=8, acgain2=32;
	const float dcgain3=1.f/1.5f, lfogain3=2, acgain3=6;
//	const float dcgain3=1.f/12, lfogain3=2, acgain3=4;
//	const float dcgain=1.f/16, lfogain=1, acgain=16;
//	const float dcgain=1.f/8, lfogain=4, acgain=16;
	if(fwd)
	{
		for(int k=0;k<BLOCK0X*BLOCK0Y;++k)
		{
			int x=k%BLOCK0X, y=k/BLOCK0X;
			//float gain=(1.1f-expf((float)(x+y)/16))*96;
			//float gain=(x+0.75f)*(x+0.75f)+(y+0.75f)*(y+0.75f);
			//if(gain>64)
			//	gain=64;
			//qtable0a[0][k]=1/(gain*qtable0[0][k]);
			//qtable0a[1][k]=1/(gain*qtable0[1][k]);
			//qtable0a[2][k]=1/(gain*qtable0[2][k]);
			qtable0a[0][k]=k?x*x+y*y<lforadii[0]?1/(lfogain0*qtable0[0][k]):1/(acgain0*qtable0[0][k]):1/(dcgain0*qtable0[0][k]);
			qtable0a[1][k]=k?x*x+y*y<lforadii[0]?1/(lfogain0*qtable0[1][k]):1/(acgain0*qtable0[1][k]):1/(dcgain0*qtable0[1][k]);
			qtable0a[2][k]=k?x*x+y*y<lforadii[0]?1/(lfogain0*qtable0[2][k]):1/(acgain0*qtable0[2][k]):1/(dcgain0*qtable0[2][k]);
		}
		for(int k=0;k<BLOCK1X*BLOCK1Y;++k)
		{
			int x=k%BLOCK1X, y=k/BLOCK1X;
			//float gain=(1.05f-expf((float)(x+y)/10))*48;
			//float gain=(x+0.75f)*(x+0.75f)+(y+0.75f)*(y+0.75f);
			//if(gain>48)
			//	gain=48;
			//qtable1a[0][k]=1/(gain*qtable1[0][k]);
			//qtable1a[1][k]=1/(gain*qtable1[1][k]);
			//qtable1a[2][k]=1/(gain*qtable1[2][k]);
			qtable1a[0][k]=k?x*x+y*y<lforadii[1]?1/(lfogain1*qtable1[0][k]):1/(acgain1*qtable1[0][k]):1/(dcgain1*qtable1[0][k]);
			qtable1a[1][k]=k?x*x+y*y<lforadii[1]?1/(lfogain1*qtable1[1][k]):1/(acgain1*qtable1[1][k]):1/(dcgain1*qtable1[1][k]);
			qtable1a[2][k]=k?x*x+y*y<lforadii[1]?1/(lfogain1*qtable1[2][k]):1/(acgain1*qtable1[2][k]):1/(dcgain1*qtable1[2][k]);
		}
		for(int k=0;k<BLOCK2X*BLOCK2Y;++k)
		{
			int x=k%BLOCK2X, y=k/BLOCK2X;
			//float gain=(x+0.75f)*(x+0.75f)+(y+0.75f)*(y+0.75f);
			//if(gain>32)
			//	gain=32;
			//qtable2a[0][k]=1/(gain*qtable2[0][k]);
			//qtable2a[1][k]=1/(gain*qtable2[1][k]);
			//qtable2a[2][k]=1/(gain*qtable2[2][k]);
			qtable2a[0][k]=k?x*x+y*y<lforadii[2]?1/(lfogain2*qtable2[0][k]):1/(acgain2*qtable2[0][k]):1/(dcgain2*qtable2[0][k]);
			qtable2a[1][k]=k?x*x+y*y<lforadii[2]?1/(lfogain2*qtable2[1][k]):1/(acgain2*qtable2[1][k]):1/(dcgain2*qtable2[1][k]);
			qtable2a[2][k]=k?x*x+y*y<lforadii[2]?1/(lfogain2*qtable2[2][k]):1/(acgain2*qtable2[2][k]):1/(dcgain2*qtable2[2][k]);
		}
		for(int k=0;k<BLOCK3X*BLOCK3Y;++k)
		{
			int x=k%BLOCK3X, y=k/BLOCK3X;
			qtable3a[0][k]=k?x*x+y*y<lforadii[3]?1/(lfogain3*qtable3[0][k]):1/(acgain3*qtable3[0][k]):1/(dcgain3*qtable3[0][k]);
			qtable3a[1][k]=k?x*x+y*y<lforadii[3]?1/(lfogain3*qtable3[1][k]):1/(acgain3*qtable3[1][k]):1/(dcgain3*qtable3[1][k]);
			qtable3a[2][k]=k?x*x+y*y<lforadii[3]?1/(lfogain3*qtable3[2][k]):1/(acgain3*qtable3[2][k]):1/(dcgain3*qtable3[2][k]);
			//prev  x+y<5
		}
	}
	else
	{
		for(int k=0;k<BLOCK0X*BLOCK0Y;++k)
		{
			int x=k%BLOCK0X, y=k/BLOCK0X;
			//float gain=(1.1f-expf((float)(x+y)/16))*96;
			//float gain=(x+0.75f)*(x+0.75f)+(y+0.75f)*(y+0.75f);
			//if(gain>64)
			//	gain=64;
			//qtable0a[0][k]=qtable0[0][k]*(gain/(BLOCK0X*BLOCK0Y));
			//qtable0a[1][k]=qtable0[1][k]*(gain/(BLOCK0X*BLOCK0Y));
			//qtable0a[2][k]=qtable0[2][k]*(gain/(BLOCK0X*BLOCK0Y));
			qtable0a[0][k]=(k?x*x+y*y<lforadii[0]?lfogain0*qtable0[0][k]:acgain0*qtable0[0][k]:dcgain0*qtable0[0][k])/(BLOCK0X*BLOCK0Y);
			qtable0a[1][k]=(k?x*x+y*y<lforadii[0]?lfogain0*qtable0[1][k]:acgain0*qtable0[1][k]:dcgain0*qtable0[1][k])/(BLOCK0X*BLOCK0Y);
			qtable0a[2][k]=(k?x*x+y*y<lforadii[0]?lfogain0*qtable0[2][k]:acgain0*qtable0[2][k]:dcgain0*qtable0[2][k])/(BLOCK0X*BLOCK0Y);
		}
		for(int k=0;k<BLOCK1X*BLOCK1Y;++k)
		{
			int x=k%BLOCK1X, y=k/BLOCK1X;
			//float gain=(1.05f-expf((float)(x+y)/10))*48;
			//float gain=(x+0.75f)*(x+0.75f)+(y+0.75f)*(y+0.75f);
			//if(gain>48)
			//	gain=48;
			//qtable1a[0][k]=qtable1[0][k]*(gain/(BLOCK1X*BLOCK1Y));
			//qtable1a[1][k]=qtable1[1][k]*(gain/(BLOCK1X*BLOCK1Y));
			//qtable1a[2][k]=qtable1[2][k]*(gain/(BLOCK1X*BLOCK1Y));
			qtable1a[0][k]=(k?x*x+y*y<lforadii[1]?lfogain1*qtable1[0][k]:acgain1*qtable1[0][k]:dcgain1*qtable1[0][k])/(BLOCK1X*BLOCK1Y);
			qtable1a[1][k]=(k?x*x+y*y<lforadii[1]?lfogain1*qtable1[1][k]:acgain1*qtable1[1][k]:dcgain1*qtable1[1][k])/(BLOCK1X*BLOCK1Y);
			qtable1a[2][k]=(k?x*x+y*y<lforadii[1]?lfogain1*qtable1[2][k]:acgain1*qtable1[2][k]:dcgain1*qtable1[2][k])/(BLOCK1X*BLOCK1Y);
		}
		for(int k=0;k<BLOCK2X*BLOCK2Y;++k)
		{
			int x=k%BLOCK2X, y=k/BLOCK2X;
			//float gain=(x+0.75f)*(x+0.75f)+(y+0.75f)*(y+0.75f);
			//if(gain>32)
			//	gain=32;
			//qtable2a[0][k]=qtable2[0][k]*(gain/(BLOCK2X*BLOCK2Y));
			//qtable2a[1][k]=qtable2[1][k]*(gain/(BLOCK2X*BLOCK2Y));
			//qtable2a[2][k]=qtable2[2][k]*(gain/(BLOCK2X*BLOCK2Y));
			qtable2a[0][k]=(k?x*x+y*y<lforadii[2]?lfogain2*qtable2[0][k]:acgain2*qtable2[0][k]:dcgain2*qtable2[0][k])/(BLOCK2X*BLOCK2Y);
			qtable2a[1][k]=(k?x*x+y*y<lforadii[2]?lfogain2*qtable2[1][k]:acgain2*qtable2[1][k]:dcgain2*qtable2[1][k])/(BLOCK2X*BLOCK2Y);
			qtable2a[2][k]=(k?x*x+y*y<lforadii[2]?lfogain2*qtable2[2][k]:acgain2*qtable2[2][k]:dcgain2*qtable2[2][k])/(BLOCK2X*BLOCK2Y);
		}
		for(int k=0;k<BLOCK3X*BLOCK3Y;++k)
		{
			int x=k%BLOCK3X, y=k/BLOCK3X;
			qtable3a[0][k]=(k?x*x+y*y<lforadii[3]?lfogain3*qtable3[0][k]:acgain3*qtable3[0][k]:dcgain3*qtable3[0][k])/(BLOCK3X*BLOCK3Y);
			qtable3a[1][k]=(k?x*x+y*y<lforadii[3]?lfogain3*qtable3[1][k]:acgain3*qtable3[1][k]:dcgain3*qtable3[1][k])/(BLOCK3X*BLOCK3Y);
			qtable3a[2][k]=(k?x*x+y*y<lforadii[3]?lfogain3*qtable3[2][k]:acgain3*qtable3[2][k]:dcgain3*qtable3[2][k])/(BLOCK3X*BLOCK3Y);
		}
		code=0;
		code=code<<32|*(uint32_t*)streamptr; streamptr+=sizeof(uint32_t);//load
		code=code<<32|*(uint32_t*)streamptr; streamptr+=sizeof(uint32_t);
	}
#ifdef _MSC_VER
	//ctx_ctr=0, renorm_ctr=0;//
	int rmin[2]={0}, rmax[2]={0};
#endif
	for(int ky=0;ky<ih;ky+=BLOCK0Y)
	{
		//int16_t *rows[]=
		//{
		//	pixels+(XPAD*NCH*NROWS+(ky/BLOCK0Y-0LL+NROWS)%NROWS)*NVAL,
		//	pixels+(XPAD*NCH*NROWS+(ky/BLOCK0Y-1LL+NROWS)%NROWS)*NVAL,
		//	pixels+(XPAD*NCH*NROWS+(ky/BLOCK0Y-2LL+NROWS)%NROWS)*NVAL,
		//	pixels+(XPAD*NCH*NROWS+(ky/BLOCK0Y-3LL+NROWS)%NROWS)*NVAL,
		//};
		int y2=ky+BLOCK0Y, dy;

		if(y2>ih)
			y2=ih;
		dy=y2-ky;
		for(int kx=0;kx<iw;kx+=BLOCK0X)
		{
			const float *tables[3]={0};
			int blocktype[3]={0};
			int x2=kx+BLOCK0X, dx;
			int den=0;

			if(x2>iw)
				x2=iw;
			dx=x2-kx;
			if(fwd)
			{
				for(int ky2=0;ky2<dy;++ky2)
				{
					imptr=image+3*(iw*(ky+ky2)+kx);
					for(int kx2=0;kx2<dx;++kx2, imptr+=3)
					{
						((int*)blocks[0])[BLOCK0X*ky2+kx2]=imptr[0];
						((int*)blocks[1])[BLOCK0X*ky2+kx2]=imptr[1];
						((int*)blocks[2])[BLOCK0X*ky2+kx2]=imptr[2];
					}
					for(int kx2=dx;kx2<BLOCK0X;++kx2)
					{
						blocks[0][BLOCK0X*ky2+kx2]=blocks[0][BLOCK0X*ky2+dx-1];
						blocks[1][BLOCK0X*ky2+kx2]=blocks[1][BLOCK0X*ky2+dx-1];
						blocks[2][BLOCK0X*ky2+kx2]=blocks[2][BLOCK0X*ky2+dx-1];
					}
				}
				for(int ky2=dy;ky2<BLOCK0Y;++ky2)
				{
					memcpy(blocks[0]+BLOCK0X*ky2, blocks[0]+BLOCK0X*(dy-1), sizeof(float[BLOCK0X]));
					memcpy(blocks[1]+BLOCK0X*ky2, blocks[1]+BLOCK0X*(dy-1), sizeof(float[BLOCK0X]));
					memcpy(blocks[2]+BLOCK0X*ky2, blocks[2]+BLOCK0X*(dy-1), sizeof(float[BLOCK0X]));
				}
				for(int kc=0;kc<3;++kc)
				{
					for(int k=0;k<BLOCK0X*BLOCK0Y/16;++k)
						cvti2f(((float*)blocks[kc])+16*k);
				}
				for(int k=0;k<BLOCK0X*BLOCK0Y/16;++k)
					rgb2yuv(
						((float*)blocks[0])+16*k,
						((float*)blocks[1])+16*k,
						((float*)blocks[2])+16*k
					);
				double sad[3]={0};
				for(int ky=0;ky<BLOCK0Y;++ky)
				{
					for(int kx=1;kx<BLOCK0X;++kx)
					{
						sad[0]+=fabsf(blocks[0][BLOCK0X*ky+kx]-blocks[0][BLOCK0X*ky+kx-1]);
						sad[1]+=fabsf(blocks[1][BLOCK0X*ky+kx]-blocks[1][BLOCK0X*ky+kx-1]);
						sad[2]+=fabsf(blocks[2][BLOCK0X*ky+kx]-blocks[2][BLOCK0X*ky+kx-1]);
					}
				}
				for(int ky=1;ky<BLOCK0Y;++ky)
				{
					for(int kx=0;kx<BLOCK0X;++kx)
					{
						sad[0]+=fabsf(blocks[0][BLOCK0X*ky+kx]-blocks[0][BLOCK0X*(ky-1)+kx]);
						sad[1]+=fabsf(blocks[1][BLOCK0X*ky+kx]-blocks[1][BLOCK0X*(ky-1)+kx]);
						sad[2]+=fabsf(blocks[2][BLOCK0X*ky+kx]-blocks[2][BLOCK0X*(ky-1)+kx]);
					}
				}
				sad[0]*=1./(2*BLOCK0X*(BLOCK0Y-1));
				sad[1]*=1./(2*BLOCK0X*(BLOCK0Y-1));
				sad[2]*=1./(2*BLOCK0X*(BLOCK0Y-1));
				static const double thresholds[]=
				{
					4.410167,
					1.346712,
					1.180267,
				};
				blocktype[0]=DCTsize32;
				blocktype[1]=DCTsize32;
				blocktype[2]=DCTsize32;
				if(sad[0]>thresholds[0]/16)blocktype[0]=DCTsize16;
				if(sad[1]>thresholds[1]/16)blocktype[1]=DCTsize16;
				if(sad[2]>thresholds[2]/16)blocktype[2]=DCTsize16;
				if(sad[0]>thresholds[0]/4)blocktype[0]=DCTsize8;
				if(sad[1]>thresholds[1]/4)blocktype[1]=DCTsize8;
				if(sad[2]>thresholds[2]/4)blocktype[2]=DCTsize8;
				if(sad[0]>thresholds[0]/2)blocktype[0]=DCTsize4;
				if(sad[1]>thresholds[1]/2)blocktype[1]=DCTsize4;
				if(sad[2]>thresholds[2]/2)blocktype[2]=DCTsize4;
				for(int kc=0;kc<3;++kc)
				{
					switch(blocktype[kc])
					{
					case DCTsize32:
						for(int k=0;k<32/4;++k)
							dctii_32(blocks[kc]+4*k, 32);
						transpose32x32(blocks[kc]);
						for(int k=0;k<32/4;++k)
							dctii_32(blocks[kc]+4*k, 32);
						for(int k=0;k<32*32;++k)
							blocks[kc][k]*=qtable0a[kc][k];
						break;
					case DCTsize16:
						{
							enum
							{
								BLOCK_L=32,
								BLOCK_S=16,
								XBLOCKS=BLOCK_L/BLOCK_S,
							};
							for(int by=0;by<XBLOCKS;++by)
							{
								for(int bx=0;bx<XBLOCKS;++bx)
								{
									float *block=blocks[kc]+16*(32*by+bx);
									for(int k=0;k<16/4;++k)
										dctii_16(block+4*k, 32);
								}
							}
							transpose32x32(blocks[kc]);
							for(int by=0;by<XBLOCKS;++by)
							{
								for(int bx=0;bx<XBLOCKS;++bx)
								{
									float *block=blocks[kc]+16*(32*by+bx);
									for(int k=0;k<16/4;++k)
										dctii_16(block+4*k, 32);
									for(int ky2=0;ky2<16;++ky2)
									{
										for(int kx2=0;kx2<16;++kx2)
											block[32*ky2+kx2]*=qtable1a[kc][16*ky2+kx2];
									}
									//for(int k=0;k<16*16/16;++k)
									//	gain(block+16*k, qtable1[kc]+16*k, 4, 4);
								}
							}
#if 0
							{//2x2 DCT
								float dc[XBLOCKS*XBLOCKS]={0};
								for(int ky2=0;ky2<XBLOCKS;++ky2)
								{
									for(int kx2=0;kx2<XBLOCKS;++kx2)
										dc[XBLOCKS*ky2+kx2]=blocks[kc][XBLOCKS*(32*ky2+kx2)];
								}
								float d2[XBLOCKS*XBLOCKS]={0};
								d2[0]=dc[0]+dc[1];
								d2[1]=dc[0]-dc[1];
								d2[2]=dc[2]+dc[3];
								d2[3]=dc[2]-dc[3];

								dc[0]=d2[0]+d2[2];
								dc[2]=d2[0]-d2[2];
								dc[1]=d2[1]+d2[3];
								dc[3]=d2[1]-d2[3];
								for(int ky2=0;ky2<XBLOCKS;++ky2)
								{
									for(int kx2=0;kx2<XBLOCKS;++kx2)
										blocks[kc][XBLOCKS*(32*ky2+kx2)]=dc[XBLOCKS*ky2+kx2];
								}
							}
#endif
						}
						break;
					case DCTsize8:
						for(int by=0;by<32/8;++by)
						{
							for(int bx=0;bx<32/8;++bx)
							{
								float *block=blocks[kc]+8*(32*by+bx);
								for(int k=0;k<8/4;++k)
									dctii_8(block+4*k, 32);
							}
						}
						transpose32x32(blocks[kc]);
						for(int by=0;by<32/8;++by)
						{
							for(int bx=0;bx<32/8;++bx)
							{
								float *block=blocks[kc]+8*(32*by+bx);
								for(int k=0;k<8/4;++k)
									dctii_8(block+4*k, 32);
								for(int ky2=0;ky2<8;++ky2)
								{
									for(int kx2=0;kx2<8;++kx2)
										block[32*ky2+kx2]*=qtable2a[kc][8*ky2+kx2];
								}
							}
						}
						break;
					case DCTsize4:
						for(int by=0;by<32/4;++by)
						{
							for(int bx=0;bx<32/4;++bx)
							{
								float *block=blocks[kc]+4*(32*by+bx);
								for(int k=0;k<4/4;++k)
									dctii_4(block+4*k, 32);
							}
						}
						transpose32x32(blocks[kc]);
						for(int by=0;by<32/4;++by)
						{
							for(int bx=0;bx<32/4;++bx)
							{
								float *block=blocks[kc]+4*(32*by+bx);
								for(int k=0;k<4/4;++k)
									dctii_4(block+4*k, 32);
								for(int ky2=0;ky2<4;++ky2)
								{
									for(int kx2=0;kx2<4;++kx2)
										block[32*ky2+kx2]*=qtable3a[kc][4*ky2+kx2];
								}
							}
						}
						break;
					}
				}
				for(int kc=0;kc<3;++kc)
				{
					for(int k=0;k<BLOCK0X*BLOCK0Y/16;++k)
						cvtf2i(((float*)blocks[kc])+16*k);
				}
#if 0
				dct4y4_fwd(blocks[0]);
				dct4y4_fwd(blocks[1]);
				dct4y4_fwd(blocks[2]);
				transpose4x4(blocks[0]);
				transpose4x4(blocks[1]);
				transpose4x4(blocks[2]);
				dct4y4_fwd(blocks[0]);
				dct4y4_fwd(blocks[1]);
				dct4y4_fwd(blocks[2]);
#if defined _MSC_VER && 0
				for(int kc=0;kc<3;++kc)for(int k=0;k<BLOCK0X*BLOCK0Y;++k)sum_before[kc][k]+=fabsf(blocks[kc][k]);
#endif
				gain(blocks[0], qtable0[0]);
				gain(blocks[1], qtable0[1]);
				gain(blocks[2], qtable0[2]);
				cvtf2i(blocks[0]);
				cvtf2i(blocks[1]);
				cvtf2i(blocks[2]);
#endif
#if defined _MSC_VER && 0
				for(int kc=0;kc<3;++kc)for(int k=0;k<BLOCK0X*BLOCK0Y;++k)sum_after[kc][k]+=abs(((int*)blocks[kc])[k]);
#endif
			}
			for(int kc=0;kc<3;++kc)
			{
				int blocksize=32, xblocks=1;
				if(fwd)
				{
					if(range<=0xFFFF)
					{
//#ifdef _MSC_VER
//						++renorm_ctr;
//#endif
						*(uint32_t*)streamptr=(uint32_t)(low>>32);
						streamptr+=sizeof(uint32_t);
						low<<=32;
						range=range<<32|0xFFFFFFFF;
						if(range>~low)
							range=~low;
					}
				}
				else
				{
					if(range<=0xFFFF)//stall: unpredictable branch
					{
//#ifdef _MSC_VER
//						++renorm_ctr;
//#endif
#ifdef _MSC_VER
						if(streamptr>streamend)
							CRASH("");
#endif
						code=code<<32|*(uint32_t*)streamptr;
						streamptr+=sizeof(uint32_t);
						low<<=32;
						range=range<<32|0xFFFFFFFF;
						if(range>~low)
							range=~low;
					}
					blocktype[kc]=(int)(((code-low)*4+3)/range);
#ifdef _MSC_VER
					if((unsigned)blocktype[kc]>3)
						CRASH("");
#endif
				}
				low+=range*blocktype[kc]>>2;
				range=(range>>2)-1;
#ifdef PROFILE_SIZE
				csizes[kc][3]+=2;
#endif
#ifdef FIFOVAL
				if(fwd)
				{
					//printf("%d", blocktype[kc]);//
					//if(kc==2&&x2==iw)
					//	printf("\n");
					//else if(kc==2)
					//	printf(" ");

					valfifo_enqueue(blocktype[kc]);
				}
				else
					valfifo_check(blocktype[kc]);
#endif
				//int lforadius=lforadii[blocktype[kc]];
				int lgblockgain=0;
				tables[kc]=qtable0[kc];
				if(blocktype[kc]==1)blocksize=16, xblocks=2, tables[kc]=qtable1[kc], lgblockgain=5+5-4-4;
				if(blocktype[kc]==2)blocksize= 8, xblocks=4, tables[kc]=qtable2[kc], lgblockgain=5+5-3-3;
				if(blocktype[kc]==3)blocksize= 4, xblocks=8, tables[kc]=qtable3[kc], lgblockgain=5+5-2-2;
				int dcsize=blocksize/4, dcstride=6*xdc;
				for(int by=0;by<xblocks;++by)
				{
					for(int bx=0;bx<xblocks;++bx)
					{
						int
							idx	=6*(xdc*(ky*4/BLOCK0Y)+kx*4/BLOCK0X)+kc,
							NNN	=idx+0*6-3*dcstride<0?0:dcbuf[idx+0*6-3*dcstride+0],
							NN	=idx+0*6-2*dcstride<0?0:dcbuf[idx+0*6-2*dcstride+0],
							NW	=idx-1*6-1*dcstride<0?0:dcbuf[idx-1*6-1*dcstride+0],
							N	=idx+0*6-1*dcstride<0?0:dcbuf[idx+0*6-1*dcstride+0],
							WWW	=idx-3*6+0*dcstride<0?0:dcbuf[idx-3*6+0*dcstride+0],
							WW	=idx-2*6+0*dcstride<0?0:dcbuf[idx-2*6+0*dcstride+0],
							W	=idx-1*6+0*dcstride<0?0:dcbuf[idx-1*6+0*dcstride+0],
							eN	=idx+0*6-1*dcstride<0?0:dcbuf[idx+0*6-1*dcstride+3],
							eW	=idx-1*6+0*dcstride<0?0:dcbuf[idx-1*6+0*dcstride+3];
						for(int ky2=0, idx2=0;ky2<blocksize;++ky2)
						{
							for(int kx2=0;kx2<blocksize;++kx2, ++idx2)
							{
								int p1=0;
								
							//	if(ky==2852&&kx==4288)//
							//	if(ky==2852&&kx==4284)//
							//	if(ky==0&&kx==8)//
							//	if(ky==0&&kx==12)//
							//	if(ky==0&&kx==2804)//
							//	if(ky==0&&kx==8&&!kc&&!k)//
							//	if(ky==2852&&kx==4284&&kc==1&&k==8)//
							//	if(ky==12&&kx==1172&&!kc&&!k)//
							//	if(ky==8&&kx==1676&&!kc&&!k)//
							//	if(ky==0&&kx==0&&kc==1&&!k)//
							//	if(ky==0&&kx==0&&kc==0&&k==1)//
							//	if(ky==0&&kx==4&&kc==0&&k==1)//
							//	if(ky==0&&kx==256&&kc==1&&k==0)//
							//	if(ky==0&&kx==256&&kc==0&&k==0)//
							//	if(ky==0&&kx==256&&kc==0&&k==0)//
							//	if(ky==2652&&kx==3132&&kc==1&&k==7)//
							//	if(ky==0&&kx==0&&kc==0&&k==4)//
							//	if(ky==0&&kx==96&&kc==0&&ky2==31&&kx2==29)//
							//		printf("");

								if(!idx2)
								{
									int vmax=N, vmin=W;
									if(N<W)vmin=N, vmax=W;
									if(vmin>NW)vmin=NW;
									if(vmax<NW)vmax=NW;
									if(vmin>WW)vmin=WW;
									if(vmax<WW)vmax=WW;
									if(vmin>NN)vmin=NN;
									if(vmax<NN)vmax=NN;
#define PRED(E) estim[j]=E; pred+=weights[kc][j]*estim[j]; ++j;
									int j=0;
									PREDLIST
#undef  PRED
									pred>>=SHIFT;
									p1=pred;
									CLAMP2(pred, vmin, vmax);
									pred+=1<<lgblockgain>>1;
									pred>>=lgblockgain;

									ctx=FLOOR_LOG2(eN*eW+1);
									ctx-=lgblockgain<<1;
									if(ctx<0)
										ctx=0;
									if(ctx>NCTX_DC-1)
										ctx=NCTX_DC-1;
								}
								else
								{
									pred=0;
								//	ctx=(int)(tables[kc][blocksize*ky2+kx2]*(kx2*kx2+ky2*ky2<lforadius?lfogain:acgain));
									ctx=(int)(tables[kc][blocksize*ky2+kx2]*0.5);
									if(ctx>NCTX_AC-1)
										ctx=NCTX_AC-1;
									ctx+=NCTX_AC*blocktype[kc];
									ctx+=NCTX_DC;
								}
								ctx+=NCTX*kc;
								
#ifdef _MSC_VER
								//ctx_ctr+=ctx==18;
								//if(ctx_ctr==1114)
								//	printf("");
#endif
								
								uint32_t *currhist=hists+NLEVELS*ctx;
								den=hweight[ctx]+NLEVELS;
								if(fwd)
								{
#ifdef FIFOVAL
									valfifo_enqueue(ctx<<24^p1<<12^pred);
#endif
									curr=((int*)blocks[kc])[32*(blocksize*by+ky2)+blocksize*bx+kx2];
									//if(curr<-(NLEVELS>>1)||curr>(NLEVELS>>1)-1)
									//	CRASH("");
#ifdef _MSC_VER
									if(rmin[idx2!=0]>curr)rmin[idx2!=0]=curr;
									if(rmax[idx2!=0]<curr)rmax[idx2!=0]=curr;
#endif
									CLAMP2(curr, -(NLEVELS>>1), (NLEVELS>>1)-1);
									error=((curr-pred+(NLEVELS>>1))&(NLEVELS-1))-(NLEVELS>>1);
									sym=error<<1^error>>31;

									if(range<=0xFFFF)
									{
//#ifdef _MSC_VER
//										//if(renorm_ctr==423+2)
//										//	printf("");
//										++renorm_ctr;
//#endif
										*(uint32_t*)streamptr=(uint32_t)(low>>32);
										streamptr+=sizeof(uint32_t);
										low<<=32;
										range=range<<32|0xFFFFFFFF;
										if(range>~low)
											range=~low;
									}
									int t=0;
									cdf=0;
									for(;;)
									{
										freq=currhist[t]+1;
										if(t>=sym)
											break;
										cdf+=freq;
										++t;
									}
									if(cdf)
										cdf+=0;
#ifdef _MSC_VER
									if(!freq
										||(uint32_t)freq>(uint32_t)den
										||(uint32_t)cdf>(uint32_t)den
										||(uint32_t)(cdf+freq)>(uint32_t)den
										||den>0xFFFF
									)
										CRASH("");
#endif
#ifdef FIFOVAL
									valfifo_enqueue(freq<<16|cdf);
#endif
									low+=range*cdf/den;
									range=range*freq/den-1;
#ifdef PROFILE_SIZE
									csizes[kc][(idx2!=0)+(kx2+ky2>=4)]+=-log2((double)freq/den);
#endif
								}
								else
								{
#ifdef FIFOVAL
									valfifo_check(ctx<<24^p1<<12^pred);
#endif
									if(range<=0xFFFF)//stall: unpredictable branch
									{
//#ifdef _MSC_VER
//										//if(renorm_ctr==423)
//										//	printf("");
//										++renorm_ctr;
//#endif
#ifdef _MSC_VER
										if(streamptr>streamend)
											CRASH("");
#endif
										code=code<<32|*(uint32_t*)streamptr;
										streamptr+=sizeof(uint32_t);
										low<<=32;
										range=range<<32|0xFFFFFFFF;
										if(range>~low)
											range=~low;
									}
									int c2=(int)(((code-low+1)*den-1)/range);
									sym=0;
									cdf=0;
									for(;;)
									{
										freq=currhist[sym]+1;
										if(cdf+freq>c2)
											break;
										cdf+=freq;
										++sym;
									}
#ifdef FIFOVAL
									if(cdf)//
										cdf+=0;//
									valfifo_check(freq<<16|cdf);
#endif
									low+=range*cdf/den;
									range=range*freq/den-1;
									error=sym>>1^-(sym&1);
									curr=((error+pred+(NLEVELS>>1))&(NLEVELS-1))-(NLEVELS>>1);
									((int*)blocks[kc])[32*(blocksize*by+ky2)+blocksize*bx+kx2]=curr;
									error=curr-pred;
								}
								++currhist[sym];
								++hweight[ctx];
								if(hweight[ctx]>=0x4000)
								{
									den=0;
									for(int k=0;k<NLEVELS;++k)
										den+=currhist[k]>>=1;
									hweight[ctx]=den;
								}
								if(!idx2)
								{
									curr<<=lgblockgain;
									int e=(curr>p1)-(curr<p1);
#define PRED(...) weights[kc][j]+=e*estim[j]; ++j;
									int j=0;
									PREDLIST
#undef  PRED
									for(int ky3=0;ky3<dcsize;++ky3)
									{
										for(int kx3=0;kx3<dcsize;++kx3)
										{
											int idx3=6*(xdc*(ky*4/BLOCK0Y+ky3)+kx*4/BLOCK0X+kx3)+kc;
											dcbuf[idx3+0]=curr;
											dcbuf[idx3+3]=sym<<lgblockgain;
										}
									}
								}
							}
						}
					}
				}
			}
			if(!fwd)
			{
#if 0
				cvti2f(blocks[0]);
				cvti2f(blocks[1]);
				cvti2f(blocks[2]);
				gain(blocks[0], qtable0[0]);
				gain(blocks[1], qtable0[1]);
				gain(blocks[2], qtable0[2]);
				dct4y4_inv(blocks[0]);
				dct4y4_inv(blocks[1]);
				dct4y4_inv(blocks[2]);
				transpose4x4(blocks[0]);
				transpose4x4(blocks[1]);
				transpose4x4(blocks[2]);
				dct4y4_inv(blocks[0]);
				dct4y4_inv(blocks[1]);
				dct4y4_inv(blocks[2]);
				yuv2rgb(blocks[0], blocks[1], blocks[2]);
				cvtf2i(blocks[0]);
				cvtf2i(blocks[1]);
				cvtf2i(blocks[2]);
#endif
				for(int kc=0;kc<3;++kc)
				{
					for(int k=0;k<BLOCK0X*BLOCK0Y/16;++k)
						cvti2f(((float*)blocks[kc])+16*k);
				}
				for(int kc=0;kc<3;++kc)
				{
					switch(blocktype[kc])
					{
					case DCTsize32:
						for(int k=0;k<32*32/16;++k)
							gain(blocks[kc]+16*k, qtable0a[kc]+16*k);
						for(int k=0;k<32/4;++k)
							dctiii_32(blocks[kc]+4*k, 32);
						transpose32x32(blocks[kc]);
						for(int k=0;k<32/4;++k)
							dctiii_32(blocks[kc]+4*k, 32);
						break;
					case DCTsize16:
						{
							enum
							{
								BLOCK_L=32,
								BLOCK_S=16,
								XBLOCKS=BLOCK_L/BLOCK_S,
							};
							for(int by=0;by<XBLOCKS;++by)
							{
								for(int bx=0;bx<XBLOCKS;++bx)
								{
									float *block=blocks[kc]+16*(32*by+bx);
									for(int ky2=0;ky2<16;++ky2)
									{
										for(int kx2=0;kx2<16;++kx2)
											block[32*ky2+kx2]*=qtable1a[kc][16*ky2+kx2];
									}
									for(int k=0;k<16/4;++k)
										dctiii_16(block+4*k, 32);
								}
							}
							transpose32x32(blocks[kc]);
							for(int by=0;by<XBLOCKS;++by)
							{
								for(int bx=0;bx<XBLOCKS;++bx)
								{
									float *block=blocks[kc]+16*(32*by+bx);
									for(int k=0;k<16/4;++k)
										dctiii_16(block+4*k, 32);
								}
							}
						}
						break;
					case DCTsize8:
						for(int by=0;by<32/8;++by)
						{
							for(int bx=0;bx<32/8;++bx)
							{
								float *block=blocks[kc]+8*(32*by+bx);
								for(int ky2=0;ky2<8;++ky2)
								{
									for(int kx2=0;kx2<8;++kx2)
										block[32*ky2+kx2]*=qtable2a[kc][8*ky2+kx2];
								}
								for(int k=0;k<8/4;++k)
									dctiii_8(block+4*k, 32);
							}
						}
						transpose32x32(blocks[kc]);
						for(int by=0;by<32/8;++by)
						{
							for(int bx=0;bx<32/8;++bx)
							{
								float *block=blocks[kc]+8*(32*by+bx);
								for(int k=0;k<8/4;++k)
									dctiii_8(block+4*k, 32);
							}
						}
						break;
					case DCTsize4:
						for(int by=0;by<32/4;++by)
						{
							for(int bx=0;bx<32/4;++bx)
							{
								float *block=blocks[kc]+4*(32*by+bx);
								for(int ky2=0;ky2<4;++ky2)
								{
									for(int kx2=0;kx2<4;++kx2)
										block[32*ky2+kx2]*=qtable3a[kc][4*ky2+kx2];
								}
								for(int k=0;k<4/4;++k)
									dctiii_4(block+4*k, 32);
							}
						}
						transpose32x32(blocks[kc]);
						for(int by=0;by<32/4;++by)
						{
							for(int bx=0;bx<32/4;++bx)
							{
								float *block=blocks[kc]+4*(32*by+bx);
								for(int k=0;k<4/4;++k)
									dctiii_4(block+4*k, 32);
							}
						}
						break;
					}
				}
				for(int k=0;k<BLOCK0X*BLOCK0Y/16;++k)
					yuv2rgb(
						((float*)blocks[0])+16*k,
						((float*)blocks[1])+16*k,
						((float*)blocks[2])+16*k
					);
				for(int kc=0;kc<3;++kc)
				{
					for(int k=0;k<BLOCK0X*BLOCK0Y/16;++k)
						cvtf2i(((float*)blocks[kc])+16*k);
				}
				for(int ky2=0;ky2<dy;++ky2)
				{
					imptr=image+3*(iw*(ky+ky2)+kx);
					for(int kx2=0;kx2<dx;++kx2, imptr+=3)
					{
						imptr[0]=((int*)blocks[0])[BLOCK0X*ky2+kx2];
						imptr[1]=((int*)blocks[1])[BLOCK0X*ky2+kx2];
						imptr[2]=((int*)blocks[2])[BLOCK0X*ky2+kx2];
					}
				}
#ifdef ENABLE_GUIDE
				for(int ky2=0;ky2<dy;++ky2)
				{
					imptr=image+3*(iw*(ky+ky2)+kx);
					for(int kx2=0;kx2<dx;++kx2, imptr+=3)
					{
						int diff;

						diff=g_image[imptr-image+0]-imptr[0]; g_sqe[0]+=diff*diff;
						diff=g_image[imptr-image+1]-imptr[1]; g_sqe[1]+=diff*diff;
						diff=g_image[imptr-image+2]-imptr[2]; g_sqe[2]+=diff*diff;
					}
				}
#endif
			}
		}
	}
#if 0
	{
		double invres=1/((double)iw*ih);
		double rmse[]=
		{
			sqrt(g_sqe[0]*invres),
			sqrt(g_sqe[1]*invres),
			sqrt(g_sqe[2]*invres),
			0,
		};
		rmse[3]=(rmse[0]+rmse[1]+rmse[2])/3;
		double psnr[]=
		{
			-20*log10(rmse[0]/255),
			-20*log10(rmse[1]/255),
			-20*log10(rmse[2]/255),
			-20*log10(rmse[3]/255),
		};
		printf(
			"RMSE  PSNR\n"
			"T %12.6lf  %12.6lf\n"
			"Y %12.6lf  %12.6lf\n"
			"U %12.6lf  %12.6lf\n"
			"V %12.6lf  %12.6lf\n"
			, rmse[3], psnr[3]
			, rmse[0], psnr[0]
			, rmse[1], psnr[1]
			, rmse[2], psnr[2]
		);
	}
	exit(0);
#endif
	//free(pixels);
	free(dcbuf);

	fdst=fopen(dstfn, "wb");
	if(!fdst)
	{
		CRASH("Cannot open \"%s\" for writing", dstfn);
		return 1;
	}
	if(fwd)
	{
		*(uint32_t*)streamptr=(uint32_t)(low>>32); streamptr+=sizeof(uint32_t); low<<=32;//flush
		*(uint32_t*)streamptr=(uint32_t)(low>>32); streamptr+=sizeof(uint32_t); low<<=32;
		
		csize+=fwrite(&tag, 1, 2, fdst);
		csize+=fwrite(&iw, 1, 3, fdst);
		csize+=fwrite(&ih, 1, 3, fdst);
		csize+=fwrite(stream, 1, streamptr-stream, fdst);
	}
	else
	{
		fprintf(fdst, "P6\n%d %d\n255\n", iw, ih);
		fwrite(image, 1, usize, fdst);
	}
	fclose(fdst);
	free(image);
	free(stream);
#ifdef LOUD
	t=time_sec()-t;
	if(fwd)
	{
#ifdef _MSC_VER
		printf("DC %d ~ %d\n", rmin[0], rmax[0]);
		printf("AC %d ~ %d\n", rmin[1], rmax[1]);
#endif
#ifdef PROFILE_SIZE
		double sum=0;
		for(int kc=0;kc<3;++kc)
		{
			for(int k=0;k<4;++k)
				sum+=csizes[kc][k];
		}
		printf("Total est. %12.2lf\n", sum/8+8);//add header size
		if(!sum)
			sum=1;
		sum=100/sum;
		for(int kc=0;kc<3;++kc)
		{
			static const char *labels[]=
			{
				"DC",
				"LFO",
				"AC",
				"flags",
			};
			double sum2=0;
			for(int k=0;k<4;++k)
				sum2+=csizes[kc][k];
			printf("%c: %12.2lf\n", "YUV"[kc], sum2/8);
			for(int k=0;k<4;++k)
				printf("   %12.2lf %8.4lf%%\n"
					, csizes[kc][k]/8
					, csizes[kc][k]*sum
				);
			printf("\n");
			//for(int ky=0;ky<BLOCKY;++ky)
			//{
			//	for(int kx=0;kx<BLOCKY;++kx)
			//		printf("  %12.2lf %8.4lf%%"
			//			, csizes[kc][ky*BLOCKX+kx]
			//			, csizes[kc][ky*BLOCKX+kx]*sum
			//		);
			//	printf("\n");
			//}
			//printf("\n");
		}
#endif
#if defined _MSC_VER && 0
		for(int kc=0;kc<3;++kc)
		{
			printf("%c before quant:\n", "YUV"[kc]);
			for(int ky=0;ky<BLOCKY;++ky)
			{
				for(int kx=0;kx<BLOCKY;++kx)
					printf(" %16.0lf", sum_before[kc][BLOCKX*ky+kx]);
				printf("\n");
			}
			printf("\n");
			printf("%c after quant:\n", "YUV"[kc]);
			for(int ky=0;ky<BLOCKY;++ky)
			{
				for(int kx=0;kx<BLOCKY;++kx)
					printf(" %16.0lf", sum_after[kc][BLOCKX*ky+kx]);
				printf("\n");
			}
			printf("\n");
		}
#endif
		printf("WH %5d*%5d  \"%s\"\n", iw, ih, srcfn);
		printf("%9td->%9td  %8.4lf%%  %12.6lf:1  BPD %12.6lf\n"
			, usize
			, csize
			, 100.*csize/usize
			, (double)usize/csize
			, 8.*csize/usize
		);
	}
	printf("%c  %12.6lf sec  %12.6lf MB/s  %12.6lf ms/MB\n"
		, 'D'+fwd
		, t
		, usize/(t*1024*1024)
		, t*1024*1024*1000/usize
	);
	if(!fwd)
	{
		double invres=1/((double)iw*ih);
		double rmse[]=
		{
			sqrt(g_sqe[0]*invres),
			sqrt(g_sqe[1]*invres),
			sqrt(g_sqe[2]*invres),
			0,
		};
		rmse[3]=(rmse[0]+rmse[1]+rmse[2])/3;
		double psnr[]=
		{
			-20*log10(rmse[0]/255),
			-20*log10(rmse[1]/255),
			-20*log10(rmse[2]/255),
			-20*log10(rmse[3]/255),
		};
		printf(
			"RMSE  PSNR\n"
			"T %12.6lf  %12.6lf\n"
			"Y %12.6lf  %12.6lf\n"
			"U %12.6lf  %12.6lf\n"
			"V %12.6lf  %12.6lf\n"
			, rmse[3], psnr[3]
			, rmse[0], psnr[0]
			, rmse[1], psnr[1]
			, rmse[2], psnr[2]
		);
	}
#endif
	(void)&time_sec;
	(void)csize;
	return 0;
}
