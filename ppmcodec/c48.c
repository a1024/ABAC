#ifdef _MSC_VER
#	ifndef _CRT_SECURE_NO_WARNINGS
#		define _CRT_SECURE_NO_WARNINGS
#	endif
#elif defined __linux__ && !defined _GNU_SOURCE
#	define _GNU_SOURCE
#	include<stddef.h>//ptrdiff_t
#endif
#include<stdint.h>
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<stdarg.h>
#define _USE_MATH_DEFINES
#include<math.h>
#include<sys/stat.h>
#if defined _MSC_VER || defined _WIN32
#define WIN32_LEAN_AND_MEAN
#include<Windows.h>
#else
#include<time.h>
#endif
#include<immintrin.h>


#ifdef _MSC_VER
	#define LOUD
	#define PROFILE_SIZE
	#define ENABLE_GUIDE
	#define FIFOVAL
#endif


	#define USE_L1


#define PREDLIST\
	PRED(N)\
	PRED(W)\
	PRED(2*N-NN)\
	PRED(2*W-WW)\
	PRED(3*(N-NN)+NNN)\
	PRED(3*(W-WW)+WWW)\
	PRED(N+W-NW)\

//c32
#if 0
#define PREDLIST\
	PRED(N)\
	PRED(W)\
	PRED(3*(N-NN)+NNN)\
	PRED(3*(W-WW)+WWW)\
	PRED(W+NE-N)\
	PRED((WWWW+WWW+NNN+NEE+NEEE+NEEEE-2*NW)/4)\
	PRED(N+W-NW)\
	PRED(N+NE-NNE)\

#endif

enum
{
	DCTsize32,
	DCTsize16,
	DCTsize8,
	DCTsize4,

	BLOCK0X=32,
	BLOCK0Y=32,
	BLOCK1X=16,
	BLOCK1Y=16,
	BLOCK2X=8,
	BLOCK2Y=8,
	BLOCK3X=4,
	BLOCK3Y=4,

	SHIFT=18,
#define PRED(...) +1
	NPREDS=PREDLIST,
#undef  PRED

	//XPAD=8,
	//NCH=3,
	//NROWS=4,
	//NVAL=2,

	GRBITS=3,

	NCTX_DC=18,
	NCTX_AC=32,
	NCTX=NCTX_DC+NCTX_AC,
	NLEVELS=512,
};

//runtime
#if 1
#define CLAMP2(X, LO, HI)\
	do\
	{\
		if((X)<(LO))X=LO;\
		if((X)>(HI))X=HI;\
	}while(0)
#ifdef _MSC_VER
#	define	ALIGN(N) __declspec(align(N))
#	define AWM_INLINE __forceinline static
#else
#	define	ALIGN(N) __attribute__((aligned(N)))
#	define AWM_INLINE __attribute__((always_inline)) inline static
#	ifndef _countof
#		define _countof(A) (sizeof(A)/sizeof(*(A)))
#	endif
#endif
#if defined _M_X64 || defined __x86_64__
#define FLOOR_LOG2(X)\
	(sizeof(X)==8?63-(int32_t)_lzcnt_u64(X):31-_lzcnt_u32((uint32_t)(X)))
#else
AWM_INLINE int floor_log2_64(uint64_t n)
{
	int	logn=-!n;
	int	sh=(n>=1ULL<<32)<<5;	logn+=sh, n>>=sh;
		sh=(n>=1<<16)<<4;	logn+=sh, n>>=sh;
		sh=(n>=1<< 8)<<3;	logn+=sh, n>>=sh;
		sh=(n>=1<< 4)<<2;	logn+=sh, n>>=sh;
		sh=(n>=1<< 2)<<1;	logn+=sh, n>>=sh;
		sh= n>=1<< 1;		logn+=sh;
	return logn;
}
AWM_INLINE int floor_log2_32(uint32_t n)
{
	int	logn=-!n;
	int	sh=(n>=1<<16)<<4;	logn+=sh, n>>=sh;
		sh=(n>=1<< 8)<<3;	logn+=sh, n>>=sh;
		sh=(n>=1<< 4)<<2;	logn+=sh, n>>=sh;
		sh=(n>=1<< 2)<<1;	logn+=sh, n>>=sh;
		sh= n>=1<< 1;		logn+=sh;
	return logn;
}
#define FLOOR_LOG2(X)\
	(sizeof(X)==8?floor_log2_64(X):floor_log2_32((uint32_t)(X)))
#endif
#define CVTFP32_I32(X)  _mm_cvt_ss2si(_mm_set_ss(X))
#define CVTTFP32_I32(X) _mm_cvtt_ss2si(_mm_set_ss(X))
#define CVTFP64_I64(X)  _mm_cvtsd_si64(_mm_set_sd(X))
#define CVTTFP64_I64(X) _mm_cvttsd_si64(_mm_set_sd(X))
static void crash(const char *file, int line, const char *format, ...)
{
	printf("%s(%d):\n", file, line);
	if(format)
	{
		va_list args;
		va_start(args, format);
		vprintf(format, args);
		va_end(args);
	}
	printf("\n");
	exit(1);
}
#define CRASH(FORMAT, ...) crash(__FILE__, __LINE__, FORMAT,##__VA_ARGS__)
static double time_sec(void)
{
#ifdef _WIN32
	static long long t0=0;
	LARGE_INTEGER li;
	double t;
	QueryPerformanceCounter(&li);
	if(!t0)
		t0=li.QuadPart;
	t=(double)(li.QuadPart-t0);
	QueryPerformanceFrequency(&li);
	t/=(double)li.QuadPart;
	return t;
#else
	struct timespec t;
	clock_gettime(CLOCK_REALTIME, &t);//<time.h>
	return t.tv_sec+t.tv_nsec*1e-9;
#endif
}
#ifdef ENABLE_GUIDE
static int g_iw=0, g_ih=0;
static uint8_t *g_image=0;
static double g_sqe[3]={0};
static void guide_save(uint8_t *image, int iw, int ih)
{
	int size=3*iw*ih;
	g_iw=iw;
	g_ih=ih;
	g_image=(uint8_t*)malloc(size);
	if(!g_image)
	{
		CRASH("Alloc error");
		return;
	}
	memcpy(g_image, image, size);
}
#endif
#endif


#ifdef _MSC_VER
static int ctx_ctr=0, renorm_ctr=0;
#endif
#ifdef FIFOVAL
static ptrdiff_t fifoidx=0, fifocap=0, fifoidx2=0;
static uint32_t *fifoval=0;
static void valfifo_enqueue(uint32_t val)
{
	if(fifoidx+1>=fifocap)
	{
		void *p=0;

		if(!fifocap)
			fifocap=1;
		fifocap<<=1;
		p=realloc(fifoval, fifocap*sizeof(uint32_t));
		if(!p)
		{
			CRASH("Alloc error");
			return;
		}
		fifoval=(uint32_t*)p;
	}
	fifoval[fifoidx++]=val;
}
static void valfifo_check(uint32_t val)
{
	uint32_t val0=fifoval[fifoidx2++];
	if(val!=val0)
	{
		--fifoidx2;
		printf(
			"\n"
			"FIFO Error  at %10lld,  remaining %10lld\n"
			"    0x%08X  !=  original 0x%08X\n"
			"\n"
			, fifoidx2
			, fifoidx-fifoidx2//current element was not decoded successfully
			, val, val0
		);
		for(int k=-32;k<32;++k)
		{
			ptrdiff_t idx=fifoidx2+k;
			if((size_t)idx<(size_t)fifoidx)
			{
				printf(
					"%10td  0x%08X"
					, idx
					, fifoval[idx]
				);
				if(idx<fifoidx2)
					printf("  OK");
				if(idx==fifoidx2)
					printf("  !=  corrupt 0x%08X", val);
				printf("\n");
			}
		}
		CRASH("");
	}
}
#endif


#if defined _MSC_VER && 0
static double sum_before[3][BLOCK0X*BLOCK0Y], sum_after[3][BLOCK0X*BLOCK0Y];
#endif
#if 1
static const float qtable0[3][BLOCK0X*BLOCK0Y]=
{
	{
	    32074.413f,      807.443f,      361.422f,      223.163f,      153.069f,      112.586f,       85.873f,       67.846f,       56.378f,       47.182f,       40.048f,       34.593f,       30.547f,       27.104f,       24.365f,       21.986f,       20.338f,       18.800f,       17.378f,       16.191f,       15.175f,       14.425f,       13.500f,       12.657f,       11.926f,       11.290f,       10.725f,       10.470f,        9.999f,        9.784f,        9.256f,       10.741f,
	      682.631f,      335.574f,      215.648f,      149.099f,      109.931f,       83.809f,       66.305f,       53.594f,       44.805f,       38.194f,       33.496f,       29.522f,       26.280f,       23.632f,       21.442f,       19.562f,       18.054f,       16.804f,       15.690f,       14.628f,       13.826f,       13.041f,       12.370f,       11.750f,       11.206f,       10.629f,       10.134f,        9.788f,        9.372f,        9.110f,        8.840f,        8.756f,
	      313.308f,      205.303f,      153.014f,      115.250f,       89.046f,       70.161f,       56.610f,       46.772f,       39.601f,       34.265f,       30.211f,       26.908f,       24.228f,       21.971f,       20.056f,       18.420f,       17.080f,       15.982f,       14.974f,       14.093f,       13.301f,       12.653f,       11.991f,       11.426f,       10.857f,       10.354f,        9.959f,        9.529f,        9.201f,        8.942f,        8.694f,        8.567f,
	      195.965f,      139.035f,      111.074f,       89.425f,       72.443f,       58.987f,       48.877f,       41.228f,       35.478f,       31.115f,       27.974f,       25.234f,       22.666f,       20.652f,       18.967f,       17.555f,       16.362f,       15.341f,       14.456f,       13.628f,       12.899f,       12.289f,       11.699f,       11.166f,       10.625f,       10.213f,        9.775f,        9.407f,        9.046f,        8.793f,        8.581f,        8.487f,
	      136.025f,      102.072f,       84.556f,       71.035f,       59.645f,       50.182f,       42.630f,       36.734f,       32.275f,       28.632f,       26.615f,       24.290f,       21.494f,       19.536f,       18.084f,       16.804f,       15.700f,       14.778f,       13.980f,       13.272f,       12.630f,       12.031f,       11.470f,       10.941f,       10.430f,       10.000f,        9.594f,        9.260f,        8.901f,        8.657f,        8.450f,        8.420f,
	      100.575f,       77.338f,       65.894f,       56.971f,       49.371f,       42.788f,       37.335f,       32.862f,       29.328f,       26.335f,       24.406f,       22.422f,       20.175f,       18.551f,       17.280f,       16.131f,       15.112f,       14.330f,       13.597f,       12.918f,       12.333f,       11.761f,       11.249f,       10.730f,       10.263f,        9.855f,        9.444f,        9.101f,        8.772f,        8.555f,        8.364f,        8.253f,
	       77.904f,       61.265f,       52.945f,       46.608f,       41.525f,       36.845f,       32.861f,       29.455f,       26.687f,       24.285f,       22.293f,       20.490f,       18.958f,       17.647f,       16.516f,       15.512f,       14.636f,       13.931f,       13.205f,       12.605f,       11.992f,       11.475f,       10.998f,       10.538f,       10.065f,        9.672f,        9.319f,        9.001f,        8.638f,        8.379f,        8.220f,        8.065f,
	       61.911f,       49.556f,       43.465f,       38.945f,       35.425f,       32.111f,       29.194f,       26.625f,       24.395f,       22.461f,       20.845f,       19.346f,       17.992f,       16.850f,       15.838f,       14.951f,       14.169f,       13.449f,       12.858f,       12.253f,       11.699f,       11.293f,       10.751f,       10.333f,        9.880f,        9.488f,        9.112f,        8.793f,        8.514f,        8.265f,        8.049f,        7.912f,
	       50.836f,       41.518f,       36.776f,       33.534f,       30.981f,       28.521f,       26.218f,       24.194f,       22.432f,       20.882f,       19.586f,       18.346f,       17.106f,       16.113f,       15.257f,       14.442f,       13.720f,       13.122f,       12.537f,       12.018f,       11.470f,       11.073f,       10.608f,       10.112f,        9.725f,        9.327f,        9.001f,        8.665f,        8.355f,        8.119f,        7.951f,        7.855f,
	       42.741f,       35.477f,       31.873f,       29.361f,       27.424f,       25.461f,       23.727f,       22.107f,       20.764f,       19.451f,       18.343f,       17.277f,       16.244f,       15.412f,       14.656f,       13.971f,       13.310f,       12.748f,       12.236f,       11.668f,       11.208f,       10.872f,       10.367f,        9.946f,        9.565f,        9.201f,        8.825f,        8.492f,        8.249f,        7.993f,        7.811f,        7.756f,
	       36.670f,       31.250f,       28.210f,       26.752f,       26.256f,       24.120f,       21.683f,       20.425f,       19.369f,       18.317f,       17.233f,       16.299f,       15.499f,       14.771f,       14.155f,       13.468f,       13.020f,       12.690f,       12.001f,       11.406f,       10.980f,       10.586f,       10.177f,        9.762f,        9.379f,        9.000f,        8.681f,        8.406f,        8.116f,        7.884f,        7.692f,        7.550f,
	       31.962f,       27.817f,       25.262f,       24.255f,       24.226f,       22.222f,       19.919f,       18.944f,       18.102f,       17.250f,       16.225f,       15.467f,       14.809f,       14.164f,       13.581f,       13.028f,       12.627f,       12.389f,       11.731f,       11.162f,       10.758f,       10.380f,        9.966f,        9.581f,        9.215f,        8.809f,        8.587f,        8.233f,        7.965f,        7.772f,        7.568f,        7.437f,
	       28.315f,       24.770f,       22.742f,       21.450f,       20.723f,       19.539f,       18.322f,       17.498f,       16.783f,       16.094f,       15.375f,       14.723f,       14.119f,       13.551f,       13.088f,       12.573f,       12.123f,       11.756f,       11.307f,       10.886f,       10.456f,       10.186f,        9.741f,        9.370f,        9.027f,        8.657f,        8.335f,        8.055f,        7.804f,        7.611f,        7.379f,        7.302f,
	       25.248f,       22.316f,       20.670f,       19.509f,       18.574f,       17.799f,       17.056f,       16.372f,       15.769f,       15.156f,       14.590f,       14.019f,       13.508f,       13.050f,       12.622f,       12.171f,       11.716f,       11.323f,       10.963f,       10.603f,       10.231f,        9.919f,        9.612f,        9.158f,        8.797f,        8.469f,        8.230f,        7.876f,        7.642f,        7.443f,        7.285f,        7.161f,
	       22.786f,       20.281f,       18.916f,       17.945f,       17.236f,       16.583f,       15.926f,       15.361f,       14.856f,       14.359f,       13.896f,       13.428f,       12.963f,       12.549f,       12.163f,       11.767f,       11.352f,       11.025f,       10.698f,       10.278f,        9.973f,        9.637f,        9.346f,        8.947f,        8.570f,        8.249f,        8.053f,        7.709f,        7.454f,        7.259f,        7.079f,        6.992f,
	       20.619f,       18.507f,       17.458f,       16.597f,       15.989f,       15.450f,       14.947f,       14.525f,       14.082f,       13.621f,       13.265f,       12.809f,       12.470f,       12.075f,       11.720f,       11.351f,       11.028f,       10.672f,       10.370f,       10.041f,        9.680f,        9.386f,        9.069f,        8.746f,        8.399f,        8.104f,        7.806f,        7.511f,        7.321f,        7.114f,        6.991f,        6.836f,
	       19.102f,       17.116f,       16.212f,       15.483f,       14.982f,       14.506f,       14.087f,       13.714f,       13.343f,       13.002f,       12.739f,       12.395f,       11.997f,       11.622f,       11.337f,       10.996f,       10.731f,       10.375f,       10.063f,        9.738f,        9.439f,        9.126f,        8.792f,        8.523f,        8.165f,        7.859f,        7.572f,        7.338f,        7.092f,        6.923f,        6.776f,        6.672f,
	       17.678f,       16.007f,       15.241f,       14.601f,       14.120f,       13.739f,       13.400f,       13.075f,       12.808f,       12.481f,       12.300f,       12.008f,       11.564f,       11.237f,       10.955f,       10.669f,       10.353f,       10.126f,        9.820f,        9.504f,        9.158f,        8.893f,        8.584f,        8.271f,        8.020f,        7.654f,        7.430f,        7.200f,        6.944f,        6.714f,        6.607f,        6.529f,
	       16.339f,       14.964f,       14.266f,       13.758f,       13.405f,       13.055f,       12.798f,       12.492f,       12.182f,       11.953f,       11.727f,       11.482f,       11.148f,       10.877f,       10.598f,       10.319f,       10.026f,        9.774f,        9.493f,        9.215f,        8.894f,        8.669f,        8.364f,        7.993f,        7.725f,        7.459f,        7.208f,        6.919f,        6.722f,        6.498f,        6.368f,        6.326f,
	       15.397f,       14.059f,       13.461f,       13.006f,       12.654f,       12.442f,       12.133f,       11.923f,       11.638f,       11.428f,       11.208f,       10.943f,       10.710f,       10.461f,       10.231f,        9.956f,        9.730f,        9.441f,        9.245f,        8.978f,        8.685f,        8.329f,        8.069f,        7.767f,        7.536f,        7.206f,        6.920f,        6.749f,        6.516f,        6.358f,        6.218f,        6.098f,
	       14.564f,       13.294f,       12.788f,       12.366f,       12.096f,       11.837f,       11.629f,       11.373f,       11.221f,       10.985f,       10.779f,       10.574f,       10.374f,       10.111f,        9.871f,        9.620f,        9.409f,        9.137f,        8.883f,        8.617f,        8.364f,        8.063f,        7.797f,        7.549f,        7.306f,        6.981f,        6.716f,        6.455f,        6.307f,        6.183f,        5.959f,        5.957f,
	       13.875f,       12.649f,       12.147f,       11.814f,       11.673f,       11.345f,       11.103f,       10.932f,       10.842f,       10.627f,       10.408f,       10.164f,       10.003f,        9.911f,        9.548f,        9.324f,        9.039f,        8.874f,        8.602f,        8.308f,        8.057f,        7.830f,        7.535f,        7.282f,        6.999f,        6.791f,        6.509f,        6.312f,        6.086f,        5.902f,        5.766f,        5.708f,
	       13.053f,       11.960f,       11.546f,       11.238f,       11.049f,       10.858f,       10.611f,       10.477f,       10.366f,       10.193f,        9.963f,        9.780f,        9.633f,        9.456f,        9.208f,        8.954f,        8.752f,        8.526f,        8.288f,        8.006f,        7.786f,        7.531f,        7.254f,        7.064f,        6.748f,        6.485f,        6.262f,        6.063f,        5.854f,        5.710f,        5.593f,        5.443f,
	       12.156f,       11.294f,       10.961f,       10.750f,       10.500f,       10.335f,       10.215f,       10.010f,        9.845f,        9.724f,        9.540f,        9.377f,        9.199f,        9.025f,        8.842f,        8.621f,        8.416f,        8.213f,        7.961f,        7.732f,        7.471f,        7.228f,        6.956f,        6.755f,        6.487f,        6.243f,        6.020f,        5.856f,        5.634f,        5.506f,        5.367f,        5.322f,
	       11.411f,       10.743f,       10.467f,       10.255f,       10.078f,        9.894f,        9.739f,        9.624f,        9.500f,        9.341f,        9.138f,        9.015f,        8.799f,        8.663f,        8.478f,        8.277f,        8.053f,        7.870f,        7.653f,        7.472f,        7.209f,        6.982f,        6.704f,        6.505f,        6.236f,        6.026f,        5.770f,        5.655f,        5.399f,        5.289f,        5.236f,        5.109f,
	       10.882f,       10.269f,       10.007f,        9.876f,        9.702f,        9.564f,        9.382f,        9.214f,        9.080f,        8.963f,        8.828f,        8.628f,        8.537f,        8.339f,        8.199f,        7.982f,        7.766f,        7.616f,        7.386f,        7.160f,        6.966f,        6.678f,        6.478f,        6.241f,        6.017f,        5.786f,        5.585f,        5.398f,        5.219f,        5.159f,        5.015f,        4.929f,
	       10.313f,        9.813f,        9.620f,        9.430f,        9.295f,        9.146f,        9.050f,        8.927f,        8.767f,        8.654f,        8.478f,        8.355f,        8.218f,        8.061f,        7.900f,        7.705f,        7.503f,        7.323f,        7.070f,        6.892f,        6.713f,        6.448f,        6.195f,        6.044f,        5.771f,        5.584f,        5.354f,        5.258f,        5.082f,        5.005f,        4.848f,        4.854f,
	       10.068f,        9.432f,        9.223f,        9.095f,        8.964f,        8.845f,        8.726f,        8.595f,        8.448f,        8.299f,        8.176f,        8.048f,        7.863f,        7.778f,        7.591f,        7.532f,        7.222f,        7.078f,        6.886f,        6.665f,        6.450f,        6.212f,        6.008f,        5.783f,        5.586f,        5.412f,        5.188f,        5.100f,        4.937f,        4.785f,        4.713f,        4.652f,
		9.641f,        9.098f,        8.935f,        8.769f,        8.639f,        8.548f,        8.389f,        8.275f,        8.153f,        8.060f,        7.905f,        7.794f,        7.639f,        7.525f,        7.379f,        7.196f,        6.998f,        6.849f,        6.651f,        6.495f,        6.245f,        6.043f,        5.817f,        5.600f,        5.436f,        5.248f,        5.073f,        4.995f,        4.826f,        4.723f,        4.653f,        4.561f,
		9.423f,        8.862f,        8.685f,        8.539f,        8.468f,        8.316f,        8.161f,        8.068f,        7.947f,        7.815f,        7.699f,        7.572f,        7.467f,        7.347f,        7.149f,        7.038f,        6.885f,        6.671f,        6.508f,        6.251f,        6.050f,        5.851f,        5.667f,        5.453f,        5.262f,        5.127f,        4.959f,        4.822f,        4.734f,        4.624f,        4.552f,        4.558f,
		9.043f,        8.643f,        8.471f,        8.341f,        8.239f,        8.107f,        8.028f,        7.884f,        7.832f,        7.663f,        7.523f,        7.462f,        7.279f,        7.122f,        7.008f,        6.849f,        6.723f,        6.567f,        6.321f,        6.111f,        5.962f,        5.783f,        5.543f,        5.352f,        5.177f,        4.990f,        4.844f,        4.724f,        4.638f,        4.576f,        4.440f,        4.390f,
	       10.361f,        8.549f,        8.409f,        8.308f,        8.366f,        8.150f,        7.869f,        7.803f,        7.791f,        7.645f,        7.433f,        7.296f,        7.203f,        7.038f,        6.897f,        6.770f,        6.637f,        6.435f,        6.262f,        6.051f,        5.893f,        5.658f,        5.469f,        5.263f,        5.073f,        4.926f,        4.782f,        4.708f,        4.580f,        4.487f,        4.395f,        4.479f,
	},
	{
	     3299.740f,      181.967f,       86.284f,       56.019f,       40.779f,       32.026f,       26.112f,       22.054f,       19.303f,       16.901f,       14.873f,       13.336f,       12.082f,       10.991f,        9.984f,        9.122f,        8.347f,        7.714f,        7.154f,        6.566f,        6.088f,        5.623f,        5.151f,        4.733f,        4.356f,        3.995f,        3.691f,        3.446f,        3.228f,        3.079f,        2.938f,        2.957f,
	      146.837f,       77.303f,       52.502f,       38.584f,       30.541f,       25.170f,       21.392f,       18.545f,       16.368f,       14.576f,       13.125f,       11.903f,       10.837f,        9.907f,        9.092f,        8.348f,        7.657f,        7.070f,        6.541f,        5.996f,        5.530f,        5.113f,        4.706f,        4.343f,        4.004f,        3.713f,        3.448f,        3.218f,        3.032f,        2.886f,        2.772f,        2.699f,
	       72.256f,       49.624f,       38.804f,       31.058f,       25.756f,       21.897f,       19.011f,       16.766f,       14.953f,       13.459f,       12.207f,       11.139f,       10.188f,        9.353f,        8.599f,        7.917f,        7.274f,        6.735f,        6.235f,        5.729f,        5.293f,        4.874f,        4.509f,        4.168f,        3.857f,        3.569f,        3.315f,        3.111f,        2.935f,        2.800f,        2.701f,        2.635f,
	       47.594f,       35.859f,       30.173f,       25.624f,       22.075f,       19.309f,       17.070f,       15.231f,       13.747f,       12.467f,       11.346f,       10.398f,        9.557f,        8.792f,        8.123f,        7.496f,        6.898f,        6.404f,        5.929f,        5.468f,        5.062f,        4.679f,        4.330f,        4.004f,        3.717f,        3.456f,        3.218f,        3.020f,        2.861f,        2.732f,        2.640f,        2.577f,
	       35.601f,       28.229f,       24.647f,       21.729f,       19.277f,       17.193f,       15.445f,       13.947f,       12.650f,       11.537f,       10.580f,        9.699f,        8.946f,        8.262f,        7.636f,        7.055f,        6.513f,        6.055f,        5.622f,        5.189f,        4.810f,        4.469f,        4.150f,        3.850f,        3.566f,        3.325f,        3.113f,        2.927f,        2.786f,        2.666f,        2.582f,        2.525f,
	       28.279f,       23.292f,       20.808f,       18.760f,       17.013f,       15.431f,       14.019f,       12.780f,       11.683f,       10.683f,        9.831f,        9.053f,        8.365f,        7.723f,        7.158f,        6.627f,        6.139f,        5.710f,        5.311f,        4.927f,        4.581f,        4.263f,        3.956f,        3.687f,        3.435f,        3.206f,        3.009f,        2.840f,        2.710f,        2.598f,        2.526f,        2.470f,
	       23.374f,       19.814f,       17.959f,       16.462f,       15.111f,       13.890f,       12.771f,       11.723f,       10.746f,        9.887f,        9.126f,        8.421f,        7.774f,        7.212f,        6.697f,        6.218f,        5.769f,        5.384f,        5.018f,        4.665f,        4.341f,        4.050f,        3.784f,        3.532f,        3.301f,        3.088f,        2.913f,        2.759f,        2.633f,        2.538f,        2.470f,        2.424f,
	       19.915f,       17.236f,       15.754f,       14.596f,       13.548f,       12.536f,       11.620f,       10.734f,        9.913f,        9.144f,        8.453f,        7.827f,        7.247f,        6.724f,        6.261f,        5.819f,        5.406f,        5.060f,        4.730f,        4.418f,        4.126f,        3.859f,        3.606f,        3.384f,        3.167f,        2.981f,        2.819f,        2.678f,        2.567f,        2.479f,        2.419f,        2.371f,
	       17.442f,       15.212f,       14.033f,       13.082f,       12.211f,       11.391f,       10.575f,        9.834f,        9.121f,        8.430f,        7.819f,        7.260f,        6.741f,        6.275f,        5.840f,        5.451f,        5.086f,        4.752f,        4.468f,        4.169f,        3.912f,        3.662f,        3.441f,        3.234f,        3.047f,        2.879f,        2.727f,        2.604f,        2.506f,        2.428f,        2.367f,        2.328f,
	       15.454f,       13.614f,       12.635f,       11.812f,       11.039f,       10.355f,        9.666f,        9.000f,        8.369f,        7.782f,        7.236f,        6.727f,        6.280f,        5.846f,        5.460f,        5.104f,        4.779f,        4.483f,        4.206f,        3.947f,        3.713f,        3.498f,        3.288f,        3.103f,        2.933f,        2.781f,        2.652f,        2.539f,        2.448f,        2.376f,        2.326f,        2.286f,
	       13.744f,       12.256f,       11.468f,       10.743f,       10.104f,        9.485f,        8.866f,        8.296f,        7.748f,        7.223f,        6.738f,        6.278f,        5.875f,        5.510f,        5.145f,        4.829f,        4.520f,        4.246f,        4.002f,        3.763f,        3.555f,        3.349f,        3.165f,        2.993f,        2.843f,        2.701f,        2.580f,        2.480f,        2.399f,        2.334f,        2.284f,        2.250f,
	       12.327f,       11.130f,       10.445f,        9.821f,        9.256f,        8.717f,        8.159f,        7.638f,        7.156f,        6.691f,        6.254f,        5.863f,        5.520f,        5.180f,        4.862f,        4.567f,        4.281f,        4.036f,        3.812f,        3.590f,        3.407f,        3.216f,        3.044f,        2.893f,        2.751f,        2.627f,        2.518f,        2.427f,        2.354f,        2.294f,        2.256f,        2.220f,
	       11.115f,       10.118f,        9.532f,        8.983f,        8.497f,        7.996f,        7.509f,        7.039f,        6.607f,        6.201f,        5.826f,        5.486f,        5.162f,        4.861f,        4.571f,        4.312f,        4.064f,        3.843f,        3.632f,        3.435f,        3.252f,        3.089f,        2.940f,        2.797f,        2.674f,        2.556f,        2.457f,        2.376f,        2.311f,        2.260f,        2.218f,        2.188f,
	       10.093f,        9.278f,        8.753f,        8.281f,        7.833f,        7.369f,        6.953f,        6.513f,        6.128f,        5.767f,        5.427f,        5.137f,        4.849f,        4.580f,        4.327f,        4.092f,        3.870f,        3.669f,        3.478f,        3.298f,        3.136f,        2.980f,        2.840f,        2.718f,        2.598f,        2.499f,        2.404f,        2.331f,        2.272f,        2.224f,        2.186f,        2.158f,
		9.207f,        8.488f,        8.053f,        7.633f,        7.224f,        6.810f,        6.427f,        6.056f,        5.697f,        5.360f,        5.066f,        4.804f,        4.549f,        4.321f,        4.097f,        3.888f,        3.689f,        3.512f,        3.337f,        3.175f,        3.022f,        2.883f,        2.756f,        2.638f,        2.528f,        2.435f,        2.356f,        2.289f,        2.234f,        2.186f,        2.155f,        2.128f,
		8.429f,        7.798f,        7.413f,        7.037f,        6.663f,        6.308f,        5.951f,        5.613f,        5.303f,        4.996f,        4.741f,        4.506f,        4.273f,        4.078f,        3.876f,        3.696f,        3.517f,        3.352f,        3.194f,        3.054f,        2.918f,        2.789f,        2.672f,        2.564f,        2.465f,        2.381f,        2.309f,        2.246f,        2.197f,        2.157f,        2.125f,        2.102f,
		7.722f,        7.156f,        6.814f,        6.489f,        6.155f,        5.838f,        5.521f,        5.225f,        4.937f,        4.664f,        4.427f,        4.216f,        4.016f,        3.842f,        3.666f,        3.503f,        3.358f,        3.204f,        3.073f,        2.938f,        2.812f,        2.700f,        2.593f,        2.493f,        2.410f,        2.330f,        2.264f,        2.204f,        2.159f,        2.123f,        2.093f,        2.069f,
		7.141f,        6.611f,        6.301f,        6.015f,        5.710f,        5.428f,        5.150f,        4.878f,        4.615f,        4.377f,        4.160f,        3.975f,        3.791f,        3.642f,        3.484f,        3.343f,        3.206f,        3.078f,        2.959f,        2.837f,        2.721f,        2.621f,        2.522f,        2.439f,        2.357f,        2.282f,        2.227f,        2.169f,        2.127f,        2.092f,        2.067f,        2.045f,
		6.519f,        6.060f,        5.775f,        5.521f,        5.271f,        5.018f,        4.769f,        4.523f,        4.301f,        4.085f,        3.900f,        3.719f,        3.572f,        3.434f,        3.303f,        3.171f,        3.052f,        2.945f,        2.841f,        2.734f,        2.637f,        2.541f,        2.453f,        2.374f,        2.303f,        2.237f,        2.179f,        2.133f,        2.095f,        2.060f,        2.039f,        2.017f,
		6.092f,        5.630f,        5.383f,        5.147f,        4.918f,        4.691f,        4.468f,        4.256f,        4.046f,        3.864f,        3.693f,        3.530f,        3.392f,        3.263f,        3.150f,        3.036f,        2.924f,        2.830f,        2.735f,        2.645f,        2.560f,        2.470f,        2.395f,        2.323f,        2.257f,        2.199f,        2.147f,        2.099f,        2.065f,        2.034f,        2.011f,        1.992f,
		5.605f,        5.189f,        4.979f,        4.758f,        4.556f,        4.360f,        4.165f,        3.979f,        3.800f,        3.631f,        3.478f,        3.336f,        3.213f,        3.099f,        2.991f,        2.897f,        2.799f,        2.717f,        2.640f,        2.555f,        2.483f,        2.410f,        2.336f,        2.269f,        2.211f,        2.155f,        2.109f,        2.070f,        2.038f,        2.008f,        1.983f,        1.966f,
		5.219f,        4.818f,        4.611f,        4.423f,        4.258f,        4.080f,        3.901f,        3.728f,        3.573f,        3.422f,        3.291f,        3.166f,        3.053f,        2.952f,        2.859f,        2.778f,        2.686f,        2.618f,        2.544f,        2.471f,        2.409f,        2.348f,        2.286f,        2.224f,        2.172f,        2.123f,        2.077f,        2.041f,        2.008f,        1.986f,        1.963f,        1.949f,
		4.807f,        4.451f,        4.263f,        4.099f,        3.950f,        3.796f,        3.641f,        3.493f,        3.354f,        3.224f,        3.104f,        3.003f,        2.903f,        2.812f,        2.732f,        2.661f,        2.583f,        2.520f,        2.453f,        2.399f,        2.340f,        2.286f,        2.237f,        2.184f,        2.137f,        2.088f,        2.047f,        2.012f,        1.982f,        1.961f,        1.939f,        1.924f,
		4.430f,        4.109f,        3.946f,        3.802f,        3.670f,        3.534f,        3.405f,        3.276f,        3.155f,        3.040f,        2.942f,        2.847f,        2.767f,        2.693f,        2.616f,        2.554f,        2.484f,        2.430f,        2.377f,        2.321f,        2.273f,        2.225f,        2.179f,        2.139f,        2.091f,        2.053f,        2.020f,        1.988f,        1.959f,        1.938f,        1.920f,        1.906f,
		4.069f,        3.802f,        3.653f,        3.537f,        3.416f,        3.304f,        3.191f,        3.077f,        2.978f,        2.875f,        2.790f,        2.713f,        2.645f,        2.577f,        2.514f,        2.456f,        2.401f,        2.356f,        2.303f,        2.259f,        2.212f,        2.174f,        2.132f,        2.097f,        2.061f,        2.021f,        1.991f,        1.961f,        1.937f,        1.918f,        1.903f,        1.888f,
		3.763f,        3.533f,        3.409f,        3.296f,        3.198f,        3.098f,        2.998f,        2.908f,        2.817f,        2.737f,        2.663f,        2.596f,        2.533f,        2.478f,        2.425f,        2.377f,        2.323f,        2.281f,        2.243f,        2.200f,        2.162f,        2.127f,        2.090f,        2.058f,        2.026f,        1.998f,        1.965f,        1.939f,        1.919f,        1.897f,        1.884f,        1.871f,
		3.500f,        3.288f,        3.182f,        3.090f,        3.004f,        2.917f,        2.834f,        2.755f,        2.684f,        2.610f,        2.551f,        2.494f,        2.446f,        2.393f,        2.347f,        2.305f,        2.261f,        2.226f,        2.190f,        2.154f,        2.116f,        2.086f,        2.054f,        2.029f,        1.998f,        1.968f,        1.943f,        1.920f,        1.898f,        1.879f,        1.869f,        1.854f,
		3.258f,        3.083f,        2.980f,        2.902f,        2.829f,        2.753f,        2.682f,        2.619f,        2.557f,        2.502f,        2.448f,        2.404f,        2.362f,        2.325f,        2.284f,        2.247f,        2.205f,        2.174f,        2.140f,        2.104f,        2.078f,        2.048f,        2.020f,        1.992f,        1.967f,        1.943f,        1.921f,        1.901f,        1.885f,        1.869f,        1.854f,        1.846f,
		3.078f,        2.916f,        2.839f,        2.767f,        2.700f,        2.636f,        2.577f,        2.526f,        2.470f,        2.420f,        2.381f,        2.338f,        2.301f,        2.268f,        2.228f,        2.195f,        2.162f,        2.134f,        2.105f,        2.075f,        2.045f,        2.015f,        1.994f,        1.968f,        1.945f,        1.927f,        1.905f,        1.885f,        1.868f,        1.856f,        1.842f,        1.833f,
		2.961f,        2.791f,        2.725f,        2.659f,        2.602f,        2.549f,        2.499f,        2.451f,        2.408f,        2.365f,        2.327f,        2.292f,        2.254f,        2.223f,        2.193f,        2.160f,        2.129f,        2.103f,        2.071f,        2.045f,        2.021f,        1.994f,        1.968f,        1.948f,        1.927f,        1.904f,        1.887f,        1.873f,        1.854f,        1.845f,        1.835f,        1.833f,
		2.829f,        2.696f,        2.635f,        2.581f,        2.528f,        2.480f,        2.438f,        2.391f,        2.356f,        2.317f,        2.283f,        2.248f,        2.221f,        2.188f,        2.161f,        2.133f,        2.104f,        2.078f,        2.051f,        2.027f,        2.000f,        1.976f,        1.954f,        1.934f,        1.912f,        1.893f,        1.874f,        1.858f,        1.847f,        1.836f,        1.825f,        1.819f,
		2.864f,        2.631f,        2.572f,        2.522f,        2.484f,        2.440f,        2.395f,        2.353f,        2.322f,        2.288f,        2.253f,        2.225f,        2.194f,        2.166f,        2.141f,        2.108f,        2.084f,        2.056f,        2.034f,        2.008f,        1.985f,        1.964f,        1.940f,        1.922f,        1.899f,        1.883f,        1.864f,        1.852f,        1.839f,        1.836f,        1.818f,        1.866f,
	},
	{
	     2438.960f,      132.731f,       63.043f,       41.169f,       30.211f,       23.810f,       19.402f,       16.423f,       14.458f,       12.793f,       11.410f,       10.303f,        9.379f,        8.550f,        7.771f,        7.114f,        6.503f,        6.019f,        5.573f,        5.130f,        4.756f,        4.398f,        4.048f,        3.727f,        3.444f,        3.174f,        2.948f,        2.767f,        2.605f,        2.472f,        2.377f,        2.378f,
	      105.512f,       56.952f,       39.151f,       29.081f,       23.105f,       19.046f,       16.218f,       14.099f,       12.479f,       11.187f,       10.126f,        9.210f,        8.445f,        7.740f,        7.075f,        6.507f,        5.963f,        5.523f,        5.102f,        4.693f,        4.328f,        3.998f,        3.694f,        3.428f,        3.178f,        2.948f,        2.748f,        2.578f,        2.437f,        2.321f,        2.242f,        2.178f,
	       52.471f,       37.083f,       29.283f,       23.660f,       19.697f,       16.756f,       14.565f,       12.871f,       11.537f,       10.378f,        9.449f,        8.665f,        7.947f,        7.296f,        6.702f,        6.177f,        5.684f,        5.246f,        4.864f,        4.467f,        4.137f,        3.817f,        3.540f,        3.284f,        3.054f,        2.840f,        2.654f,        2.494f,        2.364f,        2.253f,        2.179f,        2.123f,
	       35.123f,       27.171f,       22.936f,       19.646f,       17.003f,       14.863f,       13.161f,       11.760f,       10.645f,        9.656f,        8.845f,        8.124f,        7.480f,        6.875f,        6.336f,        5.838f,        5.382f,        4.987f,        4.628f,        4.269f,        3.941f,        3.663f,        3.392f,        3.160f,        2.942f,        2.746f,        2.567f,        2.416f,        2.296f,        2.199f,        2.125f,        2.075f,
	       26.425f,       21.571f,       18.969f,       16.757f,       14.912f,       13.311f,       11.959f,       10.830f,        9.845f,        9.007f,        8.245f,        7.592f,        6.994f,        6.450f,        5.957f,        5.497f,        5.084f,        4.709f,        4.382f,        4.053f,        3.764f,        3.498f,        3.253f,        3.033f,        2.825f,        2.643f,        2.483f,        2.345f,        2.235f,        2.142f,        2.078f,        2.032f,
	       21.196f,       17.925f,       16.092f,       14.505f,       13.183f,       11.977f,       10.904f,        9.964f,        9.107f,        8.362f,        7.681f,        7.083f,        6.533f,        6.033f,        5.587f,        5.167f,        4.781f,        4.442f,        4.149f,        3.843f,        3.574f,        3.332f,        3.107f,        2.904f,        2.718f,        2.547f,        2.401f,        2.273f,        2.172f,        2.090f,        2.029f,        1.984f,
	       17.656f,       15.309f,       13.933f,       12.789f,       11.731f,       10.818f,        9.944f,        9.162f,        8.405f,        7.752f,        7.158f,        6.607f,        6.114f,        5.649f,        5.236f,        4.851f,        4.492f,        4.189f,        3.911f,        3.641f,        3.400f,        3.172f,        2.969f,        2.780f,        2.614f,        2.454f,        2.320f,        2.206f,        2.111f,        2.041f,        1.984f,        1.945f,
	       15.164f,       13.346f,       12.288f,       11.377f,       10.548f,        9.796f,        9.072f,        8.408f,        7.763f,        7.184f,        6.643f,        6.151f,        5.693f,        5.276f,        4.896f,        4.546f,        4.227f,        3.948f,        3.691f,        3.444f,        3.225f,        3.022f,        2.831f,        2.662f,        2.513f,        2.370f,        2.251f,        2.139f,        2.055f,        1.990f,        1.941f,        1.901f,
	       13.278f,       11.867f,       10.981f,       10.241f,        9.548f,        8.914f,        8.300f,        7.704f,        7.166f,        6.638f,        6.152f,        5.714f,        5.308f,        4.926f,        4.577f,        4.261f,        3.972f,        3.718f,        3.486f,        3.255f,        3.068f,        2.879f,        2.705f,        2.555f,        2.414f,        2.292f,        2.178f,        2.087f,        2.007f,        1.949f,        1.903f,        1.867f,
	       11.869f,       10.638f,        9.895f,        9.295f,        8.672f,        8.131f,        7.590f,        7.074f,        6.586f,        6.143f,        5.691f,        5.291f,        4.937f,        4.591f,        4.276f,        3.988f,        3.729f,        3.497f,        3.294f,        3.090f,        2.914f,        2.749f,        2.591f,        2.455f,        2.328f,        2.212f,        2.119f,        2.035f,        1.966f,        1.903f,        1.865f,        1.834f,
	       10.692f,        9.644f,        9.049f,        8.487f,        7.988f,        7.475f,        6.977f,        6.546f,        6.101f,        5.697f,        5.321f,        4.970f,        4.637f,        4.334f,        4.049f,        3.791f,        3.545f,        3.323f,        3.142f,        2.956f,        2.794f,        2.643f,        2.501f,        2.373f,        2.259f,        2.152f,        2.066f,        1.985f,        1.926f,        1.875f,        1.838f,        1.807f,
		9.663f,        8.811f,        8.273f,        7.786f,        7.338f,        6.879f,        6.451f,        6.029f,        5.641f,        5.286f,        4.954f,        4.639f,        4.352f,        4.083f,        3.825f,        3.584f,        3.365f,        3.170f,        3.000f,        2.832f,        2.683f,        2.541f,        2.415f,        2.296f,        2.193f,        2.100f,        2.018f,        1.946f,        1.889f,        1.847f,        1.810f,        1.783f,
		8.776f,        8.035f,        7.579f,        7.134f,        6.716f,        6.310f,        5.924f,        5.556f,        5.216f,        4.895f,        4.598f,        4.333f,        4.079f,        3.839f,        3.611f,        3.396f,        3.197f,        3.025f,        2.869f,        2.714f,        2.577f,        2.449f,        2.331f,        2.228f,        2.133f,        2.045f,        1.974f,        1.906f,        1.856f,        1.813f,        1.783f,        1.758f,
		7.992f,        7.363f,        6.954f,        6.560f,        6.190f,        5.826f,        5.470f,        5.135f,        4.830f,        4.539f,        4.280f,        4.048f,        3.829f,        3.625f,        3.418f,        3.232f,        3.059f,        2.901f,        2.757f,        2.611f,        2.486f,        2.371f,        2.263f,        2.166f,        2.081f,        2.000f,        1.930f,        1.876f,        1.828f,        1.789f,        1.762f,        1.733f,
		7.251f,        6.732f,        6.375f,        6.038f,        5.700f,        5.369f,        5.062f,        4.764f,        4.485f,        4.221f,        3.989f,        3.783f,        3.593f,        3.416f,        3.242f,        3.077f,        2.923f,        2.778f,        2.649f,        2.517f,        2.403f,        2.290f,        2.195f,        2.108f,        2.026f,        1.952f,        1.893f,        1.841f,        1.797f,        1.759f,        1.732f,        1.709f,
		6.633f,        6.172f,        5.862f,        5.563f,        5.260f,        4.960f,        4.686f,        4.418f,        4.169f,        3.937f,        3.728f,        3.547f,        3.377f,        3.226f,        3.075f,        2.934f,        2.790f,        2.663f,        2.545f,        2.426f,        2.323f,        2.224f,        2.139f,        2.054f,        1.980f,        1.914f,        1.857f,        1.808f,        1.771f,        1.735f,        1.710f,        1.691f,
		6.065f,        5.658f,        5.395f,        5.122f,        4.861f,        4.598f,        4.343f,        4.110f,        3.883f,        3.668f,        3.483f,        3.325f,        3.170f,        3.044f,        2.909f,        2.788f,        2.668f,        2.551f,        2.442f,        2.339f,        2.244f,        2.154f,        2.077f,        2.007f,        1.932f,        1.875f,        1.822f,        1.777f,        1.742f,        1.709f,        1.684f,        1.664f,
		5.627f,        5.228f,        4.979f,        4.737f,        4.497f,        4.274f,        4.044f,        3.830f,        3.626f,        3.442f,        3.277f,        3.126f,        2.999f,        2.884f,        2.761f,        2.661f,        2.551f,        2.453f,        2.359f,        2.265f,        2.177f,        2.099f,        2.021f,        1.956f,        1.894f,        1.838f,        1.788f,        1.748f,        1.716f,        1.688f,        1.664f,        1.648f,
		5.129f,        4.775f,        4.561f,        4.347f,        4.145f,        3.945f,        3.739f,        3.558f,        3.380f,        3.208f,        3.060f,        2.937f,        2.821f,        2.719f,        2.621f,        2.524f,        2.432f,        2.350f,        2.268f,        2.183f,        2.107f,        2.038f,        1.972f,        1.907f,        1.853f,        1.800f,        1.759f,        1.719f,        1.690f,        1.662f,        1.642f,        1.622f,
		4.802f,        4.461f,        4.256f,        4.062f,        3.870f,        3.695f,        3.519f,        3.345f,        3.190f,        3.041f,        2.908f,        2.784f,        2.683f,        2.591f,        2.505f,        2.416f,        2.336f,        2.259f,        2.193f,        2.115f,        2.051f,        1.981f,        1.924f,        1.870f,        1.817f,        1.770f,        1.727f,        1.694f,        1.667f,        1.640f,        1.622f,        1.606f,
		4.423f,        4.105f,        3.928f,        3.756f,        3.605f,        3.437f,        3.285f,        3.131f,        2.989f,        2.866f,        2.742f,        2.638f,        2.550f,        2.464f,        2.386f,        2.312f,        2.240f,        2.169f,        2.111f,        2.049f,        1.988f,        1.933f,        1.879f,        1.830f,        1.780f,        1.737f,        1.702f,        1.670f,        1.642f,        1.622f,        1.601f,        1.584f,
		4.114f,        3.814f,        3.653f,        3.502f,        3.368f,        3.219f,        3.077f,        2.942f,        2.819f,        2.701f,        2.603f,        2.513f,        2.429f,        2.353f,        2.280f,        2.216f,        2.151f,        2.094f,        2.043f,        1.984f,        1.938f,        1.891f,        1.843f,        1.795f,        1.753f,        1.713f,        1.678f,        1.648f,        1.623f,        1.599f,        1.586f,        1.569f,
		3.798f,        3.538f,        3.388f,        3.254f,        3.138f,        3.009f,        2.884f,        2.765f,        2.653f,        2.556f,        2.464f,        2.382f,        2.319f,        2.249f,        2.185f,        2.127f,        2.072f,        2.022f,        1.970f,        1.928f,        1.882f,        1.840f,        1.797f,        1.757f,        1.718f,        1.686f,        1.654f,        1.625f,        1.601f,        1.577f,        1.568f,        1.550f,
		3.513f,        3.271f,        3.142f,        3.027f,        2.917f,        2.805f,        2.706f,        2.602f,        2.504f,        2.419f,        2.341f,        2.272f,        2.211f,        2.151f,        2.095f,        2.041f,        1.996f,        1.951f,        1.908f,        1.866f,        1.829f,        1.794f,        1.756f,        1.722f,        1.688f,        1.657f,        1.631f,        1.605f,        1.581f,        1.567f,        1.552f,        1.534f,
		3.241f,        3.035f,        2.921f,        2.821f,        2.728f,        2.635f,        2.537f,        2.453f,        2.371f,        2.295f,        2.230f,        2.170f,        2.114f,        2.064f,        2.017f,        1.973f,        1.930f,        1.888f,        1.856f,        1.817f,        1.784f,        1.752f,        1.718f,        1.690f,        1.661f,        1.632f,        1.607f,        1.585f,        1.565f,        1.548f,        1.533f,        1.521f,
		3.007f,        2.836f,        2.732f,        2.642f,        2.560f,        2.479f,        2.399f,        2.326f,        2.250f,        2.188f,        2.132f,        2.083f,        2.033f,        1.992f,        1.951f,        1.910f,        1.871f,        1.838f,        1.804f,        1.774f,        1.746f,        1.714f,        1.687f,        1.660f,        1.633f,        1.607f,        1.588f,        1.569f,        1.549f,        1.532f,        1.519f,        1.509f,
		2.808f,        2.655f,        2.560f,        2.484f,        2.409f,        2.339f,        2.277f,        2.212f,        2.153f,        2.096f,        2.047f,        2.000f,        1.961f,        1.928f,        1.890f,        1.854f,        1.822f,        1.791f,        1.765f,        1.735f,        1.709f,        1.681f,        1.658f,        1.634f,        1.611f,        1.590f,        1.570f,        1.550f,        1.533f,        1.519f,        1.509f,        1.495f,
		2.617f,        2.479f,        2.406f,        2.339f,        2.276f,        2.216f,        2.161f,        2.103f,        2.055f,        2.008f,        1.968f,        1.932f,        1.898f,        1.869f,        1.841f,        1.811f,        1.777f,        1.751f,        1.724f,        1.698f,        1.676f,        1.651f,        1.630f,        1.608f,        1.590f,        1.571f,        1.549f,        1.536f,        1.521f,        1.508f,        1.497f,        1.490f,
		2.485f,        2.361f,        2.297f,        2.232f,        2.178f,        2.126f,        2.080f,        2.034f,        1.988f,        1.950f,        1.915f,        1.883f,        1.855f,        1.827f,        1.798f,        1.770f,        1.745f,        1.723f,        1.697f,        1.673f,        1.653f,        1.627f,        1.606f,        1.588f,        1.573f,        1.552f,        1.538f,        1.523f,        1.508f,        1.497f,        1.488f,        1.477f,
		2.387f,        2.273f,        2.210f,        2.153f,        2.102f,        2.059f,        2.017f,        1.975f,        1.934f,        1.902f,        1.872f,        1.843f,        1.818f,        1.787f,        1.764f,        1.742f,        1.718f,        1.695f,        1.672f,        1.649f,        1.631f,        1.610f,        1.594f,        1.572f,        1.556f,        1.539f,        1.525f,        1.507f,        1.498f,        1.491f,        1.479f,        1.476f,
		2.291f,        2.194f,        2.137f,        2.086f,        2.043f,        2.006f,        1.967f,        1.929f,        1.895f,        1.861f,        1.835f,        1.812f,        1.784f,        1.764f,        1.739f,        1.717f,        1.697f,        1.675f,        1.652f,        1.634f,        1.614f,        1.593f,        1.575f,        1.559f,        1.542f,        1.527f,        1.512f,        1.500f,        1.490f,        1.481f,        1.474f,        1.466f,
		2.288f,        2.134f,        2.084f,        2.042f,        2.004f,        1.972f,        1.928f,        1.895f,        1.867f,        1.840f,        1.808f,        1.789f,        1.764f,        1.744f,        1.720f,        1.699f,        1.673f,        1.657f,        1.638f,        1.616f,        1.597f,        1.583f,        1.564f,        1.547f,        1.530f,        1.518f,        1.502f,        1.492f,        1.481f,        1.475f,        1.467f,        1.490f,
	},
};
static const float qtable1[3][BLOCK1X*BLOCK1Y]=
{
	{
	     4673.814f,      252.190f,      125.276f,       77.283f,       53.775f,       39.553f,       30.468f,       24.041f,       19.465f,       16.207f,       13.723f,       11.758f,       10.222f,        8.921f,        7.924f,        7.343f,
	      231.281f,      114.361f,       75.758f,       52.719f,       39.594f,       30.693f,       24.561f,       19.849f,       16.487f,       13.918f,       11.960f,       10.402f,        9.139f,        8.098f,        7.287f,        6.756f,
	      113.629f,       72.873f,       55.064f,       41.862f,       33.090f,       26.845f,       21.948f,       18.012f,       15.155f,       12.966f,       11.272f,        9.903f,        8.758f,        7.813f,        7.064f,        6.590f,
	       70.421f,       49.687f,       40.647f,       33.192f,       27.463f,       22.957f,       19.266f,       16.236f,       13.869f,       12.070f,       10.610f,        9.396f,        8.389f,        7.531f,        6.842f,        6.378f,
	       49.097f,       37.005f,       31.657f,       27.003f,       23.094f,       19.808f,       17.036f,       14.675f,       12.750f,       11.247f,        9.977f,        8.942f,        8.005f,        7.233f,        6.606f,        6.182f,
	       36.173f,       28.627f,       25.352f,       22.245f,       19.518f,       17.156f,       15.046f,       13.245f,       11.737f,       10.480f,        9.403f,        8.478f,        7.651f,        6.935f,        6.353f,        5.962f,
	       28.089f,       22.943f,       20.649f,       18.499f,       16.591f,       14.885f,       13.293f,       11.942f,       10.745f,        9.744f,        8.834f,        8.024f,        7.274f,        6.636f,        6.091f,        5.734f,
	       22.338f,       18.587f,       16.933f,       15.524f,       14.233f,       13.009f,       11.844f,       10.782f,        9.837f,        9.024f,        8.269f,        7.567f,        6.890f,        6.309f,        5.815f,        5.482f,
	       18.126f,       15.424f,       14.240f,       13.216f,       12.297f,       11.451f,       10.590f,        9.746f,        9.002f,        8.342f,        7.696f,        7.081f,        6.494f,        5.956f,        5.514f,        5.208f,
	       15.030f,       13.003f,       12.162f,       11.429f,       10.774f,       10.155f,        9.509f,        8.870f,        8.253f,        7.710f,        7.162f,        6.619f,        6.088f,        5.600f,        5.197f,        4.907f,
	       12.744f,       11.150f,       10.505f,        9.977f,        9.499f,        9.007f,        8.529f,        8.041f,        7.535f,        7.083f,        6.607f,        6.129f,        5.653f,        5.218f,        4.849f,        4.576f,
	       10.827f,        9.626f,        9.163f,        8.774f,        8.421f,        8.040f,        7.655f,        7.260f,        6.845f,        6.473f,        6.052f,        5.628f,        5.214f,        4.812f,        4.470f,        4.221f,
		9.291f,        8.396f,        8.040f,        7.758f,        7.470f,        7.165f,        6.851f,        6.542f,        6.189f,        5.874f,        5.517f,        5.148f,        4.777f,        4.420f,        4.107f,        3.890f,
		8.088f,        7.380f,        7.105f,        6.886f,        6.662f,        6.410f,        6.156f,        5.903f,        5.610f,        5.333f,        5.013f,        4.684f,        4.359f,        4.041f,        3.783f,        3.581f,
		7.093f,        6.549f,        6.328f,        6.160f,        5.981f,        5.774f,        5.575f,        5.355f,        5.104f,        4.871f,        4.586f,        4.283f,        3.994f,        3.726f,        3.505f,        3.335f,
		6.539f,        5.995f,        5.836f,        5.670f,        5.528f,        5.338f,        5.158f,        4.975f,        4.752f,        4.542f,        4.278f,        4.000f,        3.718f,        3.494f,        3.295f,        3.172f,
	},
	{
	      524.043f,       58.516f,       32.419f,       21.201f,       15.260f,       11.601f,        9.154f,        7.390f,        6.084f,        5.067f,        4.236f,        3.527f,        2.922f,        2.403f,        1.989f,        1.735f,
	       53.857f,       30.172f,       21.154f,       15.289f,       11.664f,        9.205f,        7.496f,        6.176f,        5.179f,        4.353f,        3.654f,        3.053f,        2.538f,        2.099f,        1.764f,        1.555f,
	       29.616f,       20.458f,       15.912f,       12.357f,        9.856f,        7.995f,        6.611f,        5.535f,        4.678f,        3.963f,        3.347f,        2.814f,        2.350f,        1.958f,        1.667f,        1.490f,
	       19.388f,       14.448f,       12.003f,        9.901f,        8.201f,        6.842f,        5.751f,        4.874f,        4.159f,        3.553f,        3.027f,        2.563f,        2.160f,        1.823f,        1.575f,        1.429f,
	       13.946f,       10.906f,        9.394f,        8.030f,        6.845f,        5.827f,        4.980f,        4.272f,        3.674f,        3.169f,        2.723f,        2.325f,        1.981f,        1.698f,        1.493f,        1.371f,
	       10.548f,        8.541f,        7.534f,        6.593f,        5.728f,        4.952f,        4.295f,        3.728f,        3.240f,        2.823f,        2.444f,        2.108f,        1.819f,        1.581f,        1.413f,        1.312f,
		8.349f,        6.939f,        6.200f,        5.496f,        4.843f,        4.238f,        3.711f,        3.252f,        2.853f,        2.504f,        2.196f,        1.917f,        1.677f,        1.482f,        1.342f,        1.258f,
		6.753f,        5.711f,        5.160f,        4.624f,        4.116f,        3.647f,        3.220f,        2.846f,        2.522f,        2.239f,        1.981f,        1.751f,        1.553f,        1.392f,        1.277f,        1.207f,
		5.562f,        4.775f,        4.343f,        3.925f,        3.523f,        3.149f,        2.805f,        2.503f,        2.238f,        2.007f,        1.791f,        1.605f,        1.443f,        1.310f,        1.216f,        1.156f,
		4.631f,        3.991f,        3.660f,        3.332f,        3.014f,        2.718f,        2.440f,        2.202f,        1.986f,        1.799f,        1.626f,        1.473f,        1.342f,        1.235f,        1.156f,        1.108f,
		3.899f,        3.375f,        3.102f,        2.844f,        2.596f,        2.356f,        2.140f,        1.947f,        1.775f,        1.625f,        1.486f,        1.363f,        1.256f,        1.169f,        1.105f,        1.063f,
		3.248f,        2.824f,        2.612f,        2.414f,        2.219f,        2.036f,        1.869f,        1.721f,        1.588f,        1.470f,        1.360f,        1.263f,        1.181f,        1.109f,        1.056f,        1.022f,
		2.683f,        2.351f,        2.187f,        2.037f,        1.897f,        1.759f,        1.639f,        1.529f,        1.427f,        1.338f,        1.253f,        1.178f,        1.112f,        1.057f,        1.015f,        0.986f,
		2.230f,        1.960f,        1.838f,        1.732f,        1.633f,        1.538f,        1.452f,        1.374f,        1.300f,        1.232f,        1.167f,        1.108f,        1.057f,        1.014f,        0.979f,        0.956f,
		1.872f,        1.669f,        1.582f,        1.507f,        1.442f,        1.380f,        1.319f,        1.262f,        1.207f,        1.155f,        1.103f,        1.056f,        1.016f,        0.980f,        0.953f,        0.933f,
		1.656f,        1.487f,        1.430f,        1.380f,        1.334f,        1.286f,        1.240f,        1.196f,        1.149f,        1.107f,        1.063f,        1.023f,        0.988f,        0.957f,        0.934f,        0.923f,
	},
	{
	      570.011f,       51.979f,       28.680f,       19.263f,       14.292f,       11.209f,        9.046f,        7.417f,        6.176f,        5.180f,        4.354f,        3.649f,        3.039f,        2.512f,        2.096f,        1.851f,
	       48.659f,       27.251f,       19.415f,       14.401f,       11.318f,        9.187f,        7.612f,        6.333f,        5.319f,        4.488f,        3.780f,        3.176f,        2.653f,        2.210f,        1.872f,        1.663f,
	       26.715f,       18.840f,       15.001f,       11.956f,        9.770f,        8.114f,        6.800f,        5.721f,        4.838f,        4.105f,        3.474f,        2.933f,        2.459f,        2.064f,        1.770f,        1.593f,
	       17.946f,       13.730f,       11.667f,        9.838f,        8.326f,        7.061f,        5.987f,        5.082f,        4.334f,        3.702f,        3.154f,        2.681f,        2.268f,        1.927f,        1.678f,        1.530f,
	       13.301f,       10.663f,        9.368f,        8.177f,        7.080f,        6.095f,        5.224f,        4.484f,        3.857f,        3.318f,        2.850f,        2.441f,        2.089f,        1.801f,        1.593f,        1.471f,
	       10.411f,        8.597f,        7.695f,        6.825f,        6.006f,        5.229f,        4.534f,        3.926f,        3.406f,        2.961f,        2.568f,        2.223f,        1.924f,        1.684f,        1.514f,        1.410f,
		8.415f,        7.083f,        6.403f,        5.730f,        5.090f,        4.490f,        3.933f,        3.436f,        3.006f,        2.638f,        2.312f,        2.025f,        1.781f,        1.583f,        1.440f,        1.356f,
		6.864f,        5.881f,        5.348f,        4.829f,        4.329f,        3.850f,        3.404f,        3.010f,        2.663f,        2.360f,        2.091f,        1.855f,        1.653f,        1.490f,        1.373f,        1.304f,
		5.694f,        4.933f,        4.503f,        4.093f,        3.696f,        3.312f,        2.958f,        2.643f,        2.368f,        2.119f,        1.900f,        1.708f,        1.539f,        1.408f,        1.311f,        1.253f,
		4.764f,        4.131f,        3.793f,        3.470f,        3.152f,        2.849f,        2.567f,        2.320f,        2.100f,        1.903f,        1.729f,        1.573f,        1.438f,        1.332f,        1.251f,        1.203f,
		4.020f,        3.489f,        3.218f,        2.961f,        2.709f,        2.471f,        2.251f,        2.054f,        1.880f,        1.725f,        1.585f,        1.457f,        1.350f,        1.262f,        1.197f,        1.157f,
		3.360f,        2.929f,        2.716f,        2.517f,        2.323f,        2.138f,        1.969f,        1.817f,        1.684f,        1.563f,        1.454f,        1.355f,        1.272f,        1.201f,        1.149f,        1.116f,
		2.793f,        2.443f,        2.282f,        2.132f,        1.987f,        1.852f,        1.729f,        1.619f,        1.518f,        1.427f,        1.344f,        1.269f,        1.203f,        1.148f,        1.106f,        1.078f,
		2.327f,        2.049f,        1.928f,        1.819f,        1.718f,        1.624f,        1.537f,        1.458f,        1.385f,        1.319f,        1.254f,        1.197f,        1.146f,        1.103f,        1.071f,        1.048f,
		1.959f,        1.751f,        1.662f,        1.589f,        1.521f,        1.459f,        1.399f,        1.344f,        1.289f,        1.239f,        1.190f,        1.143f,        1.104f,        1.069f,        1.043f,        1.025f,
		1.743f,        1.563f,        1.504f,        1.453f,        1.408f,        1.361f,        1.316f,        1.273f,        1.229f,        1.188f,        1.147f,        1.109f,        1.074f,        1.046f,        1.024f,        1.013f,
	},
};
static const float qtable2[3][BLOCK2X*BLOCK2Y]=
{
	{
	      683.811f,       60.468f,       31.476f,       19.334f,       13.164f,        9.272f,        6.721f,        4.876f,
	       54.677f,       29.103f,       19.571f,       13.573f,        9.898f,        7.367f,        5.542f,        4.179f,
	       27.460f,       18.451f,       14.095f,       10.664f,        8.209f,        6.373f,        4.922f,        3.806f,
	       16.713f,       12.343f,       10.184f,        8.296f,        6.748f,        5.461f,        4.338f,        3.431f,
	       11.310f,        8.855f,        7.651f,        6.552f,        5.564f,        4.655f,        3.788f,        3.053f,
		7.981f,        6.516f,        5.832f,        5.186f,        4.545f,        3.908f,        3.240f,        2.648f,
		5.793f,        4.879f,        4.456f,        4.054f,        3.634f,        3.183f,        2.681f,        2.222f,
		4.228f,        3.661f,        3.407f,        3.158f,        2.874f,        2.556f,        2.184f,        1.854f,
	},
	{
	      166.718f,       18.145f,        9.876f,        5.948f,        4.015f,        2.686f,        1.851f,        1.262f,
	       17.347f,       10.132f,        6.737f,        4.486f,        3.155f,        2.186f,        1.533f,        1.079f,
		9.331f,        6.559f,        4.888f,        3.532f,        2.574f,        1.849f,        1.326f,        0.965f,
		5.552f,        4.271f,        3.443f,        2.665f,        2.029f,        1.513f,        1.120f,        0.846f,
		3.710f,        2.955f,        2.461f,        1.986f,        1.572f,        1.220f,        0.936f,        0.736f,
		2.459f,        2.021f,        1.740f,        1.456f,        1.199f,        0.968f,        0.774f,        0.634f,
		1.689f,        1.407f,        1.234f,        1.062f,        0.908f,        0.764f,        0.639f,        0.546f,
		1.156f,        0.992f,        0.895f,        0.797f,        0.706f,        0.620f,        0.540f,        0.480f,
	},
	{
	      163.494f,       17.304f,        9.407f,        5.744f,        3.946f,        2.703f,        1.881f,        1.285f,
	       16.843f,        9.776f,        6.508f,        4.391f,        3.137f,        2.215f,        1.567f,        1.102f,
		9.134f,        6.384f,        4.785f,        3.495f,        2.580f,        1.876f,        1.354f,        0.989f,
		5.500f,        4.221f,        3.418f,        2.661f,        2.041f,        1.535f,        1.146f,        0.877f,
		3.732f,        2.962f,        2.473f,        1.999f,        1.590f,        1.243f,        0.967f,        0.775f,
		2.525f,        2.063f,        1.775f,        1.482f,        1.224f,        0.998f,        0.815f,        0.685f,
		1.745f,        1.448f,        1.268f,        1.092f,        0.940f,        0.805f,        0.691f,        0.609f,
		1.192f,        1.021f,        0.924f,        0.830f,        0.748f,        0.672f,        0.604f,        0.555f,
	},
};
static const float qtable3[3][BLOCK3X*BLOCK3Y]=
{
	{
	      104.603f,       16.761f,        9.341f,        5.025f,
	       15.479f,        9.389f,        6.417f,        3.828f,
		8.412f,        6.071f,        4.601f,        2.962f,
		4.519f,        3.516f,        2.845f,        1.973f,
	},
	{
	       39.740f,        5.063f,        2.710f,        1.463f,
		4.985f,        3.066f,        1.965f,        1.182f,
		2.632f,        1.934f,        1.399f,        0.941f,
		1.402f,        1.145f,        0.927f,        0.716f,
	},
	{
	       35.829f,        4.474f,        2.255f,        1.085f,
		4.328f,        2.562f,        1.537f,        0.820f,
		2.159f,        1.508f,        1.015f,        0.605f,
		1.029f,        0.790f,        0.593f,        0.413f,
	},
};
#endif
#if 0
static const float qtable_luma[]=
{
	16, 10, 12, 16,//v15
	10, 10, 16, 24,
	12, 16, 24, 24,
	16, 24, 24, 24,

	//10, 12, 14, 16,//v14
	//12, 20, 32, 32,
	//14, 32, 32, 32,
	//16, 32, 32, 32,

	//10, 24, 28, 32,
	//24, 28, 32, 32,
	//28, 32, 32, 32,
	//32, 32, 32, 32,

	//16, 18, 18, 14,//nice
	//18, 18, 14, 12,
	//18, 14, 12, 12,
	//14, 12, 12, 12,

	//16, 16, 14, 12,//good
	//16, 14, 12, 12,
	//14, 12, 12, 12,
	//12, 12, 12, 12,

	//10, 7, 7, 7,
	// 7, 7, 7, 7,
	// 7, 7, 7, 7,
	// 7, 7, 7, 7,

	//12, 13, 14, 15,
	//13, 14, 15, 16,
	//14, 15, 16, 16,
	//15, 16, 16, 16,

	//12, 12, 14, 16,
	//12, 14, 16, 32,
	//14, 16, 24, 32,
	//16, 32, 32, 32,

	//5, 6, 7, 8,//CRASH overflow
	//6, 7, 8, 9,
	//7, 8, 8, 9,
	//8, 9, 9, 9,

	//5, 3, 4, 5,
	//3, 4, 5, 6,
	//4, 5, 5, 6,
	//5, 6, 6, 6,

	//16, 24, 32, 48,
	//24, 32, 48, 64,
	//32, 48, 48, 64,
	//48, 64, 64, 64,
};
static const float qtable_chroma[]=
{
	16, 10, 12, 12,//v14
	10, 10, 12, 12,
	12, 12, 12, 12,
	12, 12, 12, 12,

	//10, 12, 14, 16,
	//12, 20, 32, 32,
	//14, 32, 32, 32,
	//16, 32, 32, 32,

	//12, 12, 10, 10,
	//12, 10, 10, 10,
	//10, 10, 10, 10,
	//10, 10, 10, 10,

	//12, 12, 13, 13,
	//12, 13, 15, 16,
	//13, 15, 16, 16,
	//13, 16, 16, 16,

	//10, 7, 7, 7,
	// 7, 7, 7, 7,
	// 7, 7, 7, 7,
	// 7, 7, 7, 7,

	//10, 4, 3, 2,
	// 4, 3, 2, 1,
	// 3, 2, 1, 1,
	// 2, 1, 1, 1,

	//12, 13, 14, 15,
	//13, 14, 15, 15,
	//14, 15, 15, 15,
	//15, 15, 15, 15,

	//12, 12, 14, 16,
	//12, 14, 16, 16,
	//14, 16, 16, 16,
	//16, 16, 16, 16,

	//5, 6, 7, 8,//CRASH overflow
	//6, 7, 8, 8,
	//7, 8, 8, 8,
	//8, 8, 8, 8,

	//5, 3, 4, 4,
	//3, 4, 4, 4,
	//4, 4, 4, 4,
	//4, 4, 4, 4,

	//16, 24, 32, 32,
	//24, 32, 32, 32,
	//32, 32, 32, 32,
	//32, 32, 32, 32,
};
#endif
AWM_INLINE void cvti2f(float *block)
{
	__m128i a[4];

	a[0]=_mm_load_si128((__m128i*)block+0);
	a[1]=_mm_load_si128((__m128i*)block+1);
	a[2]=_mm_load_si128((__m128i*)block+2);
	a[3]=_mm_load_si128((__m128i*)block+3);

	_mm_store_ps(block+0*4, _mm_cvtepi32_ps(a[0]));
	_mm_store_ps(block+1*4, _mm_cvtepi32_ps(a[1]));
	_mm_store_ps(block+2*4, _mm_cvtepi32_ps(a[2]));
	_mm_store_ps(block+3*4, _mm_cvtepi32_ps(a[3]));
}
AWM_INLINE void cvtf2i(float *block)
{
	__m128 a[8];

	a[0]=_mm_load_ps(block+0*4);
	a[1]=_mm_load_ps(block+1*4);
	a[2]=_mm_load_ps(block+2*4);
	a[3]=_mm_load_ps(block+3*4);

	_mm_store_si128((__m128i*)block+0, _mm_cvtps_epi32(a[0]));
	_mm_store_si128((__m128i*)block+1, _mm_cvtps_epi32(a[1]));
	_mm_store_si128((__m128i*)block+2, _mm_cvtps_epi32(a[2]));
	_mm_store_si128((__m128i*)block+3, _mm_cvtps_epi32(a[3]));
}
AWM_INLINE void rgb2yuv(float *c0, float *c1, float *c2)
{
	__m128 half=_mm_set1_ps(128);
	for(int k=0;k<4;++k)
	{
		__m128 rgb[3], yuv[3];

		rgb[0]=_mm_load_ps(c0+k*4);
		rgb[1]=_mm_load_ps(c1+k*4);
		rgb[2]=_mm_load_ps(c2+k*4);
		
		//https://en.wikipedia.org/wiki/YCbCr
		yuv[0]=_mm_mul_ps(_mm_set1_ps(+0.299000f), rgb[0]);
		yuv[1]=_mm_mul_ps(_mm_set1_ps(-0.168736f), rgb[0]);
		yuv[2]=_mm_mul_ps(_mm_set1_ps(+0.500000f), rgb[0]);
		yuv[0]=_mm_add_ps(yuv[0], _mm_mul_ps(_mm_set1_ps(+0.587000f), rgb[1]));
		yuv[1]=_mm_add_ps(yuv[1], _mm_mul_ps(_mm_set1_ps(-0.331264f), rgb[1]));
		yuv[2]=_mm_add_ps(yuv[2], _mm_mul_ps(_mm_set1_ps(-0.418688f), rgb[1]));
		yuv[0]=_mm_add_ps(yuv[0], _mm_mul_ps(_mm_set1_ps(+0.114000f), rgb[2]));
		yuv[1]=_mm_add_ps(yuv[1], _mm_mul_ps(_mm_set1_ps(+0.500000f), rgb[2]));
		yuv[2]=_mm_add_ps(yuv[2], _mm_mul_ps(_mm_set1_ps(-0.081312f), rgb[2]));
		
		yuv[0]=_mm_sub_ps(yuv[0], half);
	//	yuv[1]=_mm_add_ps(yuv[1], half);
	//	yuv[2]=_mm_add_ps(yuv[2], half);

		_mm_store_ps(c0+k*4, yuv[0]);
		_mm_store_ps(c1+k*4, yuv[1]);
		_mm_store_ps(c2+k*4, yuv[2]);
	}
}
AWM_INLINE void yuv2rgb(float *c0, float *c1, float *c2)
{
	__m128 half=_mm_set1_ps(128);
	__m128 vmin=_mm_setzero_ps();
	__m128 vmax=_mm_set1_ps(255);
	for(int k=0;k<4;++k)
	{
		__m128 rgb[3], yuv[3];

		yuv[0]=_mm_load_ps(c0+k*4);
		yuv[1]=_mm_load_ps(c1+k*4);
		yuv[2]=_mm_load_ps(c2+k*4);
		
		yuv[0]=_mm_add_ps(yuv[0], half);
	//	yuv[1]=_mm_sub_ps(yuv[1], half);
	//	yuv[2]=_mm_sub_ps(yuv[2], half);

		rgb[1]=_mm_add_ps(yuv[0], _mm_mul_ps(_mm_set1_ps(-0.344136f), yuv[1]));
		rgb[2]=_mm_add_ps(yuv[0], _mm_mul_ps(_mm_set1_ps(+1.772f), yuv[1]));
		rgb[0]=_mm_add_ps(yuv[0], _mm_mul_ps(_mm_set1_ps(+1.402f), yuv[2]));
		rgb[1]=_mm_add_ps(rgb[1], _mm_mul_ps(_mm_set1_ps(-0.714136f), yuv[2]));

		rgb[0]=_mm_min_ps(rgb[0], vmax);
		rgb[1]=_mm_min_ps(rgb[1], vmax);
		rgb[2]=_mm_min_ps(rgb[2], vmax);
		rgb[0]=_mm_max_ps(rgb[0], vmin);
		rgb[1]=_mm_max_ps(rgb[1], vmin);
		rgb[2]=_mm_max_ps(rgb[2], vmin);
		_mm_store_ps(c0+k*4, rgb[0]);
		_mm_store_ps(c1+k*4, rgb[1]);
		_mm_store_ps(c2+k*4, rgb[2]);
	}
}

AWM_INLINE void dct4y4_fwd(float *block)//DCT-II
{
	__m128 c3=_mm_set1_ps(0.3826834323650897717284599840304f);//cosd(90*3/4) = sind(90*1/4) = s1
	__m128 c2=_mm_set1_ps(0.7071067811865475244008443621048f);//cosd(90*2/4) = sind(90*2/4) = s2 = sqrt(2)
	__m128 c1=_mm_set1_ps(0.9238795325112867561281831893968f);//cosd(90*1/4) = sind(90*3/4) = s3

	__m128 a[4], b[4];

	a[0]=_mm_load_ps(block+0*4);
	a[1]=_mm_load_ps(block+1*4);
	a[2]=_mm_load_ps(block+2*4);
	a[3]=_mm_load_ps(block+3*4);

	b[0]=_mm_add_ps(a[0], a[3]);//step 1
	b[1]=_mm_add_ps(a[1], a[2]);
	b[2]=_mm_sub_ps(a[1], a[2]);
	b[3]=_mm_sub_ps(a[0], a[3]);

	a[0]=_mm_add_ps(b[0], b[1]);//step 2
	a[1]=_mm_mul_ps(_mm_sub_ps(b[0], b[1]), c2);
	a[2]=_mm_add_ps(_mm_mul_ps(b[3], c1), _mm_mul_ps(b[2], c3));
	a[3]=_mm_sub_ps(_mm_mul_ps(b[3], c3), _mm_mul_ps(b[2], c1));

	_mm_store_ps(block+0*4, a[0]);
	_mm_store_ps(block+2*4, a[1]);
	_mm_store_ps(block+1*4, a[2]);
	_mm_store_ps(block+3*4, a[3]);
}
AWM_INLINE void dct4y4_inv(float *block)//DCT-III
{
	__m128 half=_mm_set1_ps(0.5f);
	__m128 c3=_mm_set1_ps(0.3826834323650897717284599840304f);//cosd(90*3/4) = sind(90*1/4) = s1
	__m128 c2=_mm_set1_ps(0.7071067811865475244008443621048f);//cosd(90*2/4) = sind(90*2/4) = s2 = sqrt(2)
	__m128 c1=_mm_set1_ps(0.9238795325112867561281831893968f);//cosd(90*1/4) = sind(90*3/4) = s3

	__m128 a[4], b[4];

	a[0]=_mm_load_ps(block+0*4);
	a[1]=_mm_load_ps(block+2*4);
	a[2]=_mm_load_ps(block+1*4);
	a[3]=_mm_load_ps(block+3*4);
	
	/*
	matrix					inverse
	M0 = [1 1;1 -1]				same/2
	M1: [a0;a1] = [1 1;c2 -c2][b0;b1]	[b0;b1] = [1/2 c2;1/2 -c2][a0;a1]
	M2: [a2;a3] = [c3 c1;-c1 c3][b2;b3]	transpose [b2;b3] = [c3 -c1;c1 c3][a2;a3]
	*/
	a[0]=_mm_mul_ps(a[0], half);
	a[1]=_mm_mul_ps(a[1], c2);

	b[0]=_mm_add_ps(a[0], a[1]);//step 2
	b[1]=_mm_sub_ps(a[0], a[1]);
	b[2]=_mm_sub_ps(_mm_mul_ps(a[2], c3), _mm_mul_ps(a[3], c1));
	b[3]=_mm_add_ps(_mm_mul_ps(a[2], c1), _mm_mul_ps(a[3], c3));

	a[0]=_mm_add_ps(b[0], b[3]);//step 1
	a[1]=_mm_add_ps(b[1], b[2]);
	a[2]=_mm_sub_ps(b[1], b[2]);
	a[3]=_mm_sub_ps(b[0], b[3]);

	_mm_store_ps(block+0*4, a[0]);
	_mm_store_ps(block+1*4, a[1]);
	_mm_store_ps(block+2*4, a[2]);
	_mm_store_ps(block+3*4, a[3]);
}
AWM_INLINE void dct8y8_fwd(float *block)//DCT-II
{
	/*
	DCTii8 =

	DCTii4		0
	0		C * DCTii4
	
	where C = diag(cos(pi*1/16), cos(pi*3/16), cos(pi*5/16), cos(pi*7/16))
	*/

	//Chen factorization
	__m256 c7=_mm256_set1_ps(0.1950903220161282678482848684770f);//cosd(90*7/8) = sind(90*1/8) = s1
	__m256 c6=_mm256_set1_ps(0.3826834323650897717284599840304f);//cosd(90*6/8) = sind(90*2/8) = s2
	__m256 c5=_mm256_set1_ps(0.5555702330196022247428308139485f);//cosd(90*5/8) = sind(90*3/8) = s3
	__m256 c4=_mm256_set1_ps(0.7071067811865475244008443621048f);//cosd(90*4/8) = sind(90*4/8) = s4 = sqrt(2)
	__m256 c3=_mm256_set1_ps(0.8314696123025452370787883776179f);//cosd(90*3/8) = sind(90*5/8) = s5
	__m256 c2=_mm256_set1_ps(0.9238795325112867561281831893968f);//cosd(90*2/8) = sind(90*6/8) = s6
	__m256 c1=_mm256_set1_ps(0.9807852804032304491261822361342f);//cosd(90*1/8) = sind(90*7/8) = s7

	__m256 a[8], b[8];

	a[0]=_mm256_load_ps(block+0*8);
	a[1]=_mm256_load_ps(block+1*8);
	a[2]=_mm256_load_ps(block+2*8);
	a[3]=_mm256_load_ps(block+3*8);
	a[4]=_mm256_load_ps(block+4*8);
	a[5]=_mm256_load_ps(block+5*8);
	a[6]=_mm256_load_ps(block+6*8);
	a[7]=_mm256_load_ps(block+7*8);

	b[0]=_mm256_add_ps(a[0], a[7]);//step 1
	b[1]=_mm256_add_ps(a[1], a[6]);
	b[2]=_mm256_add_ps(a[2], a[5]);
	b[3]=_mm256_add_ps(a[3], a[4]);
	b[4]=_mm256_sub_ps(a[3], a[4]);
	b[5]=_mm256_sub_ps(a[2], a[5]);
	b[6]=_mm256_sub_ps(a[1], a[6]);
	b[7]=_mm256_sub_ps(a[0], a[7]);
	
	a[0]=_mm256_add_ps(b[0], b[3]);//step 2
	a[1]=_mm256_add_ps(b[1], b[2]);
	a[2]=_mm256_sub_ps(b[1], b[2]);
	a[3]=_mm256_sub_ps(b[0], b[3]);
	a[4]=b[4];
	a[5]=_mm256_mul_ps(_mm256_sub_ps(b[6], b[5]), c4);//M0
	a[6]=_mm256_mul_ps(_mm256_add_ps(b[6], b[5]), c4);
	a[7]=b[7];
	
	b[0]=_mm256_add_ps(a[0], a[1]);//step 3
	b[1]=_mm256_mul_ps(_mm256_sub_ps(a[0], a[1]), c4);
	b[2]=_mm256_add_ps(_mm256_mul_ps(a[3], c2), _mm256_mul_ps(a[2], c6));//M1
	b[3]=_mm256_sub_ps(_mm256_mul_ps(a[3], c6), _mm256_mul_ps(a[2], c2));
	b[4]=_mm256_add_ps(a[4], a[5]);
	b[5]=_mm256_sub_ps(a[4], a[5]);
	b[6]=_mm256_sub_ps(a[7], a[6]);
	b[7]=_mm256_add_ps(a[7], a[6]);
	
	a[0]=b[0];//step 4
	a[1]=b[1];
	a[2]=b[2];
	a[3]=b[3];
	a[4]=_mm256_add_ps(_mm256_mul_ps(b[7], c1), _mm256_mul_ps(b[4], c7));//M2
	a[5]=_mm256_add_ps(_mm256_mul_ps(b[6], c5), _mm256_mul_ps(b[5], c3));//M3
	a[6]=_mm256_sub_ps(_mm256_mul_ps(b[6], c3), _mm256_mul_ps(b[5], c5));
	a[7]=_mm256_sub_ps(_mm256_mul_ps(b[7], c7), _mm256_mul_ps(b[4], c1));

	_mm256_store_ps(block+0*8, a[0]);
	_mm256_store_ps(block+4*8, a[1]);
	_mm256_store_ps(block+2*8, a[2]);
	_mm256_store_ps(block+6*8, a[3]);
	_mm256_store_ps(block+1*8, a[4]);
	_mm256_store_ps(block+5*8, a[5]);
	_mm256_store_ps(block+3*8, a[6]);
	_mm256_store_ps(block+7*8, a[7]);
}
AWM_INLINE void dct8y8_inv(float *block)//DCT-III
{
	//Chen factorization
	__m256 c7=_mm256_set1_ps(0.1950903220161282678482848684770f);//cosd(90*7/8) = sind(90*1/8) = s1
	__m256 c6=_mm256_set1_ps(0.3826834323650897717284599840304f);//cosd(90*6/8) = sind(90*2/8) = s2
	__m256 c5=_mm256_set1_ps(0.5555702330196022247428308139485f);//cosd(90*5/8) = sind(90*3/8) = s3
	__m256 c4=_mm256_set1_ps(0.7071067811865475244008443621048f);//cosd(90*4/8) = sind(90*4/8) = s4 = sqrt(2)
	__m256 c3=_mm256_set1_ps(0.8314696123025452370787883776179f);//cosd(90*3/8) = sind(90*5/8) = s5
	__m256 c2=_mm256_set1_ps(0.9238795325112867561281831893968f);//cosd(90*2/8) = sind(90*6/8) = s6
	__m256 c1=_mm256_set1_ps(0.9807852804032304491261822361342f);//cosd(90*1/8) = sind(90*7/8) = s7

	__m256 a[8], b[8];

	b[0]=_mm256_load_ps(block+0*8);
	b[1]=_mm256_load_ps(block+4*8);
	b[2]=_mm256_load_ps(block+2*8);
	b[3]=_mm256_load_ps(block+6*8);
	b[4]=_mm256_load_ps(block+1*8);
	b[5]=_mm256_load_ps(block+5*8);
	b[6]=_mm256_load_ps(block+3*8);
	b[7]=_mm256_load_ps(block+7*8);

	/*
	matrix					inverse
	M0 = [c4 c4;c4 -c4]			itself (scaled)
	M1: [a2;a3] = [c6 c2;-c2 c6][b2;b3]	transpose [b2;b3] = [c6 -c2;c2 c6][a2;a3]
	M2: [a4;a7] = [c7 c1;-c1 c7][b4;b7]	transpose [a4;a7] = [c7 -c1;c1 c7][b4;b7]
	M3: [a5;a6] = [c3 c5;-c5 c3][b5;b6]	transpose [a5;a6] = [c3 -c5;c5 c3][b5;b6]
	*/
	a[0]=b[0];//step 4
	a[1]=b[1];
	a[2]=b[2];
	a[3]=b[3];
	a[4]=_mm256_sub_ps(_mm256_mul_ps(b[4], c7), _mm256_mul_ps(b[7], c1));//M2 (transposed)
	a[5]=_mm256_sub_ps(_mm256_mul_ps(b[5], c3), _mm256_mul_ps(b[6], c5));//M3 (transposed)
	a[6]=_mm256_add_ps(_mm256_mul_ps(b[5], c5), _mm256_mul_ps(b[6], c3));
	a[7]=_mm256_add_ps(_mm256_mul_ps(b[4], c1), _mm256_mul_ps(b[7], c7));

	a[0]=_mm256_mul_ps(a[0], _mm256_set1_ps(0.5f));
	a[1]=_mm256_mul_ps(a[1], c4);
	
	b[0]=_mm256_add_ps(a[0], a[1]);//step 3
	b[1]=_mm256_sub_ps(a[0], a[1]);
	b[2]=_mm256_sub_ps(_mm256_mul_ps(a[2], c6), _mm256_mul_ps(a[3], c2));//M1
	b[3]=_mm256_add_ps(_mm256_mul_ps(a[2], c2), _mm256_mul_ps(a[3], c6));
	b[4]=_mm256_add_ps(a[4], a[5]);
	b[5]=_mm256_sub_ps(a[4], a[5]);
	b[6]=_mm256_sub_ps(a[7], a[6]);
	b[7]=_mm256_add_ps(a[7], a[6]);
	
	a[0]=_mm256_add_ps(b[0], b[3]);//step 2
	a[1]=_mm256_add_ps(b[1], b[2]);
	a[2]=_mm256_sub_ps(b[1], b[2]);
	a[3]=_mm256_sub_ps(b[0], b[3]);
	a[4]=b[4];
	a[5]=_mm256_mul_ps(_mm256_sub_ps(b[6], b[5]), c4);//M0
	a[6]=_mm256_mul_ps(_mm256_add_ps(b[6], b[5]), c4);
	a[7]=b[7];
	
	b[0]=_mm256_add_ps(a[0], a[7]);//step 1
	b[1]=_mm256_add_ps(a[1], a[6]);
	b[2]=_mm256_add_ps(a[2], a[5]);
	b[3]=_mm256_add_ps(a[3], a[4]);
	b[4]=_mm256_sub_ps(a[3], a[4]);
	b[5]=_mm256_sub_ps(a[2], a[5]);
	b[6]=_mm256_sub_ps(a[1], a[6]);
	b[7]=_mm256_sub_ps(a[0], a[7]);

	_mm256_store_ps(block+0*8, b[0]);
	_mm256_store_ps(block+1*8, b[1]);
	_mm256_store_ps(block+2*8, b[2]);
	_mm256_store_ps(block+3*8, b[3]);
	_mm256_store_ps(block+4*8, b[4]);
	_mm256_store_ps(block+5*8, b[5]);
	_mm256_store_ps(block+6*8, b[6]);
	_mm256_store_ps(block+7*8, b[7]);
}

AWM_INLINE void dctii_4(float *data, const int stride)
{
	__m128 a[4], b[4];

	a[0]=_mm_load_ps(data+0*stride);
	a[1]=_mm_load_ps(data+1*stride);
	a[2]=_mm_load_ps(data+2*stride);
	a[3]=_mm_load_ps(data+3*stride);

	//Hbar		Add/SubReverse
	b[0]=_mm_add_ps(a[0], a[3]);
	b[1]=_mm_add_ps(a[1], a[2]);
	b[2]=_mm_sub_ps(a[0], a[3]);
	b[3]=_mm_sub_ps(a[1], a[2]);
	//b[0]=_mm_mul_ps(b[0], _mm_set1_ps(0.7071067811865475244008443621048f));
	//b[1]=_mm_mul_ps(b[1], _mm_set1_ps(0.7071067811865475244008443621048f));
	//b[2]=_mm_mul_ps(b[2], _mm_set1_ps(0.7071067811865475244008443621048f));
	//b[3]=_mm_mul_ps(b[3], _mm_set1_ps(0.7071067811865475244008443621048f));

	//Wc		Multiply
	b[2]=_mm_mul_ps(b[2], _mm_set1_ps(0.5411961001461969843997232053664f));//0.5 sec( 1 pi/(2*4))
	b[3]=_mm_mul_ps(b[3], _mm_set1_ps(1.3065629648763765278566431734272f));//0.5 sec( 3 pi/(2*4))

	//two half-DCTIIs
	a[0]=_mm_add_ps(b[0], b[1]);
	a[1]=_mm_sub_ps(b[0], b[1]);
	a[2]=_mm_add_ps(b[2], b[3]);
	a[3]=_mm_sub_ps(b[2], b[3]);
	//a[0]=_mm_mul_ps(a[0], _mm_set1_ps(0.7071067811865475244008443621048f));
	//a[1]=_mm_mul_ps(a[1], _mm_set1_ps(0.7071067811865475244008443621048f));
	//a[2]=_mm_mul_ps(a[2], _mm_set1_ps(0.7071067811865475244008443621048f));
	//a[3]=_mm_mul_ps(a[3], _mm_set1_ps(0.7071067811865475244008443621048f));

	//Bc		B
	a[2]=_mm_add_ps(_mm_mul_ps(a[2], _mm_set1_ps(1.4142135623730950488016887242097f)), a[3]);//sqrt2

	//PeoT
	_mm_store_ps(data+0*stride, a[0]);
	_mm_store_ps(data+1*stride, a[2]);
	_mm_store_ps(data+2*stride, a[1]);
	_mm_store_ps(data+3*stride, a[3]);
}
AWM_INLINE void dctiii_4(float *data, const int stride)
{
	__m128 a[4], b[4];

	//Peo
	a[0]=_mm_load_ps(data+0*stride);
	a[2]=_mm_load_ps(data+1*stride);
	a[1]=_mm_load_ps(data+2*stride);
	a[3]=_mm_load_ps(data+3*stride);

	//BcT
	a[3]=_mm_add_ps(a[3], a[2]);
	a[2]=_mm_mul_ps(a[2], _mm_set1_ps(1.4142135623730950488016887242097f));
	
	//two half-DCTIIIs
	//a[0]=_mm_mul_ps(a[0], _mm_set1_ps(0.7071067811865475244008443621048f));
	//a[1]=_mm_mul_ps(a[1], _mm_set1_ps(0.7071067811865475244008443621048f));
	//a[2]=_mm_mul_ps(a[2], _mm_set1_ps(0.7071067811865475244008443621048f));
	//a[3]=_mm_mul_ps(a[3], _mm_set1_ps(0.7071067811865475244008443621048f));
	b[0]=_mm_add_ps(a[0], a[1]);
	b[1]=_mm_sub_ps(a[0], a[1]);
	b[2]=_mm_add_ps(a[2], a[3]);
	b[3]=_mm_sub_ps(a[2], a[3]);

	//Wc
	b[2]=_mm_mul_ps(b[2], _mm_set1_ps(0.5411961001461969843997232053664f));//0.5 sec( 1 pi/(2*4))
	b[3]=_mm_mul_ps(b[3], _mm_set1_ps(1.3065629648763765278566431734272f));//0.5 sec( 3 pi/(2*4))

	//HbarT
	a[0]=_mm_add_ps(b[0], b[2]);
	a[1]=_mm_add_ps(b[1], b[3]);
	a[2]=_mm_sub_ps(b[1], b[3]);
	a[3]=_mm_sub_ps(b[0], b[2]);
	//a[0]=_mm_mul_ps(a[0], _mm_set1_ps(0.7071067811865475244008443621048f));
	//a[1]=_mm_mul_ps(a[1], _mm_set1_ps(0.7071067811865475244008443621048f));
	//a[2]=_mm_mul_ps(a[2], _mm_set1_ps(0.7071067811865475244008443621048f));
	//a[3]=_mm_mul_ps(a[3], _mm_set1_ps(0.7071067811865475244008443621048f));

	_mm_store_ps(data+0*stride, a[0]);
	_mm_store_ps(data+1*stride, a[1]);
	_mm_store_ps(data+2*stride, a[2]);
	_mm_store_ps(data+3*stride, a[3]);
}
AWM_INLINE void dctii_8(float *data, const int stride)
{
	__m128 a[8], b[8];
	
	a[0]=_mm_load_ps(data+0*stride);
	a[1]=_mm_load_ps(data+1*stride);
	a[2]=_mm_load_ps(data+2*stride);
	a[3]=_mm_load_ps(data+3*stride);
	a[4]=_mm_load_ps(data+4*stride);
	a[5]=_mm_load_ps(data+5*stride);
	a[6]=_mm_load_ps(data+6*stride);
	a[7]=_mm_load_ps(data+7*stride);

	//Hbar
	b[0]=_mm_add_ps(a[0], a[7]);
	b[1]=_mm_add_ps(a[1], a[6]);
	b[2]=_mm_add_ps(a[2], a[5]);
	b[3]=_mm_add_ps(a[3], a[4]);
	b[4]=_mm_sub_ps(a[0], a[7]);
	b[5]=_mm_sub_ps(a[1], a[6]);
	b[6]=_mm_sub_ps(a[2], a[5]);
	b[7]=_mm_sub_ps(a[3], a[4]);

	//Wc
	b[4]=_mm_mul_ps(b[4], _mm_set1_ps(0.50979557910415916894193980398784f));//0.5 sec(1 pi/(2*8))
	b[5]=_mm_mul_ps(b[5], _mm_set1_ps(0.60134488693504528054372182390922f));//0.5 sec(3 pi/(2*8))
	b[6]=_mm_mul_ps(b[6], _mm_set1_ps(0.89997622313641570463850954094189f));//0.5 sec(5 pi/(2*8))
	b[7]=_mm_mul_ps(b[7], _mm_set1_ps(2.56291544774150617879608629617770f));//0.5 sec(7 pi/(2*8))

	dctii_4((float*)(b+0*4), sizeof(__m128)/sizeof(float));
	dctii_4((float*)(b+1*4), sizeof(__m128)/sizeof(float));

	//Bc
	b[4]=_mm_add_ps(_mm_mul_ps(b[4], _mm_set1_ps(1.4142135623730950488016887242097f)), b[5]);//sqrt2
	b[5]=_mm_add_ps(b[5], b[6]);
	b[6]=_mm_add_ps(b[6], b[7]);

	//PeoT
	_mm_store_ps(data+0*stride, b[0]);
	_mm_store_ps(data+1*stride, b[4]);
	_mm_store_ps(data+2*stride, b[1]);
	_mm_store_ps(data+3*stride, b[5]);
	_mm_store_ps(data+4*stride, b[2]);
	_mm_store_ps(data+5*stride, b[6]);
	_mm_store_ps(data+6*stride, b[3]);
	_mm_store_ps(data+7*stride, b[7]);
#if 0
	__m128 w34=_mm_set1_ps(1.3065629648763765278566431734272f);//Wij = 0.5 sec(i*Pi/(2j))
	__m128 w14=_mm_set1_ps(0.5411961001461969843997232053664f);
	__m128 sqrt2=_mm_set1_ps(1.4142135623730950488016887242097f);

	__m128 a[8], b[8];

	a[0]=_mm_load_ps(data+0*stride);
	a[1]=_mm_load_ps(data+1*stride);
	a[2]=_mm_load_ps(data+2*stride);
	a[3]=_mm_load_ps(data+3*stride);
	a[4]=_mm_load_ps(data+4*stride);
	a[5]=_mm_load_ps(data+5*stride);
	a[6]=_mm_load_ps(data+6*stride);
	a[7]=_mm_load_ps(data+7*stride);

	b[0]=_mm_add_ps(a[0], a[7]);
	b[1]=_mm_add_ps(a[1], a[6]);
	b[2]=_mm_add_ps(a[2], a[5]);
	b[3]=_mm_add_ps(a[3], a[4]);
	b[4]=_mm_sub_ps(a[3], a[4]);
	b[5]=_mm_sub_ps(a[2], a[5]);
	b[6]=_mm_sub_ps(a[1], a[6]);
	b[7]=_mm_sub_ps(a[0], a[7]);

	b[4]=_mm_mul_ps(b[4], _mm_set1_ps(2.5629154477415061787960862961777f));//w78
	b[5]=_mm_mul_ps(b[5], _mm_set1_ps(0.8999762231364157046385095409419f));//w58
	b[6]=_mm_mul_ps(b[6], _mm_set1_ps(0.6013448869350452805437218239092f));//w38
	b[7]=_mm_mul_ps(b[7], _mm_set1_ps(0.5097955791041591689419398039878f));//w18

	a[0]=_mm_add_ps(b[0], b[3]);
	a[1]=_mm_add_ps(b[1], b[2]);
	a[2]=_mm_sub_ps(b[1], b[2]);
	a[3]=_mm_sub_ps(b[0], b[3]);
	a[4]=_mm_sub_ps(b[7], b[4]);
	a[5]=_mm_sub_ps(b[6], b[5]);
	a[6]=_mm_add_ps(b[6], b[5]);
	a[7]=_mm_add_ps(b[7], b[4]);

	a[2]=_mm_mul_ps(a[2], w34);
	a[3]=_mm_mul_ps(a[3], w14);
	a[4]=_mm_mul_ps(a[4], w14);
	a[5]=_mm_mul_ps(a[5], w34);

	b[0]=_mm_add_ps(a[0], a[1]);
	b[1]=_mm_sub_ps(a[0], a[1]);
	b[2]=_mm_sub_ps(a[3], a[2]);
	b[3]=_mm_add_ps(a[3], a[2]);
	b[4]=_mm_add_ps(a[4], a[5]);
	b[5]=_mm_sub_ps(a[4], a[5]);
	b[6]=_mm_sub_ps(a[7], a[6]);
	b[7]=_mm_sub_ps(a[7], a[6]);

	b[3]=_mm_add_ps(_mm_mul_ps(b[3], sqrt2), b[2]);
	b[4]=_mm_add_ps(_mm_mul_ps(b[4], sqrt2), b[5]);

	b[7]=_mm_add_ps(_mm_mul_ps(b[7], sqrt2), b[4]);

	b[4]=_mm_add_ps(b[4], b[6]);

	b[6]=_mm_add_ps(b[6], b[5]);

	_mm_store_ps(data+0*stride, b[0]);
	_mm_store_ps(data+1*stride, b[7]);
	_mm_store_ps(data+2*stride, b[3]);
	_mm_store_ps(data+3*stride, b[4]);
	_mm_store_ps(data+4*stride, b[1]);
	_mm_store_ps(data+5*stride, b[6]);
	_mm_store_ps(data+6*stride, b[2]);
	_mm_store_ps(data+7*stride, b[5]);
#endif
}
AWM_INLINE void dctiii_8(float *data, const int stride)
{
	__m128 a[8], b[8];
	
	//Peo
	a[0]=_mm_load_ps(data+0*stride);
	a[4]=_mm_load_ps(data+1*stride);
	a[1]=_mm_load_ps(data+2*stride);
	a[5]=_mm_load_ps(data+3*stride);
	a[2]=_mm_load_ps(data+4*stride);
	a[6]=_mm_load_ps(data+5*stride);
	a[3]=_mm_load_ps(data+6*stride);
	a[7]=_mm_load_ps(data+7*stride);

	//BcT
	a[7]=_mm_add_ps(a[7], a[6]);
	a[6]=_mm_add_ps(a[6], a[5]);
	a[5]=_mm_add_ps(a[5], a[4]);
	a[4]=_mm_mul_ps(a[4], _mm_set1_ps(1.4142135623730950488016887242097f));
	
	dctiii_4((float*)(a+0*4), sizeof(__m128)/sizeof(float));
	dctiii_4((float*)(a+1*4), sizeof(__m128)/sizeof(float));

	//Wc
	a[4]=_mm_mul_ps(a[4], _mm_set1_ps(0.50979557910415916894193980398784f));//0.5 sec(1 pi/(2*8))
	a[5]=_mm_mul_ps(a[5], _mm_set1_ps(0.60134488693504528054372182390922f));//0.5 sec(3 pi/(2*8))
	a[6]=_mm_mul_ps(a[6], _mm_set1_ps(0.89997622313641570463850954094189f));//0.5 sec(5 pi/(2*8))
	a[7]=_mm_mul_ps(a[7], _mm_set1_ps(2.56291544774150617879608629617770f));//0.5 sec(7 pi/(2*8))

	//HbarT
	b[0]=_mm_add_ps(a[0], a[4]);
	b[1]=_mm_add_ps(a[1], a[5]);
	b[2]=_mm_add_ps(a[2], a[6]);
	b[3]=_mm_add_ps(a[3], a[7]);
	b[4]=_mm_sub_ps(a[3], a[7]);
	b[5]=_mm_sub_ps(a[2], a[6]);
	b[6]=_mm_sub_ps(a[1], a[5]);
	b[7]=_mm_sub_ps(a[0], a[4]);

	_mm_store_ps(data+0*stride, b[0]);
	_mm_store_ps(data+1*stride, b[1]);
	_mm_store_ps(data+2*stride, b[2]);
	_mm_store_ps(data+3*stride, b[3]);
	_mm_store_ps(data+4*stride, b[4]);
	_mm_store_ps(data+5*stride, b[5]);
	_mm_store_ps(data+6*stride, b[6]);
	_mm_store_ps(data+7*stride, b[7]);
#if 0
	__m128 w34=_mm_set1_ps(1.3065629648763765278566431734272f);//Wij = 0.5 sec(i*Pi/(2j))
	__m128 w14=_mm_set1_ps(0.5411961001461969843997232053664f);
	__m128 sqrt2=_mm_set1_ps(1.4142135623730950488016887242097f);

	__m128 a[8], b[8];

	a[0]=_mm_load_ps(data+0*stride);
	a[1]=_mm_load_ps(data+1*stride);
	a[2]=_mm_load_ps(data+2*stride);
	a[3]=_mm_load_ps(data+3*stride);
	a[4]=_mm_load_ps(data+4*stride);
	a[5]=_mm_load_ps(data+5*stride);
	a[6]=_mm_load_ps(data+6*stride);
	a[7]=_mm_load_ps(data+7*stride);

	b[0]=a[0];
	b[1]=_mm_mul_ps(sqrt2, a[1]);
	b[2]=a[2];
	b[3]=_mm_add_ps(a[1], a[3]);
	b[4]=a[4];
	b[5]=_mm_add_ps(a[3], a[5]);
	b[6]=a[6];
	b[7]=_mm_add_ps(a[5], a[7]);

	a[0]=b[0];
	a[1]=b[1];
	a[2]=_mm_mul_ps(sqrt2, b[2]);
	a[3]=_mm_mul_ps(sqrt2, b[3]);
	a[4]=b[4];
	a[5]=b[5];
	a[6]=_mm_add_ps(b[2], b[6]);
	a[7]=_mm_add_ps(b[3], b[7]);

	b[0]=_mm_add_ps(a[0], a[4]);
	b[1]=_mm_add_ps(a[1], a[5]);
	b[2]=_mm_add_ps(a[2], a[6]);
	b[3]=_mm_add_ps(a[3], a[7]);
	b[4]=_mm_sub_ps(a[0], a[4]);
	b[5]=_mm_sub_ps(a[1], a[5]);
	b[6]=_mm_sub_ps(a[2], a[6]);
	b[7]=_mm_sub_ps(a[3], a[7]);

	b[2]=_mm_mul_ps(b[2], w14);
	b[3]=_mm_mul_ps(b[3], w14);
	b[6]=_mm_mul_ps(b[6], w34);
	b[7]=_mm_mul_ps(b[7], w34);

	a[0]=_mm_add_ps(b[0], b[2]);
	a[1]=_mm_add_ps(b[1], b[3]);
	a[2]=_mm_sub_ps(b[0], b[2]);
	a[3]=_mm_sub_ps(b[1], b[3]);
	a[4]=_mm_add_ps(b[4], b[6]);
	a[5]=_mm_add_ps(b[5], b[7]);
	a[6]=_mm_sub_ps(b[4], b[6]);
	a[7]=_mm_sub_ps(b[5], b[7]);

	a[1]=_mm_mul_ps(a[1], _mm_set1_ps(0.5097955791041591689419398039878f));//w18
	a[3]=_mm_mul_ps(a[3], _mm_set1_ps(2.5629154477415061787960862961777f));//w78
	a[5]=_mm_mul_ps(a[5], _mm_set1_ps(0.6013448869350452805437218239092f));//w38
	a[7]=_mm_mul_ps(a[7], _mm_set1_ps(0.8999762231364157046385095409419f));//w58

	b[0]=_mm_add_ps(a[0], a[1]);
	b[1]=_mm_sub_ps(a[0], a[1]);
	b[2]=_mm_add_ps(a[2], a[3]);
	b[3]=_mm_sub_ps(a[2], a[3]);
	b[4]=_mm_add_ps(a[4], a[5]);
	b[5]=_mm_sub_ps(a[4], a[5]);
	b[6]=_mm_add_ps(a[6], a[7]);
	b[7]=_mm_sub_ps(a[6], a[7]);

	_mm_store_ps(data+0*stride, b[0]);
	_mm_store_ps(data+1*stride, b[4]);
	_mm_store_ps(data+2*stride, b[6]);
	_mm_store_ps(data+3*stride, b[2]);
	_mm_store_ps(data+4*stride, b[3]);
	_mm_store_ps(data+5*stride, b[7]);
	_mm_store_ps(data+6*stride, b[5]);
	_mm_store_ps(data+7*stride, b[1]);
#endif
}
AWM_INLINE void dctii_16(float *data, const int stride)
{
	__m128 a[16];

	//Hbar_16
	float *p1=data, *p2=data+15*stride;
	for(int k=0;k<8;++k)
	{
		__m128 t0=_mm_load_ps(p1);
		__m128 t1=_mm_load_ps(p2);
		p1+=stride;
		p2-=stride;
		a[k+0*8]=_mm_add_ps(t0, t1);
		a[k+1*8]=_mm_sub_ps(t0, t1);
	}

	//Wc_16
	a[0x8]=_mm_mul_ps(a[0x8], _mm_set1_ps(0.5024192861881557055116701192801f));//0.5 sec( 1 pi/(2*16))
	a[0x9]=_mm_mul_ps(a[0x9], _mm_set1_ps(0.5224986149396888806285753190567f));//0.5 sec( 3 pi/(2*16))
	a[0xA]=_mm_mul_ps(a[0xA], _mm_set1_ps(0.5669440348163577036805379151549f));//0.5 sec( 5 pi/(2*16))
	a[0xB]=_mm_mul_ps(a[0xB], _mm_set1_ps(0.6468217833599901295483601116520f));//0.5 sec( 7 pi/(2*16))
	a[0xC]=_mm_mul_ps(a[0xC], _mm_set1_ps(0.7881546234512502247339824871974f));//0.5 sec( 9 pi/(2*16))
	a[0xD]=_mm_mul_ps(a[0xD], _mm_set1_ps(1.0606776859903474713404517472331f));//0.5 sec(11 pi/(2*16))
	a[0xE]=_mm_mul_ps(a[0xE], _mm_set1_ps(1.7224470982383339278159153641566f));//0.5 sec(13 pi/(2*16))
	a[0xF]=_mm_mul_ps(a[0xF], _mm_set1_ps(5.1011486186891638581062454923454f));//0.5 sec(15 pi/(2*16))

	dctii_8((float*)(a+0*8), sizeof(__m128)/sizeof(float));
	dctii_8((float*)(a+1*8), sizeof(__m128)/sizeof(float));

	//Bc_16
	a[0x8]=_mm_add_ps(_mm_mul_ps(a[0x8], _mm_set1_ps(1.4142135623730950488016887242097f)), a[0x9]);//sqrt2
	a[0x9]=_mm_add_ps(a[0x9], a[0xA]);
	a[0xA]=_mm_add_ps(a[0xA], a[0xB]);
	a[0xB]=_mm_add_ps(a[0xB], a[0xC]);
	a[0xC]=_mm_add_ps(a[0xC], a[0xD]);
	a[0xD]=_mm_add_ps(a[0xD], a[0xE]);
	a[0xE]=_mm_add_ps(a[0xE], a[0xF]);

	//Peo16T
	for(int k=0;k<8;++k)
		_mm_store_ps(data+(2*k)*stride, a[k]);
	for(int k=0;k<8;++k)
		_mm_store_ps(data+(2*k+1)*stride, a[k+8]);
}
AWM_INLINE void dctiii_16(float *data, const int stride)
{
	__m128 a[16];

	//Peo16
	for(int k=0;k<8;++k)
		a[k]=_mm_load_ps(data+(2*k)*stride);
	for(int k=0;k<8;++k)
		a[k+8]=_mm_load_ps(data+(2*k+1)*stride);

	//Bc_16T
	a[0xF]=_mm_add_ps(a[0xF], a[0xE]);
	a[0xE]=_mm_add_ps(a[0xE], a[0xD]);
	a[0xD]=_mm_add_ps(a[0xD], a[0xC]);
	a[0xC]=_mm_add_ps(a[0xC], a[0xB]);
	a[0xB]=_mm_add_ps(a[0xB], a[0xA]);
	a[0xA]=_mm_add_ps(a[0xA], a[0x9]);
	a[0x9]=_mm_add_ps(a[0x9], a[0x8]);
	a[0x8]=_mm_mul_ps(a[0x8], _mm_set1_ps(1.4142135623730950488016887242097f));

	dctiii_8((float*)(a+0*8), sizeof(__m128)/sizeof(float));
	dctiii_8((float*)(a+1*8), sizeof(__m128)/sizeof(float));

	//Wc_16
	a[0x8]=_mm_mul_ps(a[0x8], _mm_set1_ps(0.5024192861881557055116701192801f));//0.5 sec( 1 pi/(2*16))
	a[0x9]=_mm_mul_ps(a[0x9], _mm_set1_ps(0.5224986149396888806285753190567f));//0.5 sec( 3 pi/(2*16))
	a[0xA]=_mm_mul_ps(a[0xA], _mm_set1_ps(0.5669440348163577036805379151549f));//0.5 sec( 5 pi/(2*16))
	a[0xB]=_mm_mul_ps(a[0xB], _mm_set1_ps(0.6468217833599901295483601116520f));//0.5 sec( 7 pi/(2*16))
	a[0xC]=_mm_mul_ps(a[0xC], _mm_set1_ps(0.7881546234512502247339824871974f));//0.5 sec( 9 pi/(2*16))
	a[0xD]=_mm_mul_ps(a[0xD], _mm_set1_ps(1.0606776859903474713404517472331f));//0.5 sec(11 pi/(2*16))
	a[0xE]=_mm_mul_ps(a[0xE], _mm_set1_ps(1.7224470982383339278159153641566f));//0.5 sec(13 pi/(2*16))
	a[0xF]=_mm_mul_ps(a[0xF], _mm_set1_ps(5.1011486186891638581062454923454f));//0.5 sec(15 pi/(2*16))

	//Hbar16T
	for(int k=0;k<8;++k)
		_mm_store_ps(data+k*stride, _mm_add_ps(a[k], a[k+8]));
	for(int k=0;k<8;++k)
		_mm_store_ps(data+(k+8)*stride, _mm_sub_ps(a[7-k], a[7-k+8]));
}
AWM_INLINE void dctii_32(float *data, const int stride)
{
	__m128 a[32];

	//Hbar_32
	float *p1=data, *p2=data+31*stride;
	for(int k=0;k<16;++k)
	{
		__m128 t0=_mm_load_ps(p1);
		__m128 t1=_mm_load_ps(p2);
		p1+=stride;
		p2-=stride;
		a[k+0*16]=_mm_add_ps(t0, t1);
		a[k+1*16]=_mm_sub_ps(t0, t1);
	}

	//Wc_32
	a[0x10]=_mm_mul_ps(a[0x10], _mm_set1_ps( 0.5006029982351963013455041067664f));//0.5 sec( 1 pi/(2*32))
	a[0x11]=_mm_mul_ps(a[0x11], _mm_set1_ps( 0.5054709598975436599844445856070f));//0.5 sec( 3 pi/(2*32))
	a[0x12]=_mm_mul_ps(a[0x12], _mm_set1_ps( 0.5154473099226245469749513056493f));//0.5 sec( 5 pi/(2*32))
	a[0x13]=_mm_mul_ps(a[0x13], _mm_set1_ps( 0.5310425910897841744757339323572f));//0.5 sec( 7 pi/(2*32))
	a[0x14]=_mm_mul_ps(a[0x14], _mm_set1_ps( 0.5531038960344445278293808381371f));//0.5 sec( 9 pi/(2*32))
	a[0x15]=_mm_mul_ps(a[0x15], _mm_set1_ps( 0.5829349682061338736738307012526f));//0.5 sec(11 pi/(2*32))
	a[0x16]=_mm_mul_ps(a[0x16], _mm_set1_ps( 0.6225041230356648161572561567628f));//0.5 sec(13 pi/(2*32))
	a[0x17]=_mm_mul_ps(a[0x17], _mm_set1_ps( 0.6748083414550057460259687110410f));//0.5 sec(15 pi/(2*32))
	a[0x18]=_mm_mul_ps(a[0x18], _mm_set1_ps( 0.7445362710022984497769811919729f));//0.5 sec(17 pi/(2*32))
	a[0x19]=_mm_mul_ps(a[0x19], _mm_set1_ps( 0.8393496454155270387392637466254f));//0.5 sec(19 pi/(2*32))
	a[0x1A]=_mm_mul_ps(a[0x1A], _mm_set1_ps( 0.9725682378619606936976894140525f));//0.5 sec(21 pi/(2*32))
	a[0x1B]=_mm_mul_ps(a[0x1B], _mm_set1_ps( 1.1694399334328849551557702840422f));//0.5 sec(23 pi/(2*32))
	a[0x1C]=_mm_mul_ps(a[0x1C], _mm_set1_ps( 1.4841646163141662772433269374281f));//0.5 sec(25 pi/(2*32))
	a[0x1D]=_mm_mul_ps(a[0x1D], _mm_set1_ps( 2.0577810099534115508565544797104f));//0.5 sec(27 pi/(2*32))
	a[0x1E]=_mm_mul_ps(a[0x1E], _mm_set1_ps( 3.4076084184687187857011913334591f));//0.5 sec(29 pi/(2*32))
	a[0x1F]=_mm_mul_ps(a[0x1F], _mm_set1_ps(10.1900081235480568112121092010356f));//0.5 sec(31 pi/(2*32))

	dctii_16((float*)(a+0*16), sizeof(__m128)/sizeof(float));
	dctii_16((float*)(a+1*16), sizeof(__m128)/sizeof(float));

	//Bc_16
	a[0x10]=_mm_add_ps(_mm_mul_ps(a[0x10], _mm_set1_ps(1.4142135623730950488016887242097f)), a[0x11]);//sqrt2
	a[0x11]=_mm_add_ps(a[0x11], a[0x12]);
	a[0x12]=_mm_add_ps(a[0x12], a[0x13]);
	a[0x13]=_mm_add_ps(a[0x13], a[0x14]);
	a[0x14]=_mm_add_ps(a[0x14], a[0x15]);
	a[0x15]=_mm_add_ps(a[0x15], a[0x16]);
	a[0x16]=_mm_add_ps(a[0x16], a[0x17]);
	a[0x17]=_mm_add_ps(a[0x17], a[0x18]);
	a[0x18]=_mm_add_ps(a[0x18], a[0x19]);
	a[0x19]=_mm_add_ps(a[0x19], a[0x1A]);
	a[0x1A]=_mm_add_ps(a[0x1A], a[0x1B]);
	a[0x1B]=_mm_add_ps(a[0x1B], a[0x1C]);
	a[0x1C]=_mm_add_ps(a[0x1C], a[0x1D]);
	a[0x1D]=_mm_add_ps(a[0x1D], a[0x1E]);
	a[0x1E]=_mm_add_ps(a[0x1E], a[0x1F]);

	//Peo16T
	for(int k=0;k<16;++k)
		_mm_store_ps(data+(2*k)*stride, a[k]);
	for(int k=0;k<16;++k)
		_mm_store_ps(data+(2*k+1)*stride, a[k+16]);
}
AWM_INLINE void dctiii_32(float *data, const int stride)
{
	__m128 a[32];

	//Peo16
	for(int k=0;k<16;++k)
		a[k]=_mm_load_ps(data+(2*k)*stride);
	for(int k=0;k<16;++k)
		a[k+16]=_mm_load_ps(data+(2*k+1)*stride);

	//Bc_16T
	a[0x1F]=_mm_add_ps(a[0x1F], a[0x1E]);
	a[0x1E]=_mm_add_ps(a[0x1E], a[0x1D]);
	a[0x1D]=_mm_add_ps(a[0x1D], a[0x1C]);
	a[0x1C]=_mm_add_ps(a[0x1C], a[0x1B]);
	a[0x1B]=_mm_add_ps(a[0x1B], a[0x1A]);
	a[0x1A]=_mm_add_ps(a[0x1A], a[0x19]);
	a[0x19]=_mm_add_ps(a[0x19], a[0x18]);
	a[0x18]=_mm_add_ps(a[0x18], a[0x17]);
	a[0x17]=_mm_add_ps(a[0x17], a[0x16]);
	a[0x16]=_mm_add_ps(a[0x16], a[0x15]);
	a[0x15]=_mm_add_ps(a[0x15], a[0x14]);
	a[0x14]=_mm_add_ps(a[0x14], a[0x13]);
	a[0x13]=_mm_add_ps(a[0x13], a[0x12]);
	a[0x12]=_mm_add_ps(a[0x12], a[0x11]);
	a[0x11]=_mm_add_ps(a[0x11], a[0x10]);
	a[0x10]=_mm_mul_ps(a[0x10], _mm_set1_ps(1.4142135623730950488016887242097f));

	dctiii_16((float*)(a+0*16), sizeof(__m128)/sizeof(float));
	dctiii_16((float*)(a+1*16), sizeof(__m128)/sizeof(float));

	//Wc_16
	a[0x10]=_mm_mul_ps(a[0x10], _mm_set1_ps( 0.5006029982351963013455041067664f));//0.5 sec( 1 pi/(2*32))
	a[0x11]=_mm_mul_ps(a[0x11], _mm_set1_ps( 0.5054709598975436599844445856070f));//0.5 sec( 3 pi/(2*32))
	a[0x12]=_mm_mul_ps(a[0x12], _mm_set1_ps( 0.5154473099226245469749513056493f));//0.5 sec( 5 pi/(2*32))
	a[0x13]=_mm_mul_ps(a[0x13], _mm_set1_ps( 0.5310425910897841744757339323572f));//0.5 sec( 7 pi/(2*32))
	a[0x14]=_mm_mul_ps(a[0x14], _mm_set1_ps( 0.5531038960344445278293808381371f));//0.5 sec( 9 pi/(2*32))
	a[0x15]=_mm_mul_ps(a[0x15], _mm_set1_ps( 0.5829349682061338736738307012526f));//0.5 sec(11 pi/(2*32))
	a[0x16]=_mm_mul_ps(a[0x16], _mm_set1_ps( 0.6225041230356648161572561567628f));//0.5 sec(13 pi/(2*32))
	a[0x17]=_mm_mul_ps(a[0x17], _mm_set1_ps( 0.6748083414550057460259687110410f));//0.5 sec(15 pi/(2*32))
	a[0x18]=_mm_mul_ps(a[0x18], _mm_set1_ps( 0.7445362710022984497769811919729f));//0.5 sec(17 pi/(2*32))
	a[0x19]=_mm_mul_ps(a[0x19], _mm_set1_ps( 0.8393496454155270387392637466254f));//0.5 sec(19 pi/(2*32))
	a[0x1A]=_mm_mul_ps(a[0x1A], _mm_set1_ps( 0.9725682378619606936976894140525f));//0.5 sec(21 pi/(2*32))
	a[0x1B]=_mm_mul_ps(a[0x1B], _mm_set1_ps( 1.1694399334328849551557702840422f));//0.5 sec(23 pi/(2*32))
	a[0x1C]=_mm_mul_ps(a[0x1C], _mm_set1_ps( 1.4841646163141662772433269374281f));//0.5 sec(25 pi/(2*32))
	a[0x1D]=_mm_mul_ps(a[0x1D], _mm_set1_ps( 2.0577810099534115508565544797104f));//0.5 sec(27 pi/(2*32))
	a[0x1E]=_mm_mul_ps(a[0x1E], _mm_set1_ps( 3.4076084184687187857011913334591f));//0.5 sec(29 pi/(2*32))
	a[0x1F]=_mm_mul_ps(a[0x1F], _mm_set1_ps(10.1900081235480568112121092010356f));//0.5 sec(31 pi/(2*32))

	//Hbar16T
	for(int k=0;k<16;++k)
		_mm_store_ps(data+k*stride, _mm_add_ps(a[k], a[k+16]));
	for(int k=0;k<16;++k)
		_mm_store_ps(data+(k+16)*stride, _mm_sub_ps(a[15-k], a[15-k+16]));
}

AWM_INLINE void transpose4x4(float *block)
{
	__m128 a[4];
	
	a[0]=_mm_load_ps(block+0*4);
	a[1]=_mm_load_ps(block+1*4);
	a[2]=_mm_load_ps(block+2*4);
	a[3]=_mm_load_ps(block+3*4);
	
	_MM_TRANSPOSE4_PS(a[0], a[1], a[2], a[3]);

	_mm_store_ps(block+0*4, a[0]);
	_mm_store_ps(block+1*4, a[1]);
	_mm_store_ps(block+2*4, a[2]);
	_mm_store_ps(block+3*4, a[3]);
}
AWM_INLINE void transpose8x8(float *block)
{
	__m128 a[4], b[4];

	//	A	B
	//	C	D
	
	//transpose A
	a[0]=_mm_load_ps(block+0*8);
	a[1]=_mm_load_ps(block+1*8);
	a[2]=_mm_load_ps(block+2*8);
	a[3]=_mm_load_ps(block+3*8);
	
	_MM_TRANSPOSE4_PS(a[0], a[1], a[2], a[3]);

	_mm_store_ps(block+0*8, a[0]);
	_mm_store_ps(block+1*8, a[1]);
	_mm_store_ps(block+2*8, a[2]);
	_mm_store_ps(block+3*8, a[3]);

	//transpose B and C
	a[0]=_mm_load_ps(block+0*8+4);//load B
	a[1]=_mm_load_ps(block+1*8+4);
	a[2]=_mm_load_ps(block+2*8+4);
	a[3]=_mm_load_ps(block+3*8+4);
	
	_MM_TRANSPOSE4_PS(a[0], a[1], a[2], a[3]);

	b[0]=_mm_load_ps(block+4*8);//load C
	b[1]=_mm_load_ps(block+5*8);
	b[2]=_mm_load_ps(block+6*8);
	b[3]=_mm_load_ps(block+7*8);
	_mm_store_ps(block+4*8, a[0]);//store C
	_mm_store_ps(block+5*8, a[1]);
	_mm_store_ps(block+6*8, a[2]);
	_mm_store_ps(block+7*8, a[3]);

	_MM_TRANSPOSE4_PS(b[0], b[1], b[2], b[3]);

	_mm_store_ps(block+0*8+4, b[0]);//store B
	_mm_store_ps(block+1*8+4, b[1]);
	_mm_store_ps(block+2*8+4, b[2]);
	_mm_store_ps(block+3*8+4, b[3]);

	//transpose D
	a[0]=_mm_load_ps(block+4*8+4);
	a[1]=_mm_load_ps(block+5*8+4);
	a[2]=_mm_load_ps(block+6*8+4);
	a[3]=_mm_load_ps(block+7*8+4);
	
	_MM_TRANSPOSE4_PS(a[0], a[1], a[2], a[3]);

	_mm_store_ps(block+4*8+4, a[0]);
	_mm_store_ps(block+5*8+4, a[1]);
	_mm_store_ps(block+6*8+4, a[2]);
	_mm_store_ps(block+7*8+4, a[3]);
}
AWM_INLINE void transpose16x16(float *block)
{
	__m128 a[4], b[4];
	
#define TRANSPOSE_DIAG(IDX)\
	do\
	{\
		a[0]=_mm_load_ps(block+(0+4*(IDX))*16+4*(IDX));\
		a[1]=_mm_load_ps(block+(1+4*(IDX))*16+4*(IDX));\
		a[2]=_mm_load_ps(block+(2+4*(IDX))*16+4*(IDX));\
		a[3]=_mm_load_ps(block+(3+4*(IDX))*16+4*(IDX));\
		_MM_TRANSPOSE4_PS(a[0], a[1], a[2], a[3]);\
		_mm_store_ps(block+(0+4*(IDX))*16+4*(IDX), a[0]);\
		_mm_store_ps(block+(1+4*(IDX))*16+4*(IDX), a[1]);\
		_mm_store_ps(block+(2+4*(IDX))*16+4*(IDX), a[2]);\
		_mm_store_ps(block+(3+4*(IDX))*16+4*(IDX), a[3]);\
	}while(0)
#define TRANSPOSE_NOND(Y, X)\
	do\
	{\
		a[0]=_mm_load_ps(block+(0+4*(Y))*16+4*(X));\
		a[1]=_mm_load_ps(block+(1+4*(Y))*16+4*(X));\
		a[2]=_mm_load_ps(block+(2+4*(Y))*16+4*(X));\
		a[3]=_mm_load_ps(block+(3+4*(Y))*16+4*(X));\
		b[0]=_mm_load_ps(block+(0+4*(X))*16+4*(Y));\
		b[1]=_mm_load_ps(block+(1+4*(X))*16+4*(Y));\
		b[2]=_mm_load_ps(block+(2+4*(X))*16+4*(Y));\
		b[3]=_mm_load_ps(block+(3+4*(X))*16+4*(Y));\
		_MM_TRANSPOSE4_PS(a[0], a[1], a[2], a[3]);\
		_MM_TRANSPOSE4_PS(b[0], b[1], b[2], b[3]);\
		_mm_store_ps(block+(0+4*(Y))*16+4*(X), b[0]);\
		_mm_store_ps(block+(1+4*(Y))*16+4*(X), b[1]);\
		_mm_store_ps(block+(2+4*(Y))*16+4*(X), b[2]);\
		_mm_store_ps(block+(3+4*(Y))*16+4*(X), b[3]);\
		_mm_store_ps(block+(0+4*(X))*16+4*(Y), a[0]);\
		_mm_store_ps(block+(1+4*(X))*16+4*(Y), a[1]);\
		_mm_store_ps(block+(2+4*(X))*16+4*(Y), a[2]);\
		_mm_store_ps(block+(3+4*(X))*16+4*(Y), a[3]);\
	}while(0)
	
	//	0	1	2	3
	//	4	5	6	7
	//	8	9	A	B
	//	C	D	E	F
	TRANSPOSE_DIAG(0);
	TRANSPOSE_DIAG(1);
	TRANSPOSE_DIAG(2);
	TRANSPOSE_DIAG(3);
	TRANSPOSE_NOND(0, 1);
	TRANSPOSE_NOND(0, 2);
	TRANSPOSE_NOND(0, 3);
	TRANSPOSE_NOND(1, 2);
	TRANSPOSE_NOND(1, 3);
	TRANSPOSE_NOND(2, 3);

#undef  TRANSPOSE_DIAG
#undef  TRANSPOSE_NOND
}
AWM_INLINE void transpose32x32(float *block)
{
	__m128 a[4], b[4];
	
#define TRANSPOSE_DIAG(IDX)\
	do\
	{\
		a[0]=_mm_load_ps(block+(0+4*(IDX))*32+4*(IDX));\
		a[1]=_mm_load_ps(block+(1+4*(IDX))*32+4*(IDX));\
		a[2]=_mm_load_ps(block+(2+4*(IDX))*32+4*(IDX));\
		a[3]=_mm_load_ps(block+(3+4*(IDX))*32+4*(IDX));\
		_MM_TRANSPOSE4_PS(a[0], a[1], a[2], a[3]);\
		_mm_store_ps(block+(0+4*(IDX))*32+4*(IDX), a[0]);\
		_mm_store_ps(block+(1+4*(IDX))*32+4*(IDX), a[1]);\
		_mm_store_ps(block+(2+4*(IDX))*32+4*(IDX), a[2]);\
		_mm_store_ps(block+(3+4*(IDX))*32+4*(IDX), a[3]);\
	}while(0)
#define TRANSPOSE_NOND(Y, X)\
	do\
	{\
		a[0]=_mm_load_ps(block+(0+4*(Y))*32+4*(X));\
		a[1]=_mm_load_ps(block+(1+4*(Y))*32+4*(X));\
		a[2]=_mm_load_ps(block+(2+4*(Y))*32+4*(X));\
		a[3]=_mm_load_ps(block+(3+4*(Y))*32+4*(X));\
		b[0]=_mm_load_ps(block+(0+4*(X))*32+4*(Y));\
		b[1]=_mm_load_ps(block+(1+4*(X))*32+4*(Y));\
		b[2]=_mm_load_ps(block+(2+4*(X))*32+4*(Y));\
		b[3]=_mm_load_ps(block+(3+4*(X))*32+4*(Y));\
		_MM_TRANSPOSE4_PS(a[0], a[1], a[2], a[3]);\
		_MM_TRANSPOSE4_PS(b[0], b[1], b[2], b[3]);\
		_mm_store_ps(block+(0+4*(Y))*32+4*(X), b[0]);\
		_mm_store_ps(block+(1+4*(Y))*32+4*(X), b[1]);\
		_mm_store_ps(block+(2+4*(Y))*32+4*(X), b[2]);\
		_mm_store_ps(block+(3+4*(Y))*32+4*(X), b[3]);\
		_mm_store_ps(block+(0+4*(X))*32+4*(Y), a[0]);\
		_mm_store_ps(block+(1+4*(X))*32+4*(Y), a[1]);\
		_mm_store_ps(block+(2+4*(X))*32+4*(Y), a[2]);\
		_mm_store_ps(block+(3+4*(X))*32+4*(Y), a[3]);\
	}while(0)
	
	//	00	01	02	03	04	05	06	07
	//	08	09	0A	0B	0C	0D	0E	0F
	//	10	11	12	13	14	15	16	17
	//	18	19	1A	1B	1C	1D	1E	1F
	//	20	21	22	23	24	25	26	27
	//	28	29	2A	2B	2C	2D	2E	2F
	//	30	31	32	33	34	35	36	37
	//	38	39	3A	3B	3C	3D	3E	3F
	TRANSPOSE_DIAG(0);
	TRANSPOSE_DIAG(1);
	TRANSPOSE_DIAG(2);
	TRANSPOSE_DIAG(3);
	TRANSPOSE_DIAG(4);
	TRANSPOSE_DIAG(5);
	TRANSPOSE_DIAG(6);
	TRANSPOSE_DIAG(7);
	TRANSPOSE_NOND(0, 1);
	TRANSPOSE_NOND(0, 2);
	TRANSPOSE_NOND(0, 3);
	TRANSPOSE_NOND(0, 4);
	TRANSPOSE_NOND(0, 5);
	TRANSPOSE_NOND(0, 6);
	TRANSPOSE_NOND(0, 7);

	TRANSPOSE_NOND(1, 2);
	TRANSPOSE_NOND(1, 3);
	TRANSPOSE_NOND(1, 4);
	TRANSPOSE_NOND(1, 5);
	TRANSPOSE_NOND(1, 6);
	TRANSPOSE_NOND(1, 7);

	TRANSPOSE_NOND(2, 3);
	TRANSPOSE_NOND(2, 4);
	TRANSPOSE_NOND(2, 5);
	TRANSPOSE_NOND(2, 6);
	TRANSPOSE_NOND(2, 7);

	TRANSPOSE_NOND(3, 4);
	TRANSPOSE_NOND(3, 5);
	TRANSPOSE_NOND(3, 6);
	TRANSPOSE_NOND(3, 7);

	TRANSPOSE_NOND(4, 5);
	TRANSPOSE_NOND(4, 6);
	TRANSPOSE_NOND(4, 7);

	TRANSPOSE_NOND(5, 6);
	TRANSPOSE_NOND(5, 7);

	TRANSPOSE_NOND(6, 7);

#undef  TRANSPOSE_DIAG
#undef  TRANSPOSE_NOND
}
AWM_INLINE void gain(float *block, const float *g)
{
	__m128 a[4];

	a[0]=_mm_load_ps(block+0*4);
	a[1]=_mm_load_ps(block+1*4);
	a[2]=_mm_load_ps(block+2*4);
	a[3]=_mm_load_ps(block+3*4);

	a[0]=_mm_mul_ps(a[0], _mm_load_ps(g+0*4));
	a[1]=_mm_mul_ps(a[1], _mm_load_ps(g+1*4));
	a[2]=_mm_mul_ps(a[2], _mm_load_ps(g+2*4));
	a[3]=_mm_mul_ps(a[3], _mm_load_ps(g+3*4));

	_mm_store_ps(block+0*4, a[0]);
	_mm_store_ps(block+1*4, a[1]);
	_mm_store_ps(block+2*4, a[2]);
	_mm_store_ps(block+3*4, a[3]);
}

#if 0
AWM_INLINE void dc_predict(int16_t **rows, int32_t *weights, int32_t *estim, int32_t *ret_p1, int32_t *ret_pred, int32_t *ret_ctx)
{
	int
		NNN	=rows[3][0+0*NCH*NROWS*NVAL],
		NN	=rows[2][0+0*NCH*NROWS*NVAL],
		NNE	=rows[2][0+1*NCH*NROWS*NVAL],
		NW	=rows[1][0-1*NCH*NROWS*NVAL],
		N	=rows[1][0+0*NCH*NROWS*NVAL],
		NE	=rows[1][0+1*NCH*NROWS*NVAL],
		NEE	=rows[1][0+2*NCH*NROWS*NVAL],
		NEEE	=rows[1][0+3*NCH*NROWS*NVAL],
		NEEEE	=rows[1][0+4*NCH*NROWS*NVAL],
		WWWW	=rows[0][0-4*NCH*NROWS*NVAL],
		WWW	=rows[0][0-3*NCH*NROWS*NVAL],
		WW	=rows[0][0-2*NCH*NROWS*NVAL],
		W	=rows[0][0-1*NCH*NROWS*NVAL],
		eW	=rows[0][1-1*NCH*NROWS*NVAL];
	int ctx=FLOOR_LOG2(eW*eW+1);
	int pred=1<<SHIFT>>1, j=0, p1;
	int vmax=N, vmin=W;

	if(ctx>NCTX_DC-1)
		ctx=NCTX_DC-1;
	if(N<W)vmin=N, vmax=W;
#ifdef USE_L1
	if(vmin>NE)vmin=NE;
	if(vmax<NE)vmax=NE;
	if(vmin>NEEE)vmin=NEEE;
	if(vmax<NEEE)vmax=NEEE;
#define PRED(E) estim[j]=E; pred+=weights[j]*estim[j]; ++j;
	j=0;
	PREDLIST
#undef  PRED
	pred>>=SHIFT;
	p1=pred;
#else
	pred=N=W-NW;
#endif
	CLAMP2(pred, vmin, vmax);
	*ret_p1=p1;
	*ret_pred=pred;
	*ret_ctx=ctx;
}
AWM_INLINE void dc_update(int16_t **rows, int32_t *weights, int32_t *estim, int32_t p1, int32_t curr, int32_t error)
{
	int
		eNEEE	=rows[1][1+3*NCH*NROWS*NVAL],
		eW	=rows[0][1-1*NCH*NROWS*NVAL];
#ifdef USE_L1
	int e=(curr>p1)-(curr<p1), j=0;
#define PRED(...) weights[j]+=e*estim[j]; ++j;
	j=0;
	PREDLIST
#undef  PRED
#endif
	rows[0][1]=(2*eW+((error<<1^error>>31)<<GRBITS)+eNEEE)>>2;
}
#endif


#if 0
#define TEST3
static uint32_t stream[256], symbuf[256];
static void test3()
{
	int testsize=1000, declag=128;
	int bumpidx=64;

	uint64_t dlow=0, drange=0xFFFFFFFFFFFF, dcode=0;
	uint64_t elow=0, erange=0xFFFFFFFFFFFF;
	int estreamidx=0, eidx=0;
	int dstreamidx=0, didx=0;
	int freq=0, cdf=0;

	for(int k=0;k<testsize+declag;++k)
	{
		if(k==declag)
		{
			dcode=0;
			dcode=dcode<<32|stream[dstreamidx];
			dstreamidx=(dstreamidx+1)&((int)_countof(stream)-1);
			dcode=dcode<<32|stream[dstreamidx];
			dstreamidx=(dstreamidx+1)&((int)_countof(stream)-1);
			printf(" dec load %016llX", dcode);
		}
		if(k>=declag)
		{
			if(drange<=0xFFFF)
			{
				printf(" dec renorm %08X", (int)(dlow>>32));
				dcode=dcode<<32|stream[dstreamidx];
				dstreamidx=(dstreamidx+1)&((int)_countof(stream)-1);
				dlow<<=32;
				drange=drange<<32|0xFFFFFFFF;
				if(drange>~dlow)
					drange=~dlow;
			}
			int sym=(int)(((dcode-dlow)*16+15)/drange);
			sym=sym>=8;
			printf(" dec [%d] %d", didx, sym);
			if(sym!=symbuf[didx])
				CRASH("ERROR");

			cdf=0;
			freq=8;
			if(sym)
			{
				cdf=8;
				freq=1;
			}
			valfifo_check(freq<<16|cdf);
			dlow+=drange*cdf>>4;
			drange=(drange*freq>>4)-1;

			didx=(didx+1)&((int)_countof(symbuf)-1);
		}
		if(k<testsize)
		{
			if(erange<=0xFFFF)
			{
				printf(" enc renorm %08X", (int)(elow>>32));
				stream[estreamidx]=(uint32_t)(elow>>32);
				estreamidx=(estreamidx+1)&((int)_countof(stream)-1);
				elow<<=32;
				erange=erange<<32|0xFFFFFFFF;
				if(erange>~elow)
					erange=~elow;
			}
			cdf=0;
			freq=8;
			int sym=k==bumpidx;
			if(sym)
			{
				cdf=8;
				freq=1;
			}
			printf(" enc [%d] %d", eidx, sym);
			valfifo_enqueue(freq<<16|cdf);
			elow+=erange*cdf>>4;
			erange=(erange*freq>>4)-1;

			symbuf[eidx]=sym;
			eidx=(eidx+1)&((int)_countof(symbuf)-1);
		}
		if(k==testsize)
		{
			printf(" enc flush %08X", (int)(elow>>32));
			printf(" enc flush %08X", (int)(elow));
			stream[estreamidx]=(uint32_t)(elow>>32);
			estreamidx=(estreamidx+1)&((int)_countof(stream)-1);
			elow<<=32;
			stream[estreamidx]=(uint32_t)(elow>>32);
			estreamidx=(estreamidx+1)&((int)_countof(stream)-1);
			elow<<=32;
		}
		printf("\n");
	}
	printf("SUCCESS\n");
	exit(0);
}
#endif
#if 0
#include"util.h"
#define TEST2
enum
{
	TESTSIZE=32,
};
static const char *g_paths[]=
{
	"C:/Projects/datasets/dataset-LPCB-ppm",
	"C:/Projects/datasets/dataset-DIV2K-ppm",
	"C:/Projects/datasets/dataset-CLIC303-ppm",
	"C:/Projects/datasets/dataset-GDCC2020-ppm",

//	"C:/Projects/datasets/dataset-kodak-ppm",
};
static const char *ext[]={"ppm"};
ALIGN(32) static float testblocks[3][TESTSIZE*TESTSIZE];
static int64_t blockcount=0;
static double SADmean[3]={0}, thresholds[3][3];
static double DCT4mean[3][4*4], DCT8mean[3][8*8], DCT16mean[3][16*16], DCT32mean[3][32*32];
static int qmatrix4[3][4*4], qmatrix8[3][8*8], qmatrix16[3][16*16], qmatrix32[3][32*32];
static void calc_sad(double *sad)
{
	sad[0]=0;
	sad[1]=0;
	sad[2]=0;
	for(int ky=0;ky<TESTSIZE;++ky)
	{
		for(int kx=1;kx<TESTSIZE;++kx)
		{
			sad[0]+=fabsf(testblocks[0][TESTSIZE*ky+kx]-testblocks[0][TESTSIZE*ky+kx-1]);
			sad[1]+=fabsf(testblocks[1][TESTSIZE*ky+kx]-testblocks[1][TESTSIZE*ky+kx-1]);
			sad[2]+=fabsf(testblocks[2][TESTSIZE*ky+kx]-testblocks[2][TESTSIZE*ky+kx-1]);
		}
	}
	for(int ky=1;ky<TESTSIZE;++ky)
	{
		for(int kx=0;kx<TESTSIZE;++kx)
		{
			sad[0]+=fabsf(testblocks[0][TESTSIZE*ky+kx]-testblocks[0][TESTSIZE*(ky-1)+kx]);
			sad[1]+=fabsf(testblocks[1][TESTSIZE*ky+kx]-testblocks[1][TESTSIZE*(ky-1)+kx]);
			sad[2]+=fabsf(testblocks[2][TESTSIZE*ky+kx]-testblocks[2][TESTSIZE*(ky-1)+kx]);
		}
	}
	sad[0]*=1./(2*TESTSIZE*(TESTSIZE-1));
	sad[1]*=1./(2*TESTSIZE*(TESTSIZE-1));
	sad[2]*=1./(2*TESTSIZE*(TESTSIZE-1));
}
static int classify_dct(double sad, int kc)
{
	int flag=DCTsize32;
	if(sad>thresholds[kc][0])
		flag=DCTsize16;
	if(sad>thresholds[kc][1])
		flag=DCTsize8;
	if(sad>thresholds[kc][2])
		flag=DCTsize4;
	return flag;
}
static void test_SADmean(void)
{
	double sad[3]={0};
	calc_sad(sad);
	SADmean[0]+=sad[0];
	SADmean[1]+=sad[1];
	SADmean[2]+=sad[2];
}
#if 0
static void test_SADsdev(void)
{
	double sad[3]={0};
	calc_sad(sad);
	double x=0;
	x=sad[0]-SADmean[0], SADsdev[0]+=x*x;
	x=sad[1]-SADmean[1], SADsdev[1]+=x*x;
	x=sad[2]-SADmean[2], SADsdev[2]+=x*x;
}
#endif
static void test_DCTmean(void)
{
	double sad[3]={0};
	calc_sad(sad);

	//DCT flag	0	1	2	3
	//DCT size	32	16	8	4
	int dctflag[3]={0};
	for(int kc=0;kc<3;++kc)
	{
		dctflag[kc]=classify_dct(sad[kc], kc);
		switch(dctflag[kc])
		{
		case DCTsize32:
			for(int k=0;k<32/4;++k)
				dctii_32(testblocks[kc]+4*k, 32);
			transpose32x32(testblocks[kc]);
			for(int k=0;k<32/4;++k)
				dctii_32(testblocks[kc]+4*k, 32);

			for(int k=0;k<32*32;++k)
				DCT32mean[kc][k]+=fabs(testblocks[kc][k]);
			break;
		case DCTsize16:
			for(int by=0;by<32/16;++by)
			{
				for(int bx=0;bx<32/16;++bx)
				{
					float *block=testblocks[kc]+16*(32*by+bx);
					for(int k=0;k<16/4;++k)
						dctii_16(block+4*k, 32);
				}
			}
			transpose32x32(testblocks[kc]);
			for(int by=0;by<32/16;++by)
			{
				for(int bx=0;bx<32/16;++bx)
				{
					float *block=testblocks[kc]+16*(32*by+bx);
					for(int k=0;k<16/4;++k)
						dctii_16(block+4*k, 32);

					for(int ky=0;ky<16;++ky)
					{
						for(int kx=0;kx<16;++kx)
							DCT16mean[kc][16*ky+kx]+=fabs(block[32*ky+kx]);
					}
				}
			}
			break;
		case DCTsize8:
			for(int by=0;by<32/8;++by)
			{
				for(int bx=0;bx<32/8;++bx)
				{
					float *block=testblocks[kc]+8*(32*by+bx);
					for(int k=0;k<8/4;++k)
						dctii_8(block+4*k, 32);
				}
			}
			transpose32x32(testblocks[kc]);
			for(int by=0;by<32/8;++by)
			{
				for(int bx=0;bx<32/8;++bx)
				{
					float *block=testblocks[kc]+8*(32*by+bx);
					for(int k=0;k<8/4;++k)
						dctii_8(block+4*k, 32);

					for(int ky=0;ky<8;++ky)
					{
						for(int kx=0;kx<8;++kx)
							DCT8mean[kc][8*ky+kx]+=fabs(block[32*ky+kx]);
					}
				}
			}
			break;
		case DCTsize4:
			for(int by=0;by<32/4;++by)
			{
				for(int bx=0;bx<32/4;++bx)
				{
					float *block=testblocks[kc]+4*(32*by+bx);
					for(int k=0;k<4/4;++k)
						dctii_4(block+4*k, 32);
				}
			}
			transpose32x32(testblocks[kc]);
			for(int by=0;by<32/4;++by)
			{
				for(int bx=0;bx<32/4;++bx)
				{
					float *block=testblocks[kc]+4*(32*by+bx);
					for(int k=0;k<4/4;++k)
						dctii_4(block+4*k, 32);

					for(int ky=0;ky<4;++ky)
					{
						for(int kx=0;kx<4;++kx)
							DCT4mean[kc][4*ky+kx]+=fabs(block[32*ky+kx]);
					}
				}
			}
			break;
		}
	}
}
static uint8_t* load_ppm(const char *fn, int *ret_iw, int *ret_ih)
{
	int iw=0, ih=0, c=0;
	FILE *fsrc=0;

	fsrc=fopen(fn, "rb");
	if(!fsrc)
	{
		CRASH("Cannot open \"%s\"", fn);
		return 0;
	}
	fread(&c, 1, 3, fsrc);
	if(c!=('P'|'6'<<8|'\n'<<16))
	{
		CRASH("Unsupported PPM \"%s\"", fn);
		return 0;
	}
	c=fgetc(fsrc);
	while(c=='#')
	{
		c=fgetc(fsrc);
		while(c!='\n')
			c=fgetc(fsrc);
		c=fgetc(fsrc);
	}
	iw=0;
	while((uint32_t)(c-'0')<10)
	{
		iw=10*iw+c-'0';
		c=fgetc(fsrc);
	}
	while(c<=' ')
		c=fgetc(fsrc);
	ih=0;
	while((uint32_t)(c-'0')<10)
	{
		ih=10*ih+c-'0';
		c=fgetc(fsrc);
	}
	while(c<=' ')
		c=fgetc(fsrc);
	while(c=='#')
	{
		c=fgetc(fsrc);
		while(c!='\n')
			c=fgetc(fsrc);
		c=fgetc(fsrc);
	}
	c=c<<8|fgetc(fsrc);
	c=c<<8|fgetc(fsrc);
	c=c<<8|fgetc(fsrc);
	if(c!=('2'<<24|'5'<<16|'5'<<8|'\n')||iw<1||ih<1)
	{
		CRASH("Unsupported PPM \"%s\"", fn);
		return 0;
	}
	ptrdiff_t size=(ptrdiff_t)3*iw*ih;
	unsigned char *image=(unsigned char*)malloc(size+sizeof(__m256i));
	fread(image, 1, size, fsrc);//read image
	fclose(fsrc);
	if(ret_iw)*ret_iw=iw;
	if(ret_ih)*ret_ih=ih;
	return image;
}
static void block_loop(ArrayHandle filenames, void (*test)(void), const char *label)
{
	blockcount=0;
	for(int k=0;k<(int)filenames->count;++k)
	{
		int iw=0, ih=0;
		ArrayHandle *fn=(ArrayHandle*)array_at(&filenames, k);
		uint8_t *image=load_ppm((char*)fn[0]->data, &iw, &ih);
		if(!image)
		{
			CRASH("");
			return;
		}
		if(label)
			printf("%s %5d/%5d\r"
				, label
				, k+1
				, (int)filenames->count
			);
		for(int ky=0;ky<ih-(TESTSIZE-1);ky+=TESTSIZE)
		{
			for(int kx=0;kx<iw-(TESTSIZE-1);kx+=TESTSIZE)
			{
				for(int ky2=0;ky2<TESTSIZE;++ky2)
				{
					uint8_t *ptr=image+3*(iw*(ky+ky2)+kx);
					for(int kx2=0;kx2<TESTSIZE;++kx2, ptr+=3)
					{
						((int*)testblocks[0])[TESTSIZE*ky2+kx2]=ptr[0];
						((int*)testblocks[1])[TESTSIZE*ky2+kx2]=ptr[1];
						((int*)testblocks[2])[TESTSIZE*ky2+kx2]=ptr[2];
					}
				}
				for(int kc=0;kc<3;++kc)
				{
					for(int k=0;k<TESTSIZE*TESTSIZE/16;++k)
						cvti2f(((float*)testblocks[kc])+16*k);
				}
				for(int k=0;k<TESTSIZE*TESTSIZE/16;++k)
					rgb2yuv(
						((float*)testblocks[0])+16*k,
						((float*)testblocks[1])+16*k,
						((float*)testblocks[2])+16*k
					);
				test();
				++blockcount;
			}
		}
		free(image);
	}
	if(label)
		printf("\n");
}
static void print_qmatrix(double *mean, int *qmatrix, int size)
{
	for(int ky=0;ky<size;++ky)
	{
		for(int kx=0;kx<size;++kx)
		{
			printf(" %12.3lff,", mean[size*ky+kx]);
			//qmatrix[size*ky+kx]=(int)CVTFP64_I64(ceil(mean[size*ky+kx]));
			//printf("%10d", qmatrix[size*ky+kx]);
		}
		printf("\n");
	}
	printf("\n");
}
static void test2()
{
	ArrayHandle filenames=0;
	for(int k=0;k<(int)_countof(g_paths);++k)
	{
		ArrayHandle fns=get_filenames(g_paths[k], (char**)ext, _countof(ext), 1);
		if(!fns)
		{
			CRASH("");
			return;
		}
		array_append(&filenames, fns->data, fns->esize, fns->count, 1, 0, free_str);
		free(fns);//shallow free
	}
	if(!filenames||!filenames->count)
	{
		CRASH("");
		return;
	}
	printf("Found %d images\n", (int)filenames->count);

	memset(SADmean, 0, sizeof(SADmean));
	block_loop(filenames, test_SADmean, "SAD mean");
	SADmean[0]/=(double)blockcount;
	SADmean[1]/=(double)blockcount;
	SADmean[2]/=(double)blockcount;
	printf("SAD mean  %12.6lf %12.6lf %12.6lf\n"
		, SADmean[0]
		, SADmean[1]
		, SADmean[2]
	);

#if 0
	block_loop(filenames, test_SADsdev, "SAD sdev");
	SADsdev[0]/=(double)blockcount;
	SADsdev[1]/=(double)blockcount;
	SADsdev[2]/=(double)blockcount;
	SADsdev[0]=sqrt(SADsdev[0]);
	SADsdev[1]=sqrt(SADsdev[1]);
	SADsdev[2]=sqrt(SADsdev[2]);
	printf("SAD sdev  %12.6lf %12.6lf %12.6lf\n"
		, SADsdev[0]
		, SADsdev[1]
		, SADsdev[2]
	);
#endif

	printf("Thresholds:\n");
	for(int kc=0;kc<3;++kc)
	{
		thresholds[kc][0]=SADmean[kc]*0.5;
		thresholds[kc][1]=SADmean[kc];
		thresholds[kc][2]=SADmean[kc]*2;
		//thresholds[kc][0]=SADmean[kc]-SADsdev[kc];
		//thresholds[kc][1]=SADmean[kc];
		//thresholds[kc][2]=SADmean[kc]+SADsdev[kc];

		printf("%c  %12.6lf %12.6lf %12.6lf\n"
			, "YUV"[kc]
			, thresholds[kc][0]
			, thresholds[kc][1]
			, thresholds[kc][2]
		);
	}
	
	block_loop(filenames, test_DCTmean, "DCT mean");
	for(int kc=0;kc<3;++kc)
	{
		for(int k=0;k<32*32;++k)
			DCT32mean[kc][k]/=(double)blockcount;
		for(int k=0;k<16*16;++k)
			DCT16mean[kc][k]/=(32./16)*(32./16)*blockcount;
		for(int k=0;k<8*8;++k)
			DCT8mean[kc][k]/=(32./8)*(32./8)*blockcount;
		for(int k=0;k<4*4;++k)
			DCT4mean[kc][k]/=(32./4)*(32./4)*blockcount;
	}
	for(int kc=0;kc<3;++kc)
		print_qmatrix(DCT32mean[kc], qmatrix32[kc], 32);
	for(int kc=0;kc<3;++kc)
		print_qmatrix(DCT16mean[kc], qmatrix16[kc], 16);
	for(int kc=0;kc<3;++kc)
		print_qmatrix(DCT8mean[kc], qmatrix8[kc], 8);
	for(int kc=0;kc<3;++kc)
		print_qmatrix(DCT4mean[kc], qmatrix4[kc], 4);

	exit(0);
}
#endif
#if 0
#define TEST
ALIGN(32) static float testb0[32*32], testb1[32*32], testb2[32*32], testb3[32*32], testb4[32*32];
static void print_data(const float *data, int cx, int cy, const char *label)
{
	if(label)
		printf("%s\n", label);
	for(int ky=0;ky<cy;++ky)
	{
		for(int kx=0;kx<cx;++kx)
			printf("%12.2f", data[cx*ky+kx]);
		printf("\n");
	}
	printf("\n");
}
static void dcttest()
{
	//32
#if 1
	enum
	{
		SIZE=32,
	};
	//for(int ky=0;ky<SIZE;++ky)
	//	for(int kx=0;kx<SIZE;++kx)
	//		testb1[ky*SIZE+kx]=cosf(M_PI/SIZE*kx)*cosf(M_PI/SIZE*ky)+1;
	for(int k=0;k<32*32;++k)
		testb1[k]=(float)k;
	//	//testb1[k]=(float)rand();

	memcpy(testb0, testb1, sizeof(testb0));
	memcpy(testb2, testb1, sizeof(testb2));

	print_data(testb1, SIZE, SIZE, "Original data");

	for(int kl=0;kl<SIZE;++kl)
	{
		for(int kd=0;kd<SIZE;++kd)
		{
			float x=0;
			for(int ks=0;ks<SIZE;++ks)
				x+=(float)cos(M_PI/SIZE*(ks+0.5f)*kd)*testb1[SIZE*ks+kl];
			testb3[SIZE*kd+kl]=x;
		}
	}
	print_data(testb3, SIZE, SIZE, "Wikipedia DCTII 1D");

	for(int kl=0;kl<SIZE;++kl)
	{
		for(int kd=0;kd<SIZE;++kd)
		{
			float x=testb3[SIZE*0+kl]/2;
			for(int ks=1;ks<SIZE;++ks)
				x+=(float)cos(M_PI/SIZE*(kd+0.5f)*ks)*testb3[SIZE*ks+kl];
			testb4[SIZE*kd+kl]=x;
		}
	}
	print_data(testb4, SIZE, SIZE, "Wikipedia DCTIII 1D");

	for(int k=0;k<SIZE/4;++k)
		dctii_32(testb1+k*4, SIZE);
	transpose32x32(testb1);
	for(int k=0;k<SIZE/4;++k)
		dctii_32(testb1+k*4, SIZE);
	print_data(testb1, SIZE, SIZE, "Perera DCT");
	
	for(int k=0;k<SIZE/4;++k)
		dctiii_32(testb1+k*4, SIZE);
	transpose32x32(testb1);
	for(int k=0;k<SIZE/4;++k)
		dctiii_32(testb1+k*4, SIZE);
	print_data(testb1, SIZE, SIZE, "Recovered");
	
	for(int k=0;k<SIZE*SIZE;++k)
	{
		if(fabsf(testb1[k]/(SIZE*SIZE)-testb0[k])>1e-2)
			CRASH("ERROR");
	}
#endif

	//16
#if 0
	enum
	{
		SIZE=16,
	};
	for(int k=0;k<32*32;++k)
		testb1[k]=(float)k;
		//testb1[k]=(float)rand();

	memcpy(testb0, testb1, sizeof(testb0));
	memcpy(testb2, testb1, sizeof(testb2));

	print_data(testb1, SIZE, SIZE, "Original data");

	for(int kl=0;kl<SIZE;++kl)
	{
		for(int kd=0;kd<SIZE;++kd)
		{
			float x=0;
			for(int ks=0;ks<SIZE;++ks)
				x+=(float)cos(M_PI/SIZE*(ks+0.5f)*kd)*testb1[SIZE*ks+kl];
			testb3[SIZE*kd+kl]=x;
		}
	}
	print_data(testb3, SIZE, SIZE, "Wikipedia DCTII");

	for(int kl=0;kl<SIZE;++kl)
	{
		for(int kd=0;kd<SIZE;++kd)
		{
			float x=testb3[SIZE*0+kl]/2;
			for(int ks=1;ks<SIZE;++ks)
				x+=(float)cos(M_PI/SIZE*(kd+0.5f)*ks)*testb3[SIZE*ks+kl];
			testb4[SIZE*kd+kl]=x;
		}
	}
	print_data(testb4, SIZE, SIZE, "Wikipedia DCTIII");

	for(int k=0;k<SIZE/4;++k)
		dctii_16(testb1+k*4, SIZE);
	transpose16x16(testb1);
	for(int k=0;k<SIZE/4;++k)
		dctii_16(testb1+k*4, SIZE);
	print_data(testb1, SIZE, SIZE, "Perera DCT");
	
	for(int k=0;k<SIZE/4;++k)
		dctiii_16(testb1+k*4, SIZE);
	transpose16x16(testb1);
	for(int k=0;k<SIZE/4;++k)
		dctiii_16(testb1+k*4, SIZE);
	print_data(testb1, SIZE, SIZE, "Recovered");
	
	for(int k=0;k<SIZE*SIZE;++k)
	{
		if(fabsf(testb1[k]/(SIZE*SIZE)-testb0[k])>1e-2)
			CRASH("ERROR");
	}
#endif

	//8
#if 0
	enum
	{
		SIZE=8,
	};
	for(int k=0;k<32*32;++k)
		testb1[k]=(float)k;
		//testb1[k]=(float)rand();

	memcpy(testb0, testb1, sizeof(testb0));
	memcpy(testb2, testb1, sizeof(testb2));

	print_data(testb1, SIZE, SIZE, "Original data");

	for(int kl=0;kl<SIZE;++kl)
	{
		for(int kd=0;kd<SIZE;++kd)
		{
			float x=0;
			for(int ks=0;ks<SIZE;++ks)
				x+=(float)cos(M_PI/SIZE*(ks+0.5f)*kd)*testb1[SIZE*ks+kl];
			testb3[SIZE*kd+kl]=x;
		}
	}
	print_data(testb3, SIZE, SIZE, "Wikipedia DCTII");

	for(int kl=0;kl<SIZE;++kl)
	{
		for(int kd=0;kd<SIZE;++kd)
		{
			float x=testb3[SIZE*0+kl]/2;
			for(int ks=1;ks<SIZE;++ks)
				x+=(float)cos(M_PI/SIZE*(kd+0.5f)*ks)*testb3[SIZE*ks+kl];
			testb4[SIZE*kd+kl]=x;
		}
	}
	print_data(testb4, SIZE, SIZE, "Wikipedia DCTIII");
	
	dct8y8_fwd(testb2);
	transpose8x8(testb2);
	dct8y8_fwd(testb2);
	print_data(testb2, SIZE, SIZE, "ChatGPT DCT");

	dctii_8(testb1, SIZE);
	dctii_8(testb1+4, SIZE);
	transpose8x8(testb1);
	dctii_8(testb1, SIZE);
	dctii_8(testb1+4, SIZE);
	print_data(testb1, SIZE, SIZE, "Perera DCT");
	
	dctiii_8(testb1, SIZE);
	dctiii_8(testb1+4, SIZE);
	transpose8x8(testb1);
	dctiii_8(testb1, SIZE);
	dctiii_8(testb1+4, SIZE);
	print_data(testb1, SIZE, SIZE, "Recovered");
	
	for(int k=0;k<SIZE*SIZE;++k)
	{
		if(fabsf(testb1[k]/(SIZE*SIZE)-testb0[k])>1e-2)
			CRASH("ERROR");
	}
#endif

	//4
#if 0
	for(int k=0;k<32*32;++k)
		testb1[k]=(float)k;
		//testb1[k]=(float)rand();

	memcpy(testb0, testb1, sizeof(testb0));
	memcpy(testb2, testb1, sizeof(testb2));

	print_data(testb1, 4, 4, "Original data");

	for(int kl=0;kl<4;++kl)
	{
		for(int kd=0;kd<4;++kd)
		{
			float x=0;
			for(int ks=0;ks<4;++ks)
				x+=cos(M_PI/4*(ks+0.5f)*kd)*testb1[4*ks+kl];
			testb3[4*kd+kl]=x;
		}
	}
	print_data(testb3, 4, 4, "Wikipedia DCT");

	dct4y4_fwd(testb2);
	transpose4x4(testb2);
	dct4y4_fwd(testb2);
	print_data(testb2, 4, 4, "ChatGPT DCT");
	
	dctii_4(testb1, 4);
	transpose4x4(testb1);
	dctii_4(testb1, 4);
	print_data(testb1, 4, 4, "Perera DCT");
	
	dctiii_4(testb1, 4);
	transpose4x4(testb1);
	dctiii_4(testb1, 4);
	print_data(testb1, 4, 4, "Recovered");


	for(int k=0;k<16;++k)
	{
		if(fabsf(testb1[k]/16-testb0[k])>1e-2)
			CRASH("ERROR");
	}
#endif
	printf("SUCCESS\n");
	exit(0);
}
#endif


#ifdef PROFILE_SIZE
static double csizes[3][2]={0};
#endif

static uint32_t hweight[3*NCTX];
static uint32_t hists[3*NCTX*NLEVELS];
ALIGN(32) static float blocks[3][BLOCK0X*BLOCK0Y]={0},
	qtable0a[3][BLOCK0X*BLOCK0Y],
	qtable1a[3][BLOCK1X*BLOCK1Y],
	qtable2a[3][BLOCK2X*BLOCK2Y],
	qtable3a[3][BLOCK3X*BLOCK3Y];
int c48_codec(int argc, char **argv)
{
#ifdef TEST3
	test3();
#endif
#ifdef TEST2
	test2();
#endif
#ifdef TEST
	dcttest();//
#endif

	const uint16_t tag='4'|'7'<<8;

	const char *srcfn=0, *dstfn=0;
	FILE *fsrc=0, *fdst=0;
	uint64_t c=0;
	int fwd=0, iw=0, ih=0;
	int64_t usize=0, ccap=0, csize=0;
	//int psize=0;
	//int16_t *pixels=0;
	int xdc=0, ydc=0, dcsize=0;
	int16_t *dcbuf=0;
	uint8_t *image=0, *imptr=0, *stream=0, *streamptr=0;
#ifdef _MSC_VER
	uint8_t *streamend=0;
#endif
	int32_t weights[3][NPREDS]={0}, estim[NPREDS]={0};
	int32_t pred=0, ctx=0, error=0, sym=0, curr=0, cdf=0, freq=0;
	uint64_t low=0, range=0xFFFFFFFFFFFF, code=0;
#ifdef LOUD
	double t=0;
#endif

	if(argc!=3)
	{
		printf(
			"Usage:  \"%s\"  src  dst\n"
			"Only for 24-bit PPM images\n"
			"Built on %s %s\n"
			, argv[0]
			, __DATE__, __TIME__
		);
		return 1;
	}
#ifdef LOUD
	t=time_sec();
#endif
	srcfn=argv[1];
	dstfn=argv[2];
	
	fsrc=fopen(srcfn, "rb");
	if(!fsrc)
	{
		CRASH("Cannot open \"%s\"", srcfn);
		return 1;
	}
	fread(&c, 1, 2, fsrc);
	fwd=c==('P'|'6'<<8);
	if(!fwd&&c!=tag)
	{
		CRASH("Unsupported file \"%s\"", srcfn);
		return 1;
	}
	if(fwd)//parse header
	{
		c=fgetc(fsrc);
		if(c!='\n')
		{
			CRASH("Unsupported PPM file");
			return 1;
		}
		c=fgetc(fsrc);
		while(c=='#')
		{
			c=fgetc(fsrc);
			while(c!='\n')
				c=fgetc(fsrc);
			c=fgetc(fsrc);
		}
		iw=0;
		while((uint32_t)(c-'0')<10)
		{
			iw=10*iw+(int32_t)c-'0';
			c=fgetc(fsrc);
		}
		while(c<=' ')
			c=fgetc(fsrc);
		ih=0;
		while((uint32_t)(c-'0')<10)
		{
			ih=10*ih+(int32_t)c-'0';
			c=fgetc(fsrc);
		}
		while(c=='#')
		{
			c=fgetc(fsrc);
			while(c!='\n')
				c=fgetc(fsrc);
			c=fgetc(fsrc);
		}
		c|=(int64_t)fgetc(fsrc)<<8*1;
		c|=(int64_t)fgetc(fsrc)<<8*2;
		c|=(int64_t)fgetc(fsrc)<<8*3;
		c|=(int64_t)fgetc(fsrc)<<8*4;
		if(c!=(
			(uint64_t)'\n'<<8*0|
			(uint64_t) '2'<<8*1|
			(uint64_t) '5'<<8*2|
			(uint64_t) '5'<<8*3|
			(uint64_t)'\n'<<8*4
		))
		{
			CRASH("Unsupported PPM file");
			return 1;
		}
		ccap=(int64_t)4*iw*ih;
	}
	else
	{
		iw=0;
		ih=0;
		fread(&iw, 1, 3, fsrc);
		fread(&ih, 1, 3, fsrc);
		{
			struct stat info={0};

			stat(srcfn, &info);
			ccap=(int64_t)info.st_size-ftell(fsrc);
		}
	}
	if(iw<1||ih<1)
	{
		CRASH("Unsupported source file");
		return 1;
	}
	usize=(int64_t)3*iw*ih;
	image=(uint8_t*)malloc(usize);
	stream=(uint8_t*)malloc(ccap);
	xdc=(iw+BLOCK3X-1)/BLOCK3X;
	ydc=(ih+BLOCK3Y-1)/BLOCK3Y;
	dcsize=xdc*ydc*(int)sizeof(int16_t[6]);
	dcbuf=(int16_t*)malloc(dcsize);
	//psize=(iw/BLOCK0X+2*XPAD)*(int)sizeof(int16_t[NCH*NROWS*NVAL]);
	//pixels=(int16_t*)malloc(psize);
	if(!image||!stream||!dcbuf)
	{
		CRASH("Alloc error");
		return 1;
	}
	streamptr=stream;
#ifdef _MSC_VER
	streamend=stream+ccap;
#endif
	if(fwd)
	{
		fread(image, 1, usize, fsrc);
#ifdef ENABLE_GUIDE
		//for(int ky=0;ky<ih;++ky)
		//{
		//	for(int kx=0;kx<iw;++kx)
		//	{
		//		image[3*(iw*ky+kx)+0]=64*(kx^ky);
		//		image[3*(iw*ky+kx)+1]=64*(kx^ky);
		//		image[3*(iw*ky+kx)+2]=64*(kx^ky);
		//	}
		//}
		//for(ptrdiff_t k=0;k<usize;++k)//
		//	image[k]=rand()>>8&15;

		guide_save(image, iw, ih);
#endif
	}
	else
	{
		c=fread(stream, 1, ccap, fsrc);
	}
	fclose(fsrc);

	for(int k=0;k<3*NPREDS;++k)
		((int32_t*)weights)[k]=(1<<SHIFT)/NPREDS;
	memset(dcbuf, 0, dcsize);
	//memset(pixels, 0, psize);
	memset(hists, 0, sizeof(hists));
	memset(hweight, 0, sizeof(hweight));
	const float acgain=8, dcgain=0.125f, lfogain=1;
	if(fwd)
	{
		for(int k=0;k<BLOCK0X*BLOCK0Y;++k)
		{
			int x=k%BLOCK0X, y=k/BLOCK0X;
			qtable0a[0][k]=k?x+y<5?1/(lfogain*qtable0[0][k]):1/(acgain*qtable0[0][k]):1/(dcgain*qtable0[0][k]);
			qtable0a[1][k]=k?x+y<5?1/(lfogain*qtable0[1][k]):1/(acgain*qtable0[1][k]):1/(dcgain*qtable0[1][k]);
			qtable0a[2][k]=k?x+y<5?1/(lfogain*qtable0[2][k]):1/(acgain*qtable0[2][k]):1/(dcgain*qtable0[2][k]);
		}
		for(int k=0;k<BLOCK1X*BLOCK1Y;++k)
		{
			int x=k%BLOCK1X, y=k/BLOCK1X;
			qtable1a[0][k]=k?x+y<5?1/(lfogain*qtable1[0][k]):1/(acgain*qtable1[0][k]):1/(dcgain*qtable1[0][k]);
			qtable1a[1][k]=k?x+y<5?1/(lfogain*qtable1[1][k]):1/(acgain*qtable1[1][k]):1/(dcgain*qtable1[1][k]);
			qtable1a[2][k]=k?x+y<5?1/(lfogain*qtable1[2][k]):1/(acgain*qtable1[2][k]):1/(dcgain*qtable1[2][k]);
		}
		for(int k=0;k<BLOCK2X*BLOCK2Y;++k)
		{
			int x=k%BLOCK2X, y=k/BLOCK2X;
			qtable2a[0][k]=k?x+y<5?1/(lfogain*qtable2[0][k]):1/(acgain*qtable2[0][k]):1/(dcgain*qtable2[0][k]);
			qtable2a[1][k]=k?x+y<5?1/(lfogain*qtable2[1][k]):1/(acgain*qtable2[1][k]):1/(dcgain*qtable2[1][k]);
			qtable2a[2][k]=k?x+y<5?1/(lfogain*qtable2[2][k]):1/(acgain*qtable2[2][k]):1/(dcgain*qtable2[2][k]);
		}
		for(int k=0;k<BLOCK3X*BLOCK3Y;++k)
		{
			int x=k%BLOCK3X, y=k/BLOCK3X;
			qtable3a[0][k]=k?x+y<5?1/(lfogain*qtable3[0][k]):1/(acgain*qtable3[0][k]):1/(dcgain*qtable3[0][k]);
			qtable3a[1][k]=k?x+y<5?1/(lfogain*qtable3[1][k]):1/(acgain*qtable3[1][k]):1/(dcgain*qtable3[1][k]);
			qtable3a[2][k]=k?x+y<5?1/(lfogain*qtable3[2][k]):1/(acgain*qtable3[2][k]):1/(dcgain*qtable3[2][k]);
		}
	}
	else
	{
		for(int k=0;k<BLOCK0X*BLOCK0Y;++k)
		{
			int x=k%BLOCK0X, y=k/BLOCK0X;
			qtable0a[0][k]=k?x+y<5?qtable0[0][k]/(lfogain*BLOCK0X*BLOCK0Y):qtable0[0][k]/(acgain*BLOCK0X*BLOCK0Y):dcgain*qtable0[0][k]/(BLOCK0X*BLOCK0Y);
			qtable0a[1][k]=k?x+y<5?qtable0[1][k]/(lfogain*BLOCK0X*BLOCK0Y):qtable0[1][k]/(acgain*BLOCK0X*BLOCK0Y):dcgain*qtable0[1][k]/(BLOCK0X*BLOCK0Y);
			qtable0a[2][k]=k?x+y<5?qtable0[2][k]/(lfogain*BLOCK0X*BLOCK0Y):qtable0[2][k]/(acgain*BLOCK0X*BLOCK0Y):dcgain*qtable0[2][k]/(BLOCK0X*BLOCK0Y);
		}
		for(int k=0;k<BLOCK1X*BLOCK1Y;++k)
		{
			int x=k%BLOCK1X, y=k/BLOCK1X;
			qtable1a[0][k]=k?x+y<5?qtable1[0][k]/(lfogain*BLOCK1X*BLOCK1Y):qtable1[0][k]/(acgain*BLOCK1X*BLOCK1Y):dcgain*qtable1[0][k]/(BLOCK1X*BLOCK1Y);
			qtable1a[1][k]=k?x+y<5?qtable1[1][k]/(lfogain*BLOCK1X*BLOCK1Y):qtable1[1][k]/(acgain*BLOCK1X*BLOCK1Y):dcgain*qtable1[1][k]/(BLOCK1X*BLOCK1Y);
			qtable1a[2][k]=k?x+y<5?qtable1[2][k]/(lfogain*BLOCK1X*BLOCK1Y):qtable1[2][k]/(acgain*BLOCK1X*BLOCK1Y):dcgain*qtable1[2][k]/(BLOCK1X*BLOCK1Y);
		}
		for(int k=0;k<BLOCK2X*BLOCK2Y;++k)
		{
			int x=k%BLOCK2X, y=k/BLOCK2X;
			qtable2a[0][k]=k?x+y<5?qtable2[0][k]/(lfogain*BLOCK2X*BLOCK2Y):qtable2[0][k]/(acgain*BLOCK2X*BLOCK2Y):dcgain*qtable2[0][k]/(BLOCK2X*BLOCK2Y);
			qtable2a[1][k]=k?x+y<5?qtable2[1][k]/(lfogain*BLOCK2X*BLOCK2Y):qtable2[1][k]/(acgain*BLOCK2X*BLOCK2Y):dcgain*qtable2[1][k]/(BLOCK2X*BLOCK2Y);
			qtable2a[2][k]=k?x+y<5?qtable2[2][k]/(lfogain*BLOCK2X*BLOCK2Y):qtable2[2][k]/(acgain*BLOCK2X*BLOCK2Y):dcgain*qtable2[2][k]/(BLOCK2X*BLOCK2Y);
		}
		for(int k=0;k<BLOCK3X*BLOCK3Y;++k)
		{
			int x=k%BLOCK3X, y=k/BLOCK3X;
			qtable3a[0][k]=k?x+y<5?qtable3[0][k]/(lfogain*BLOCK3X*BLOCK3Y):qtable3[0][k]/(acgain*BLOCK3X*BLOCK3Y):dcgain*qtable3[0][k]/(BLOCK3X*BLOCK3Y);
			qtable3a[1][k]=k?x+y<5?qtable3[1][k]/(lfogain*BLOCK3X*BLOCK3Y):qtable3[1][k]/(acgain*BLOCK3X*BLOCK3Y):dcgain*qtable3[1][k]/(BLOCK3X*BLOCK3Y);
			qtable3a[2][k]=k?x+y<5?qtable3[2][k]/(lfogain*BLOCK3X*BLOCK3Y):qtable3[2][k]/(acgain*BLOCK3X*BLOCK3Y):dcgain*qtable3[2][k]/(BLOCK3X*BLOCK3Y);
		}
		code=0;
		code=code<<32|*(uint32_t*)streamptr; streamptr+=sizeof(uint32_t);//load
		code=code<<32|*(uint32_t*)streamptr; streamptr+=sizeof(uint32_t);
	}
#ifdef _MSC_VER
	ctx_ctr=0, renorm_ctr=0;//
	int rmin=0, rmax=0;
#endif
	for(int ky=0;ky<ih;ky+=BLOCK0Y)
	{
		//int16_t *rows[]=
		//{
		//	pixels+(XPAD*NCH*NROWS+(ky/BLOCK0Y-0LL+NROWS)%NROWS)*NVAL,
		//	pixels+(XPAD*NCH*NROWS+(ky/BLOCK0Y-1LL+NROWS)%NROWS)*NVAL,
		//	pixels+(XPAD*NCH*NROWS+(ky/BLOCK0Y-2LL+NROWS)%NROWS)*NVAL,
		//	pixels+(XPAD*NCH*NROWS+(ky/BLOCK0Y-3LL+NROWS)%NROWS)*NVAL,
		//};
		int y2=ky+BLOCK0Y, dy;

		if(y2>ih)
			y2=ih;
		dy=y2-ky;
		for(int kx=0;kx<iw;kx+=BLOCK0X)
		{
			const float *tables[3]={0};
			int blocktype[3]={0};
			int x2=kx+BLOCK0X, dx;
			int den=0;

			if(x2>iw)
				x2=iw;
			dx=x2-kx;
			if(fwd)
			{
				for(int ky2=0;ky2<dy;++ky2)
				{
					imptr=image+3*(iw*(ky+ky2)+kx);
					for(int kx2=0;kx2<dx;++kx2, imptr+=3)
					{
						((int*)blocks[0])[BLOCK0X*ky2+kx2]=imptr[0];
						((int*)blocks[1])[BLOCK0X*ky2+kx2]=imptr[1];
						((int*)blocks[2])[BLOCK0X*ky2+kx2]=imptr[2];
					}
					for(int kx2=dx;kx2<BLOCK0X;++kx2)
					{
						blocks[0][BLOCK0X*ky2+kx2]=blocks[0][BLOCK0X*ky2+dx-1];
						blocks[1][BLOCK0X*ky2+kx2]=blocks[1][BLOCK0X*ky2+dx-1];
						blocks[2][BLOCK0X*ky2+kx2]=blocks[2][BLOCK0X*ky2+dx-1];
					}
				}
				for(int ky2=dy;ky2<BLOCK0Y;++ky2)
				{
					memcpy(blocks[0]+BLOCK0X*ky2, blocks[0]+BLOCK0X*(dy-1), sizeof(float[BLOCK0X]));
					memcpy(blocks[1]+BLOCK0X*ky2, blocks[1]+BLOCK0X*(dy-1), sizeof(float[BLOCK0X]));
					memcpy(blocks[2]+BLOCK0X*ky2, blocks[2]+BLOCK0X*(dy-1), sizeof(float[BLOCK0X]));
				}
				for(int kc=0;kc<3;++kc)
				{
					for(int k=0;k<BLOCK0X*BLOCK0Y/16;++k)
						cvti2f(((float*)blocks[kc])+16*k);
				}
				for(int k=0;k<BLOCK0X*BLOCK0Y/16;++k)
					rgb2yuv(
						((float*)blocks[0])+16*k,
						((float*)blocks[1])+16*k,
						((float*)blocks[2])+16*k
					);
				double sad[3]={0};
				for(int ky=0;ky<BLOCK0Y;++ky)
				{
					for(int kx=1;kx<BLOCK0X;++kx)
					{
						sad[0]+=fabsf(blocks[0][BLOCK0X*ky+kx]-blocks[0][BLOCK0X*ky+kx-1]);
						sad[1]+=fabsf(blocks[1][BLOCK0X*ky+kx]-blocks[1][BLOCK0X*ky+kx-1]);
						sad[2]+=fabsf(blocks[2][BLOCK0X*ky+kx]-blocks[2][BLOCK0X*ky+kx-1]);
					}
				}
				for(int ky=1;ky<BLOCK0Y;++ky)
				{
					for(int kx=0;kx<BLOCK0X;++kx)
					{
						sad[0]+=fabsf(blocks[0][BLOCK0X*ky+kx]-blocks[0][BLOCK0X*(ky-1)+kx]);
						sad[1]+=fabsf(blocks[1][BLOCK0X*ky+kx]-blocks[1][BLOCK0X*(ky-1)+kx]);
						sad[2]+=fabsf(blocks[2][BLOCK0X*ky+kx]-blocks[2][BLOCK0X*(ky-1)+kx]);
					}
				}
				sad[0]*=1./(2*BLOCK0X*(BLOCK0Y-1));
				sad[1]*=1./(2*BLOCK0X*(BLOCK0Y-1));
				sad[2]*=1./(2*BLOCK0X*(BLOCK0Y-1));
				static const double thresholds[]=
				{
					4.410167,
					1.346712,
					1.180267,
				};
				blocktype[0]=DCTsize32;
				blocktype[1]=DCTsize32;
				blocktype[2]=DCTsize32;
				if(sad[0]>thresholds[0]/2)blocktype[0]=DCTsize16;
				if(sad[1]>thresholds[1]/2)blocktype[1]=DCTsize16;
				if(sad[2]>thresholds[2]/2)blocktype[2]=DCTsize16;
				if(sad[0]>thresholds[0]*1)blocktype[0]=DCTsize8;
				if(sad[1]>thresholds[1]*1)blocktype[1]=DCTsize8;
				if(sad[2]>thresholds[2]*1)blocktype[2]=DCTsize8;
				if(sad[0]>thresholds[0]*2)blocktype[0]=DCTsize4;
				if(sad[1]>thresholds[1]*2)blocktype[1]=DCTsize4;
				if(sad[2]>thresholds[2]*2)blocktype[2]=DCTsize4;
				for(int kc=0;kc<3;++kc)
				{
					switch(blocktype[kc])
					{
					case DCTsize32:
						for(int k=0;k<32/4;++k)
							dctii_32(blocks[kc]+4*k, 32);
						transpose32x32(blocks[kc]);
						for(int k=0;k<32/4;++k)
							dctii_32(blocks[kc]+4*k, 32);
						for(int k=0;k<32*32;++k)
							blocks[kc][k]*=qtable0a[kc][k];
						break;
					case DCTsize16:
						{
							enum
							{
								BLOCK_L=32,
								BLOCK_S=16,
								XBLOCKS=BLOCK_L/BLOCK_S,
							};
							for(int by=0;by<XBLOCKS;++by)
							{
								for(int bx=0;bx<XBLOCKS;++bx)
								{
									float *block=blocks[kc]+16*(32*by+bx);
									for(int k=0;k<16/4;++k)
										dctii_16(block+4*k, 32);
								}
							}
							transpose32x32(blocks[kc]);
							for(int by=0;by<XBLOCKS;++by)
							{
								for(int bx=0;bx<XBLOCKS;++bx)
								{
									float *block=blocks[kc]+16*(32*by+bx);
									for(int k=0;k<16/4;++k)
										dctii_16(block+4*k, 32);
									for(int ky2=0;ky2<16;++ky2)
									{
										for(int kx2=0;kx2<16;++kx2)
											block[32*ky2+kx2]*=qtable1a[kc][16*ky2+kx2];
									}
									//for(int k=0;k<16*16/16;++k)
									//	gain(block+16*k, qtable1[kc]+16*k, 4, 4);
								}
							}
#if 0
							{//2x2 DCT
								float dc[XBLOCKS*XBLOCKS]={0};
								for(int ky2=0;ky2<XBLOCKS;++ky2)
								{
									for(int kx2=0;kx2<XBLOCKS;++kx2)
										dc[XBLOCKS*ky2+kx2]=blocks[kc][XBLOCKS*(32*ky2+kx2)];
								}
								float d2[XBLOCKS*XBLOCKS]={0};
								d2[0]=dc[0]+dc[1];
								d2[1]=dc[0]-dc[1];
								d2[2]=dc[2]+dc[3];
								d2[3]=dc[2]-dc[3];

								dc[0]=d2[0]+d2[2];
								dc[2]=d2[0]-d2[2];
								dc[1]=d2[1]+d2[3];
								dc[3]=d2[1]-d2[3];
								for(int ky2=0;ky2<XBLOCKS;++ky2)
								{
									for(int kx2=0;kx2<XBLOCKS;++kx2)
										blocks[kc][XBLOCKS*(32*ky2+kx2)]=dc[XBLOCKS*ky2+kx2];
								}
							}
#endif
						}
						break;
					case DCTsize8:
						for(int by=0;by<32/8;++by)
						{
							for(int bx=0;bx<32/8;++bx)
							{
								float *block=blocks[kc]+8*(32*by+bx);
								for(int k=0;k<8/4;++k)
									dctii_8(block+4*k, 32);
							}
						}
						transpose32x32(blocks[kc]);
						for(int by=0;by<32/8;++by)
						{
							for(int bx=0;bx<32/8;++bx)
							{
								float *block=blocks[kc]+8*(32*by+bx);
								for(int k=0;k<8/4;++k)
									dctii_8(block+4*k, 32);
								for(int ky2=0;ky2<8;++ky2)
								{
									for(int kx2=0;kx2<8;++kx2)
										block[32*ky2+kx2]*=qtable2a[kc][8*ky2+kx2];
								}
							}
						}
						break;
					case DCTsize4:
						for(int by=0;by<32/4;++by)
						{
							for(int bx=0;bx<32/4;++bx)
							{
								float *block=blocks[kc]+4*(32*by+bx);
								for(int k=0;k<4/4;++k)
									dctii_4(block+4*k, 32);
							}
						}
						transpose32x32(blocks[kc]);
						for(int by=0;by<32/4;++by)
						{
							for(int bx=0;bx<32/4;++bx)
							{
								float *block=blocks[kc]+4*(32*by+bx);
								for(int k=0;k<4/4;++k)
									dctii_4(block+4*k, 32);
								for(int ky2=0;ky2<4;++ky2)
								{
									for(int kx2=0;kx2<4;++kx2)
										block[32*ky2+kx2]*=qtable3a[kc][4*ky2+kx2];
								}
							}
						}
						break;
					}
				}
				for(int kc=0;kc<3;++kc)
				{
					for(int k=0;k<BLOCK0X*BLOCK0Y/16;++k)
						cvtf2i(((float*)blocks[kc])+16*k);
				}
#if 0
				dct4y4_fwd(blocks[0]);
				dct4y4_fwd(blocks[1]);
				dct4y4_fwd(blocks[2]);
				transpose4x4(blocks[0]);
				transpose4x4(blocks[1]);
				transpose4x4(blocks[2]);
				dct4y4_fwd(blocks[0]);
				dct4y4_fwd(blocks[1]);
				dct4y4_fwd(blocks[2]);
#if defined _MSC_VER && 0
				for(int kc=0;kc<3;++kc)for(int k=0;k<BLOCK0X*BLOCK0Y;++k)sum_before[kc][k]+=fabsf(blocks[kc][k]);
#endif
				gain(blocks[0], qtable0[0]);
				gain(blocks[1], qtable0[1]);
				gain(blocks[2], qtable0[2]);
				cvtf2i(blocks[0]);
				cvtf2i(blocks[1]);
				cvtf2i(blocks[2]);
#endif
#if defined _MSC_VER && 0
				for(int kc=0;kc<3;++kc)for(int k=0;k<BLOCK0X*BLOCK0Y;++k)sum_after[kc][k]+=abs(((int*)blocks[kc])[k]);
#endif
			}
			for(int kc=0;kc<3;++kc)
			{
				int blocksize=32, xblocks=1;
				if(fwd)
				{
					if(range<=0xFFFF)
					{
#ifdef _MSC_VER
						++renorm_ctr;
#endif
						*(uint32_t*)streamptr=(uint32_t)(low>>32);
						streamptr+=sizeof(uint32_t);
						low<<=32;
						range=range<<32|0xFFFFFFFF;
						if(range>~low)
							range=~low;
					}
				}
				else
				{
					if(range<=0xFFFF)//stall: unpredictable branch
					{
#ifdef _MSC_VER
						++renorm_ctr;
#endif
#ifdef _MSC_VER
						if(streamptr>streamend)
							CRASH("");
#endif
						code=code<<32|*(uint32_t*)streamptr;
						streamptr+=sizeof(uint32_t);
						low<<=32;
						range=range<<32|0xFFFFFFFF;
						if(range>~low)
							range=~low;
					}
					blocktype[kc]=(int)(((code-low)*4+3)/range);
#ifdef _MSC_VER
					if((unsigned)blocktype[kc]>3)
						CRASH("");
#endif
				}
				low+=range*blocktype[kc]>>2;
				range=(range>>2)-1;
#ifdef FIFOVAL
				if(fwd)
				{
					//printf("%d", blocktype[kc]);//
					//if(kc==2&&x2==iw)
					//	printf("\n");
					//else if(kc==2)
					//	printf(" ");

					valfifo_enqueue(blocktype[kc]);
				}
				else
					valfifo_check(blocktype[kc]);
#endif
				tables[kc]=qtable0[kc];
				if(blocktype[kc]==1)blocksize=16, xblocks=2, tables[kc]=qtable1[kc];
				if(blocktype[kc]==2)blocksize= 8, xblocks=4, tables[kc]=qtable2[kc];
				if(blocktype[kc]==3)blocksize= 4, xblocks=8, tables[kc]=qtable3[kc];
				int dcsize=blocksize/4, dcstride=6*xdc;
				for(int by=0, idx2=0;by<xblocks;++by)
				{
					for(int bx=0;bx<xblocks;++bx)
					{
						int
							idx	=6*(xdc*(ky*4/BLOCK0Y)+kx*4/BLOCK0X)+kc,
							NNN	=idx+0*6-3*dcstride<0?0:dcbuf[idx+0*6-3*dcstride+0],
							NN	=idx+0*6-2*dcstride<0?0:dcbuf[idx+0*6-2*dcstride+0],
							NW	=idx-1*6-1*dcstride<0?0:dcbuf[idx-1*6-1*dcstride+0],
							N	=idx+0*6-1*dcstride<0?0:dcbuf[idx+0*6-1*dcstride+0],
							WWW	=idx-3*6+0*dcstride<0?0:dcbuf[idx-3*6+0*dcstride+0],
							WW	=idx-2*6+0*dcstride<0?0:dcbuf[idx-2*6+0*dcstride+0],
							W	=idx-1*6+0*dcstride<0?0:dcbuf[idx-1*6+0*dcstride+0],
							eN	=idx+0*6-1*dcstride<0?0:dcbuf[idx+0*6-1*dcstride+3],
							eW	=idx-1*6+0*dcstride<0?0:dcbuf[idx-1*6+0*dcstride+3];
						for(int ky2=0;ky2<blocksize;++ky2)
						{
							for(int kx2=0;kx2<blocksize;++kx2, ++idx2)
							{
								int p1=0;
								
							//	if(ky==2852&&kx==4288)//
							//	if(ky==2852&&kx==4284)//
							//	if(ky==0&&kx==8)//
							//	if(ky==0&&kx==12)//
							//	if(ky==0&&kx==2804)//
							//	if(ky==0&&kx==8&&!kc&&!k)//
							//	if(ky==2852&&kx==4284&&kc==1&&k==8)//
							//	if(ky==12&&kx==1172&&!kc&&!k)//
							//	if(ky==8&&kx==1676&&!kc&&!k)//
							//	if(ky==0&&kx==0&&kc==1&&!k)//
							//	if(ky==0&&kx==0&&kc==0&&k==1)//
							//	if(ky==0&&kx==4&&kc==0&&k==1)//
							//	if(ky==0&&kx==256&&kc==1&&k==0)//
							//	if(ky==0&&kx==256&&kc==0&&k==0)//
							//	if(ky==0&&kx==256&&kc==0&&k==0)//
							//	if(ky==2652&&kx==3132&&kc==1&&k==7)//
							//	if(ky==0&&kx==0&&kc==0&&k==4)//
							//	if(ky==0&&kx==96&&kc==0&&ky2==31&&kx2==29)//
							//		printf("");

								if(!idx2)
								{
									int vmax=N, vmin=W;
									if(N<W)vmin=N, vmax=W;
									if(vmin>NW)vmin=NW;
									if(vmax<NW)vmax=NW;
									if(vmin>WW)vmin=WW;
									if(vmax<WW)vmax=WW;
									if(vmin>NN)vmin=NN;
									if(vmax<NN)vmax=NN;
#define PRED(E) estim[j]=E; pred+=weights[kc][j]*estim[j]; ++j;
									int j=0;
									PREDLIST
#undef  PRED
									pred>>=SHIFT;
									p1=pred;
									CLAMP2(pred, vmin, vmax);

									ctx=FLOOR_LOG2(eW*eN+1);
									if(ctx>NCTX_DC-1)
										ctx=NCTX_DC-1;
								}
								else
								{
									pred=0;
									ctx=(int)(tables[kc][blocksize*ky2+kx2]*0.125f);
									if(ctx>NCTX_AC-1)
										ctx=NCTX_AC-1;
									ctx+=NCTX_DC;
								}
								ctx+=NCTX*kc;
								
#ifdef _MSC_VER
								ctx_ctr+=ctx==18;
								//if(ctx_ctr==1114)
								//	printf("");
#endif
								
								uint32_t *currhist=hists+NLEVELS*ctx;
								den=hweight[ctx]+NLEVELS;
								if(fwd)
								{
#ifdef FIFOVAL
									valfifo_enqueue(ctx<<24^p1<<12^pred);
#endif
									curr=((int*)blocks[kc])[32*(blocksize*by+ky2)+blocksize*bx+kx2];
									//if(curr<-(NLEVELS>>1)||curr>(NLEVELS>>1)-1)
									//	CRASH("");
#ifdef _MSC_VER
									if(rmin>curr)rmin=curr;
									if(rmax<curr)rmax=curr;
#endif
									CLAMP2(curr, -(NLEVELS>>1), (NLEVELS>>1)-1);
									error=((curr-pred+(NLEVELS>>1))&(NLEVELS-1))-(NLEVELS>>1);
									sym=error<<1^error>>31;

									if(range<=0xFFFF)
									{
#ifdef _MSC_VER
										//if(renorm_ctr==423+2)
										//	printf("");
										++renorm_ctr;
#endif
										*(uint32_t*)streamptr=(uint32_t)(low>>32);
										streamptr+=sizeof(uint32_t);
										low<<=32;
										range=range<<32|0xFFFFFFFF;
										if(range>~low)
											range=~low;
									}
									int t=0;
									cdf=0;
									for(;;)
									{
										freq=currhist[t]+1;
										if(t>=sym)
											break;
										cdf+=freq;
										++t;
									}
									if(cdf)
										cdf+=0;
#ifdef _MSC_VER
									if(!freq
										||(uint32_t)freq>(uint32_t)den
										||(uint32_t)cdf>(uint32_t)den
										||(uint32_t)(cdf+freq)>(uint32_t)den
										||den>0xFFFF
									)
										CRASH("");
#endif
#ifdef FIFOVAL
									valfifo_enqueue(freq<<16|cdf);
#endif
									low+=range*cdf/den;
									range=range*freq/den-1;
#ifdef PROFILE_SIZE
									csizes[kc][idx2!=0]+=-log2((double)freq/den);
#endif
								}
								else
								{
#ifdef FIFOVAL
									valfifo_check(ctx<<24^p1<<12^pred);
#endif
									if(range<=0xFFFF)//stall: unpredictable branch
									{
#ifdef _MSC_VER
										//if(renorm_ctr==423)
										//	printf("");
										++renorm_ctr;
#endif
#ifdef _MSC_VER
										if(streamptr>streamend)
											CRASH("");
#endif
										code=code<<32|*(uint32_t*)streamptr;
										streamptr+=sizeof(uint32_t);
										low<<=32;
										range=range<<32|0xFFFFFFFF;
										if(range>~low)
											range=~low;
									}
									int c2=(int)(((code-low+1)*den-1)/range);
									sym=0;
									cdf=0;
									for(;;)
									{
										freq=currhist[sym]+1;
										if(cdf+freq>c2)
											break;
										cdf+=freq;
										++sym;
									}
#ifdef FIFOVAL
									if(cdf)//
										cdf+=0;//
									valfifo_check(freq<<16|cdf);
#endif
									low+=range*cdf/den;
									range=range*freq/den-1;
									error=sym>>1^-(sym&1);
									curr=((error+pred+(NLEVELS>>1))&(NLEVELS-1))-(NLEVELS>>1);
									((int*)blocks[kc])[32*(blocksize*by+ky2)+blocksize*bx+kx2]=curr;
									error=curr-pred;
								}
								++currhist[sym];
								++hweight[ctx];
								if(hweight[ctx]>=0x4000)
								{
									den=0;
									for(int k=0;k<NLEVELS;++k)
										den+=currhist[k]>>=1;
									hweight[ctx]=den;
								}
								if(!idx2)
								{
									int e=(curr>p1)-(curr<p1);
#define PRED(...) weights[kc][j]+=e*estim[j]; ++j;
									int j=0;
									PREDLIST
#undef  PRED
									for(int ky3=0;ky3<dcsize;++ky3)
									{
										for(int kx3=0;kx3<dcsize;++kx3)
										{
											int idx3=6*(xdc*(ky*4/BLOCK0Y+ky3)+kx*4/BLOCK0X+kx3)+kc;
											dcbuf[idx3+0]=curr;
											dcbuf[idx3+3]=sym;
										}
									}
								}
							}
						}
					}
				}
			}
			if(!fwd)
			{
#if 0
				cvti2f(blocks[0]);
				cvti2f(blocks[1]);
				cvti2f(blocks[2]);
				gain(blocks[0], qtable0[0]);
				gain(blocks[1], qtable0[1]);
				gain(blocks[2], qtable0[2]);
				dct4y4_inv(blocks[0]);
				dct4y4_inv(blocks[1]);
				dct4y4_inv(blocks[2]);
				transpose4x4(blocks[0]);
				transpose4x4(blocks[1]);
				transpose4x4(blocks[2]);
				dct4y4_inv(blocks[0]);
				dct4y4_inv(blocks[1]);
				dct4y4_inv(blocks[2]);
				yuv2rgb(blocks[0], blocks[1], blocks[2]);
				cvtf2i(blocks[0]);
				cvtf2i(blocks[1]);
				cvtf2i(blocks[2]);
#endif
				for(int kc=0;kc<3;++kc)
				{
					for(int k=0;k<BLOCK0X*BLOCK0Y/16;++k)
						cvti2f(((float*)blocks[kc])+16*k);
				}
				for(int kc=0;kc<3;++kc)
				{
					switch(blocktype[kc])
					{
					case DCTsize32:
						for(int k=0;k<32*32/16;++k)
							gain(blocks[kc]+16*k, qtable0a[kc]+16*k);
						for(int k=0;k<32/4;++k)
							dctiii_32(blocks[kc]+4*k, 32);
						transpose32x32(blocks[kc]);
						for(int k=0;k<32/4;++k)
							dctiii_32(blocks[kc]+4*k, 32);
						break;
					case DCTsize16:
						{
							enum
							{
								BLOCK_L=32,
								BLOCK_S=16,
								XBLOCKS=BLOCK_L/BLOCK_S,
							};
							for(int by=0;by<XBLOCKS;++by)
							{
								for(int bx=0;bx<XBLOCKS;++bx)
								{
									float *block=blocks[kc]+16*(32*by+bx);
									for(int ky2=0;ky2<16;++ky2)
									{
										for(int kx2=0;kx2<16;++kx2)
											block[32*ky2+kx2]*=qtable1a[kc][16*ky2+kx2];
									}
									for(int k=0;k<16/4;++k)
										dctiii_16(block+4*k, 32);
								}
							}
							transpose32x32(blocks[kc]);
							for(int by=0;by<XBLOCKS;++by)
							{
								for(int bx=0;bx<XBLOCKS;++bx)
								{
									float *block=blocks[kc]+16*(32*by+bx);
									for(int k=0;k<16/4;++k)
										dctiii_16(block+4*k, 32);
								}
							}
						}
						break;
					case DCTsize8:
						for(int by=0;by<32/8;++by)
						{
							for(int bx=0;bx<32/8;++bx)
							{
								float *block=blocks[kc]+8*(32*by+bx);
								for(int ky2=0;ky2<8;++ky2)
								{
									for(int kx2=0;kx2<8;++kx2)
										block[32*ky2+kx2]*=qtable2a[kc][8*ky2+kx2];
								}
								for(int k=0;k<8/4;++k)
									dctiii_8(block+4*k, 32);
							}
						}
						transpose32x32(blocks[kc]);
						for(int by=0;by<32/8;++by)
						{
							for(int bx=0;bx<32/8;++bx)
							{
								float *block=blocks[kc]+8*(32*by+bx);
								for(int k=0;k<8/4;++k)
									dctiii_8(block+4*k, 32);
							}
						}
						break;
					case DCTsize4:
						for(int by=0;by<32/4;++by)
						{
							for(int bx=0;bx<32/4;++bx)
							{
								float *block=blocks[kc]+4*(32*by+bx);
								for(int ky2=0;ky2<4;++ky2)
								{
									for(int kx2=0;kx2<4;++kx2)
										block[32*ky2+kx2]*=qtable3a[kc][4*ky2+kx2];
								}
								for(int k=0;k<4/4;++k)
									dctiii_4(block+4*k, 32);
							}
						}
						transpose32x32(blocks[kc]);
						for(int by=0;by<32/4;++by)
						{
							for(int bx=0;bx<32/4;++bx)
							{
								float *block=blocks[kc]+4*(32*by+bx);
								for(int k=0;k<4/4;++k)
									dctiii_4(block+4*k, 32);
							}
						}
						break;
					}
				}
				for(int k=0;k<BLOCK0X*BLOCK0Y/16;++k)
					yuv2rgb(
						((float*)blocks[0])+16*k,
						((float*)blocks[1])+16*k,
						((float*)blocks[2])+16*k
					);
				for(int kc=0;kc<3;++kc)
				{
					for(int k=0;k<BLOCK0X*BLOCK0Y/16;++k)
						cvtf2i(((float*)blocks[kc])+16*k);
				}
				for(int ky2=0;ky2<dy;++ky2)
				{
					imptr=image+3*(iw*(ky+ky2)+kx);
					for(int kx2=0;kx2<dx;++kx2, imptr+=3)
					{
						imptr[0]=((int*)blocks[0])[BLOCK0X*ky2+kx2];
						imptr[1]=((int*)blocks[1])[BLOCK0X*ky2+kx2];
						imptr[2]=((int*)blocks[2])[BLOCK0X*ky2+kx2];
					}
				}
#ifdef ENABLE_GUIDE
				for(int ky2=0;ky2<dy;++ky2)
				{
					imptr=image+3*(iw*(ky+ky2)+kx);
					for(int kx2=0;kx2<dx;++kx2, imptr+=3)
					{
						int diff;

						diff=g_image[imptr-image+0]-imptr[0]; g_sqe[0]+=diff*diff;
						diff=g_image[imptr-image+1]-imptr[1]; g_sqe[1]+=diff*diff;
						diff=g_image[imptr-image+2]-imptr[2]; g_sqe[2]+=diff*diff;
					}
				}
#endif
			}
		}
	}
#if 0
	{
		double invres=1/((double)iw*ih);
		double rmse[]=
		{
			sqrt(g_sqe[0]*invres),
			sqrt(g_sqe[1]*invres),
			sqrt(g_sqe[2]*invres),
			0,
		};
		rmse[3]=(rmse[0]+rmse[1]+rmse[2])/3;
		double psnr[]=
		{
			-20*log10(rmse[0]/255),
			-20*log10(rmse[1]/255),
			-20*log10(rmse[2]/255),
			-20*log10(rmse[3]/255),
		};
		printf(
			"RMSE  PSNR\n"
			"T %12.6lf  %12.6lf\n"
			"Y %12.6lf  %12.6lf\n"
			"U %12.6lf  %12.6lf\n"
			"V %12.6lf  %12.6lf\n"
			, rmse[3], psnr[3]
			, rmse[0], psnr[0]
			, rmse[1], psnr[1]
			, rmse[2], psnr[2]
		);
	}
	exit(0);
#endif
	//free(pixels);
	free(dcbuf);

	fdst=fopen(dstfn, "wb");
	if(!fdst)
	{
		CRASH("Cannot open \"%s\" for writing", dstfn);
		return 1;
	}
	if(fwd)
	{
		*(uint32_t*)streamptr=(uint32_t)(low>>32); streamptr+=sizeof(uint32_t); low<<=32;//flush
		*(uint32_t*)streamptr=(uint32_t)(low>>32); streamptr+=sizeof(uint32_t); low<<=32;
		
		csize+=fwrite(&tag, 1, 2, fdst);
		csize+=fwrite(&iw, 1, 3, fdst);
		csize+=fwrite(&ih, 1, 3, fdst);
		csize+=fwrite(stream, 1, streamptr-stream, fdst);
	}
	else
	{
		fprintf(fdst, "P6\n%d %d\n255\n", iw, ih);
		fwrite(image, 1, usize, fdst);
	}
	fclose(fdst);
#ifdef LOUD
	t=time_sec()-t;
	if(fwd)
	{
#ifdef _MSC_VER
		printf("%d ~ %d\n", rmin, rmax);
#endif
#ifdef PROFILE_SIZE
		double sum=0;
		for(int kc=0;kc<3;++kc)
		{
			for(int k=0;k<2;++k)
				sum+=csizes[kc][k];
		}
		if(!sum)
			sum=1;
		sum=100/sum;
		for(int kc=0;kc<3;++kc)
		{
			double sum2=0;
			for(int k=0;k<2;++k)
				sum2+=csizes[kc][k];
			printf("%c: %12.2lf\n", "YUV"[kc], sum2);
			for(int k=0;k<2;++k)
				printf("  %12.2lf %8.4lf%%\n"
					, csizes[kc][k]
					, csizes[kc][k]*sum
				);
			//for(int ky=0;ky<BLOCKY;++ky)
			//{
			//	for(int kx=0;kx<BLOCKY;++kx)
			//		printf("  %12.2lf %8.4lf%%"
			//			, csizes[kc][ky*BLOCKX+kx]
			//			, csizes[kc][ky*BLOCKX+kx]*sum
			//		);
			//	printf("\n");
			//}
			//printf("\n");
		}
#endif
#if defined _MSC_VER && 0
		for(int kc=0;kc<3;++kc)
		{
			printf("%c before quant:\n", "YUV"[kc]);
			for(int ky=0;ky<BLOCKY;++ky)
			{
				for(int kx=0;kx<BLOCKY;++kx)
					printf(" %16.0lf", sum_before[kc][BLOCKX*ky+kx]);
				printf("\n");
			}
			printf("\n");
			printf("%c after quant:\n", "YUV"[kc]);
			for(int ky=0;ky<BLOCKY;++ky)
			{
				for(int kx=0;kx<BLOCKY;++kx)
					printf(" %16.0lf", sum_after[kc][BLOCKX*ky+kx]);
				printf("\n");
			}
			printf("\n");
		}
#endif
		printf("WH %5d*%5d  \"%s\"\n", iw, ih, srcfn);
		printf("%9td->%9td  %8.4lf%%  %12.6lf:1  BPD %12.6lf\n"
			, usize
			, csize
			, 100.*csize/usize
			, (double)usize/csize
			, 8.*csize/usize
		);
	}
	printf("%c  %12.6lf sec  %12.6lf MB/s  %12.6lf ms/MB\n"
		, 'D'+fwd
		, t
		, usize/(t*1024*1024)
		, t*1024*1024*1000/usize
	);
	if(!fwd)
	{
		double invres=1/((double)iw*ih);
		double rmse[]=
		{
			sqrt(g_sqe[0]*invres),
			sqrt(g_sqe[1]*invres),
			sqrt(g_sqe[2]*invres),
			0,
		};
		rmse[3]=(rmse[0]+rmse[1]+rmse[2])/3;
		double psnr[]=
		{
			-20*log10(rmse[0]/255),
			-20*log10(rmse[1]/255),
			-20*log10(rmse[2]/255),
			-20*log10(rmse[3]/255),
		};
		printf(
			"RMSE  PSNR\n"
			"T %12.6lf  %12.6lf\n"
			"Y %12.6lf  %12.6lf\n"
			"U %12.6lf  %12.6lf\n"
			"V %12.6lf  %12.6lf\n"
			, rmse[3], psnr[3]
			, rmse[0], psnr[0]
			, rmse[1], psnr[1]
			, rmse[2], psnr[2]
		);
	}
#endif
	(void)&time_sec;
	(void)csize;
	return 0;
}
