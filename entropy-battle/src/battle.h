#pragma once
#ifndef INC_BATTLE_H
#define INC_BATTLE_H
#ifdef _MSC_VER
#define _CRT_SECURE_NO_WARNINGS
#endif
#include"util.h"
#ifdef __cplusplus
extern "C"
{
#endif


//	#define ENABLE_GUIDE//debug

//lossless tools
void compare_bufs_uint8(unsigned char *b1, unsigned char *b0, int iw, int ih, int symbytes, int bytestride, const char *name, int backward);
void compare_bufs_ps(float *b1, float *b0, int iw, int ih, const char *name, int backward);

//Huffman Coder		TODO support channels/bytestride
int huff_compress(
	const void *src, //The source data to be compressed
	size_t srcSize,  //The count of bytes in source data
	ArrayHandle *dst //The destination array, must be a byte array.
);//Returns true on success.

int huff_decompress(
	const unsigned char *src, //The data to decompress. Must be generated by huff_compress().
	size_t srcSize,           //The byte count of data in src.
	ArrayHandle *dst          //The destination array.
);//Returns true on success.


//Binary Arithmetic Coder (AC)
long long   ac0_encode(const void *src, ptrdiff_t nbytes, int bitoffset, int bitdepth, int bytestride, ArrayHandle *out, int loud);
const void* ac0_decode(const void *srcstart, const void *srcend, void *dst, size_t nbytes, int bitoffset, int bitdepth, int bytestride, int loud
#ifdef ENABLE_GUIDE
	, unsigned char *guide
#endif
);//set the dst buffer to zero


//Adaptive Binary Arithmetic Coder (ABAC)
int         abac4_encode(const void *src, int symcount, int bitoffset, int bitdepth, int bytestride, ArrayHandle *output, int loud);
const void* abac4_decode(const void *in_start, const void *in_end, void *dst, int imsize, int bitoffset, int bitdepth, int bytestride, int loud);//set the dst buffer to zero

//abac0a: Encodes 8-bit symbols. Uses SSSE3 with 15-bit probability.
//If output was initialized, output->esize must be 1.
int         abac0a_encode(const unsigned char *src, int count, int bytestride, ArrayHandle *output, int loud);
const void* abac0a_decode(const void *src_start, const void *src_end, unsigned char *dst, int count, int bytestride, int loud);//set the dst buffer to zero


//Range-Asymmetric Numeral Systems (rANS)
typedef enum RANS_ErrorEnum
{
	RANS_INVALID_NBYTES=-5,
	RANS_INVALID_SYMBYTES,
	RANS_INVALID_DST,

	RANS_INVALID_TAG,
	RANS_BUFFER_OVERRUN,
	
	RANS_SUCCESS,
} RANS_Error;
int rans4_encode(const void *src, ptrdiff_t nsymbols, int symbytes, int bytestride, ArrayHandle *out, unsigned short *custom_pred);//symbytes: up to 16
int rans4_decode(const unsigned char *srcdata, ptrdiff_t srclen, ptrdiff_t nsymbols, int symbytes, int bytestride, void *dstbuf, unsigned short *custom_pred);

//test
int rans8_testencode(const void *src, int bw, int bh, int bitdepth, int bytestride, unsigned short prob_MPS, ArrayHandle *out);
int rans0b_testencode(const void *src, int bw, int bh, int bitdepth, int bytestride, int blockdim, int prob_bits, ArrayHandle *out);
size_t rans0c_testencode(const void *src, int bw, int bh, int symbytes, int bytestride, ArrayHandle *out);

//	#define PROB32

#ifdef PROB32
typedef unsigned Prob;
typedef unsigned long long State;
#else
typedef unsigned short Prob;
typedef unsigned State;
#endif
#define PROBBITS (sizeof(Prob)<<3)
#define ONE (State)(1LL<<PROBBITS)
Prob* rans5_preptable();
long long rans5_encode(const void *src, int bw, int bh, int symbytes, int bytestride, ArrayHandle *out, Prob *table);

//rans_sse2: symbytes must be a power of two, nbytes must be divisible by 16
int rans_sse2_encode(const void *src, size_t nbytes, int symbytes, int is_signed, ArrayHandle *out);
int rans_sse2_decode(const void *srcdata, size_t srclen, void *dstbuf, size_t nbytes, int symbytes, int is_signed
#ifdef ENABLE_GUIDE
	, unsigned char *guide
#endif
);


//WIP
int                  uabs_encode_ch(const void *src, size_t nbytes, int bitoffset, int bitdepth, int bytestride, ArrayHandle *out);
const unsigned char* uabs_decode_ch(const unsigned char *data, size_t srclen, void *dst, size_t nbytes, int bitoffset, int bitdepth, int bytestride
#ifdef ENABLE_GUIDE
	, const unsigned char *guide
#endif
);


int arans_encode(const void *src, ptrdiff_t nbytes, int bytestride, ArrayHandle *out);


//long long lz_encode(const void *src, int bw, int bh, int bytestride, ArrayHandle *data, size_t *ret_overhead);//FIXME encoding channels separately

//extern int lz2_limit;
//void lz2_encode(unsigned char *buf, int len, ArrayHandle *coeff, ArrayHandle *bypass);//undecodable

//long long test1_encode(const void *src, int bw, int bh, int symbytes, int bytestride, ArrayHandle *data);//undecodable
//long long test2_encode(const void *src, int bw, int bh, int symbytes, int bytestride, ArrayHandle *data);//undecodable

//size_t lz2d_encode(const unsigned char *buf, int bw, int bh, int symbytes, int bytestride, ArrayHandle *mask, ArrayHandle *coeff);
//size_t lz2d2_encode(const unsigned char *buf, int bw, int bh, int symbytes, int bytestride, ArrayHandle *mask, ArrayHandle *rle, ArrayHandle *lz);
size_t lz2d3_encode(const unsigned char *buf, int bw, int bh, int symbytes, int bytestride, ArrayHandle *mask, ArrayHandle *rle, ArrayHandle *lz);
size_t test3_encode(const void *src, int bw, int bh, int symbytes, int bytestride, ArrayHandle *data, int diff);//returns bytes saved by lz2d3_encode()
int    test3_decode(const void *src, ptrdiff_t srclen, int iw, int ih, int symbytes, int bytestride, void *dst, int diff);
void   test3_printsummary(ArrayHandle cdata, size_t savedbytes, size_t usize, int symbytes);

//extern unsigned char *buf0;//

//XYB, squeeze DWT, ANS (inspired by JPEG XL but worse)
size_t test4_encode(const unsigned char *src, int bw, int bh, ArrayHandle *data);
int    test4_decode(const unsigned char *data, size_t srclen, int bw, int bh, unsigned char *buf);

//adaptive binary ANS test
size_t test5_encode(const unsigned char *src, int bw, int bh, ArrayHandle *data);
int    test5_decode(const unsigned char *data, size_t srclen, int bw, int bh, unsigned char *buf);

size_t test6_encode(const unsigned char *src, int bw, int bh, ArrayHandle *data);

void   codec33_init(const char *filename);
size_t codec33_encode(const unsigned char *src, int bw, int bh, ArrayHandle *data);

//size_t test7_encode(const unsigned char *src, int bw, int bh, int is_unsigned, ArrayHandle *data);

size_t test8_encode(const unsigned char *src, int bw, int bh, int transform, ArrayHandle *data);
int    test8_decode(const unsigned char *data, size_t srclen, int bw, int bh, int detransform, unsigned char *buf);

double get_mean(const unsigned char *buf, int res, int stride);
double get_var(const unsigned char *buf, int res, int stride, double mean);
//size_t test9_encode(const unsigned char *src, int bw, int bh, ArrayHandle *data);

size_t test10_encode(const unsigned char *src, int bw, int bh, ArrayHandle *data);
int    test10_decode(const unsigned char *data, size_t srclen, int bw, int bh, unsigned char *buf);

//size_t ans128_encode(const void *src, ptrdiff_t symcount, int *depths, int nch, int bytestride, ArrayHandle *data);//depth up to 32 bit per channel, channels can be packed, each symbol must start at new byte
//int    ans128_decode(const unsigned char *data, ptrdiff_t srclen, ptrdiff_t symcount, int *depths, int nch, int bytestride, void *dst);

size_t ans16_encode(const unsigned char *src, ptrdiff_t res, ArrayHandle *data);

size_t test14_encode(const unsigned char *src, int bw, int bh, int lgblockdim, ArrayHandle *data);

size_t test16_encode(const unsigned char *src, int bw, int bh, int alpha, int blocksize, int margin, ArrayHandle *data, int loud);
int    test16_decode(const unsigned char *data, size_t srclen, int bw, int bh, int alpha, int blocksize, int margin, unsigned char *buf);

#if 0
//void test17_saveconf(const unsigned char *src, int bw, int bh, int blocksize);
size_t test17_encode(const unsigned char *src, int bw, int bh, int blocksize, int alpha, ArrayHandle *data, int loud);
int    test17_decode(const unsigned char *data, size_t srclen, int bw, int bh, int blocksize, int alpha, unsigned char *buf);

size_t test18_encode(const unsigned char *src, int bw, int bh, ArrayHandle *data);

extern unsigned char *debug_ptr;
size_t test19_encode(const unsigned char *src, int bw, int bh, int alpha, int blocksize, int margin, ArrayHandle *data, int loud);
int test19_decode(const unsigned char *data, size_t srclen, int bw, int bh, int alpha, int blocksize, int margin, unsigned char *buf);

size_t test20_encode(const unsigned char *src, int bw, int bh, int blocksize, int margin, int alpha, int blockcount, ArrayHandle *data, int loud);
int test20_decode(const unsigned char *data, size_t srclen, int bw, int bh, int blocksize, int margin, int alpha, int blockcount, unsigned char *buf);

int    e10_encode_ch(const unsigned char *src, int bw, int bh, int kc, ArrayHandle *data, int loud);
size_t e10_decode_ch(const unsigned char *data, size_t datastart, size_t datalen, int bw, int bh, int kc, unsigned char *buf);

int    e10dash_encode_ch(const unsigned char *src, int bw, int bh, int kc, int alpha, int blocksize, int margin, ArrayHandle *data, int loud);
size_t e10dash_decode_ch(const unsigned char *data, size_t datastart, size_t datalen, int bw, int bh, int kc, int alpha, int blocksize, int margin, unsigned char *buf);
#endif




//transforms
void apply_transforms_fwd(unsigned char *buf, int bw, int bh);
void apply_transforms_inv(unsigned char *buf, int bw, int bh);

void addbuf(unsigned char *buf, int iw, int ih, int nch, int bytestride, int ammount);

void colortransform_xgz_fwd(char *buf, int iw, int ih);//3 channels, stride 4 bytes
void colortransform_xgz_inv(char *buf, int iw, int ih);
void colortransform_xyz_fwd(char *buf, int iw, int ih);//3 channels, stride 4 bytes
void colortransform_xyz_inv(char *buf, int iw, int ih);
void colortransform_ycocg_fwd(char *buf, int iw, int ih);
void colortransform_ycocg_inv(char *buf, int iw, int ih);
void colortransform_ycocgt_fwd(char *buf, int iw, int ih);//like YCoCg but with g & b swapped
void colortransform_ycocgt_inv(char *buf, int iw, int ih);

//YCoCg-R		8 bit <-> ps,  3 channels, pixel stride 4 bytes,  Y in [0, 1], Co/Cg in [-1, 1],  used by AVC/HEVC/VVC
void YCoCg_8bit_ps_fwd(const unsigned char *src, ptrdiff_t res, float *bufY, float *bufCo, float *bufCg);
void YCoCg_8bit_ps_inv(const float *bufY, const float *bufCo, const float *bufCg, ptrdiff_t res, unsigned char *dst);


extern double jxlpred_params[33];
void pred_jxl(char *buf, int iw, int ih, int nch, int bytestride, int fwd);

void image_differentiate(char *buf, int iw, int ih, int nch, int bytestride);
void image_integrate    (char *buf, int iw, int ih, int nch, int bytestride);
void pred_grad_fwd     (char *buf, int iw, int ih, int nch, int bytestride);
void pred_grad_inv     (char *buf, int iw, int ih, int nch, int bytestride);


typedef struct DWTSizeStruct
{
	unsigned short w, h;
} DWTSize;
ArrayHandle dwt2d_gensizes(int iw, int ih, int wstop, int hstop, int nstages_override);//calculate dimensions of each DWT stage in descending order

//8bit DWTs			temp size is max(w, h)
void dwt2d_lazy_fwd   (char *buffer, DWTSize *sizes, int sizes_start, int sizes_end, int stride, char *temp);
void dwt2d_lazy_inv   (char *buffer, DWTSize *sizes, int sizes_start, int sizes_end, int stride, char *temp);
void dwt2d_haar_fwd   (char *buffer, DWTSize *sizes, int sizes_start, int sizes_end, int stride, char *temp);
void dwt2d_haar_inv   (char *buffer, DWTSize *sizes, int sizes_start, int sizes_end, int stride, char *temp);
void dwt2d_squeeze_fwd(char *buffer, DWTSize *sizes, int sizes_start, int sizes_end, int stride, char *temp);
void dwt2d_squeeze_inv(char *buffer, DWTSize *sizes, int sizes_start, int sizes_end, int stride, char *temp);
void dwt2d_cdf53_fwd  (char *buffer, DWTSize *sizes, int sizes_start, int sizes_end, int stride, char *temp);
void dwt2d_cdf53_inv  (char *buffer, DWTSize *sizes, int sizes_start, int sizes_end, int stride, char *temp);
void dwt2d_cdf97_fwd  (char *buffer, DWTSize *sizes, int sizes_start, int sizes_end, int stride, char *temp);
void dwt2d_cdf97_inv  (char *buffer, DWTSize *sizes, int sizes_start, int sizes_end, int stride, char *temp);

//lifting-based 9/7 DWT
void dwt2d_ps_fwd(float *buffer, DWTSize *sizes, int nsizes);//sizes in descending order
void dwt2d_ps_inv(float *buffer, DWTSize *sizes, int nsizes);//sizes in descending order

//Haar (squeeze) DWT: n bit -> n+1 bit		temp size is maxdim*sizeof(short)
//void squeeze_1d_fwd(short *buffer, int count, int stride, int vmax, short *b2);
void squeeze_2d_fwd(short *buffer, DWTSize *sizes, int sizes_start, int sizes_end, int stride, int vmax, short *temp);
//void squeeze_1d_inv(short *buffer, int count, int stride, int vmax, short *b2);
void squeeze_2d_inv(short *buffer, DWTSize *sizes, int sizes_start, int sizes_end, int stride, int vmax, short *temp);

void haar_2d_fwd(const unsigned char *buf, int bw, int bh, int nch, int bytestride, int nstages, short **ret);//lossless DWT, don't forget to free ret if was zero
void haar_2d_inv(short *buf, int bw, int bh, int nch, int bytestride, int nstages, unsigned char **ret);//buf is destroyed

void intDCT2_8x8_p32(const unsigned char *buf, int bw, int bh, int nch, int bytestride, unsigned short **ret);

//fast 8 point DCT-II/III      call, transpose, then call again
void transpose_block8x8_ps(float *ptr);//32 byte aligned
void DCT2_8x8_ps(float *ptr);//ptr to 64 packed floats is aligned by 32 bytes
void DCT3_8x8_ps(float *ptr);

//FCT-II/III, O(N*lg(N)), POT size (uses FFT size N)
typedef struct FCT1D_PS_ParamsStruct
{
	int lgsize;
	int *fctp;
	float *re, *im, *rew4N, *imw4N;
} FCT1D_PS_Params;
void FCT1D_ps_gen(int lgsize, FCT1D_PS_Params *p);//lgsize up to 16 (size up to 65536)
void FCT1D_ps_free(FCT1D_PS_Params *p);
void FCT1D_ps_fwd(FCT1D_PS_Params *p, float *data, int stride);
void FCT1D_ps_inv(FCT1D_PS_Params *p, float *data, int stride);


void save_32bit(const char *filename, const int *buf, int iw, int ih, int nch, int saveas8bit);
void save_16bit(const char *filename, const short *buf, const short *sub_b2, int iw, int ih, int nch, int val_offset, int val_shift, int saveas8bit);
void save_mono8(const char *filename, unsigned char *buf, int iw, int ih, int stride);
void save_squeeze(const char *name, short *buf, DWTSize *sizes, int nsizes, int stride, int maxnbits);
void save_channel(unsigned char *buf, int iw, int ih, int stride, int val_offset, const char *format, ...);
void save_DWT_int8(const char *name, unsigned char *buf, DWTSize *sizes, int nsizes, int stride);
void save_DWT_int8_all(const char *name, unsigned char *buf, DWTSize *sizes, int nsizes);


//lossy tools
typedef struct RateDistortionStruct
{
	size_t usize, rate;
	double ratio, BPP, RMSE, PSNR;
} RateDistortion;
void calc_distortion(unsigned char *b0, unsigned char *b1, int bw, int bh, int symbytes, int bytestride, RateDistortion *ret);//returned info is for each channel separately

//lossy codecs
int lossy1_encode(const void *src, int bw, int bh, int symbytes, int bytestride, ArrayHandle *data, int bitrate);
int lossy1_decode(const void *src, ptrdiff_t srclen, int iw, int ih, int symbytes, int bytestride, void *dst, int bitrate);


#ifdef __cplusplus
}
#endif
#endif//INC_BATTLE_H
